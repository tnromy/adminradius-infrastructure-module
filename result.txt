###
cat src/controllers/branch.controller.js
/**
 * Controller untuk endpoint branch
 */

const branchRepository = require('../repositories/branch.repository');
const { validateBranchEntity } = require('../entities/branch.entity');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan semua branches
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getAllBranches(req, res) {
  try {
    const context = getRequestContext();
    logDebug('Menerima request getAllBranches', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name),
      hasAccessFilter: !!req.accessibleBranchIds
    });
    
    const { scope_level, deleted } = req.query;
    
    if (scope_level && !Object.values(branchRepository.ResultTypes).includes(scope_level)) {
      logWarn('Invalid scope_level parameter', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        invalidValue: scope_level,
        validValues: Object.values(branchRepository.ResultTypes)
      });
      return res.status(400).json(createErrorResponse(
        400,
        'Invalid scope_level type',
        { valid_values: Object.values(branchRepository.ResultTypes) }
      ));
    }
    
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }

    logDebug('Mengambil data branches', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      filters: {
        scope_level: scope_level || 'default',
        deleted: deletedFilter,
        accessibleBranchCount: req.accessibleBranchIds?.length
      }
    });
    
    // Gunakan accessible branch IDs jika ada (untuk non-Client Owner)
    const branches = await branchRepository.getAllBranches(
      scope_level, 
      deletedFilter,
      req.accessibleBranchIds // Ini akan null untuk Client Owner
    );
    
    logInfo('Berhasil mengambil data branches', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      count: branches.length,
      scope_level: scope_level || 'default',
      deleted: deletedFilter,
      filteredByAccess: !!req.accessibleBranchIds
    });
    
    res.status(200).json({
      data: branches
    });
  } catch (error) {
    logError('Error pada getAllBranches', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId()
    });
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Mendapatkan branch berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getBranchById(req, res) {
  try {
    const context = getRequestContext();
    const { id } = req.params;
    
    logDebug('Menerima request getBranchById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Ambil parameter scope_level dan deleted dari query
    const { scope_level, deleted } = req.query;
    
    // Validasi parameter scope_level jika ada
    if (scope_level && !Object.values(branchRepository.ResultTypes).includes(scope_level)) {
      logWarn('Invalid scope_level parameter pada getBranchById', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id,
        invalidValue: scope_level,
        validValues: Object.values(branchRepository.ResultTypes)
      });
      
      return res.status(400).json(createErrorResponse(
        400,
        'Invalid scope_level type',
        { valid_values: Object.values(branchRepository.ResultTypes) }
      ));
    }
    
    // Tentukan filter deleted (defaultnya WITHOUT)
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }
    
    logDebug('Mengambil data branch by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      filters: {
        scope_level: scope_level || 'default',
        deleted: deletedFilter
      }
    });
    
    const branch = await branchRepository.getBranchById(id, scope_level, deletedFilter);
    
    if (!branch) {
      logWarn('Branch tidak ditemukan', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id,
        filters: {
          scope_level: scope_level || 'default',
          deleted: deletedFilter
        }
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Branch not found'
      ));
    }
    
    logInfo('Berhasil mengambil data branch by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      scope_level: scope_level || 'default',
      deleted: deletedFilter
    });
    
    res.status(200).json({
      data: branch
    });
  } catch (error) {
    logError('Error pada getBranchById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      branchId: req.params.id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Membuat branch baru
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function createBranch(req, res) {
  try {
    const context = getRequestContext();
    
    logDebug('Menerima request createBranch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Validasi telah dilakukan di middleware validation
    logDebug('Membuat branch baru', {
      requestId: context.getRequestId(),
      userId: context.getUserId()
    });
    
    const branch = await branchRepository.createBranch(req.body);
    
    logInfo('Branch berhasil dibuat', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: branch._id,
      branchName: branch.name
    });
    
    res.status(200).json({
      message: 'Branch created successfully',
      data: branch
    });
  } catch (error) {
    logError('Error pada createBranch', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      requestBody: req.body
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Mengupdate branch berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function updateBranch(req, res) {
  try {
    const context = getRequestContext();
    const { id } = req.params;
    
    logDebug('Menerima request updateBranch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    logDebug('Mengupdate branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id
    });
    
    const branch = await branchRepository.updateBranch(id, req.body);
    
    if (!branch) {
      logWarn('Branch tidak ditemukan untuk update', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Branch not found'
      ));
    }
    
    logInfo('Branch berhasil diupdate', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      branchName: branch.name
    });
    
    res.status(200).json({
      data: branch
    });
  } catch (error) {
    logError('Error pada updateBranch', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      branchId: req.params.id,
      requestBody: req.body
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menghapus branch berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteBranch(req, res) {
  try {
    const context = getRequestContext();
    const { id } = req.params;
    
    logDebug('Menerima request deleteBranch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah Branch ada
    logDebug('Memeriksa keberadaan branch sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id
    });
    
    const branch = await branchRepository.getBranchById(id, null, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!branch) {
      logWarn('Branch tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Branch not found or already deleted'
      ));
    }
    
    // Import soft delete function
    const { softDeleteBranch } = require('../utils/recursiveSoftDelete.util');
    
    // Lakukan soft delete rekursif pada Branch dan semua Router, OLT, ODC, ODP, serta ONT di dalamnya
    logDebug('Melakukan soft delete rekursif pada branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      branchName: branch.name
    });
    
    const result = await softDeleteBranch(branch._id);
    
    if (!result) {
      logError('Gagal melakukan soft delete pada branch', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id,
        branchName: branch.name
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        'Failed to delete Branch',
        { branchId: id }
      ));
    }
    
    // Dapatkan Branch yang sudah di-soft delete
    const deletedBranch = await branchRepository.getBranchById(id, null, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('Branch berhasil di-soft delete secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      branchName: branch.name
    });
    
    // Sukses, kembalikan status 200 dengan data Branch yang sudah di-soft delete
    res.status(200).json({
      message: 'Branch and all Routers, OLTs, ODCs, ODPs, and ONTs deleted successfully',
      data: deletedBranch
    });
  } catch (error) {
    logError('Error pada deleteBranch', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      branchId: req.params.id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada branch yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreBranch(req, res) {
  try {
    const context = getRequestContext();
    const { id } = req.params;
    
    logDebug('Menerima request restoreBranch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa status branch terlebih dahulu
    logDebug('Memeriksa keberadaan branch yang sudah dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id
    });
    
    const branch = await branchRepository.getBranchById(id, null, branchRepository.DeletedFilterTypes.ONLY);
    
    logDebug('Status pencarian branch yang dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      ditemukan: branch ? true : false
    });
    
    if (!branch) {
      logWarn('Branch tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Branch not found or already restored'
      ));
    }
    
    // Coba restore branch
    logDebug('Mencoba melakukan restore branch secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      branchName: branch.name
    });
    
    const result = await branchRepository.restore(id);
    
    logDebug('Hasil restore branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      berhasil: result ? true : false
    });
    
    if (!result) {
      logError('Gagal melakukan restore branch', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id,
        branchName: branch.name
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Failed to restore branch'
      ));
    }
    
    // Dapatkan data branch yang sudah di-restore
    logDebug('Mengambil data branch yang sudah di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id
    });
    
    const restoredBranch = await branchRepository.getBranchById(id, null, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('Branch berhasil di-restore secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      branchName: restoredBranch.name
    });
    
    res.status(200).json({
      message: 'Branch restored successfully',
      data: restoredBranch
    });
  } catch (error) {
    logError('Error pada restoreBranch', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      branchId: req.params.id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getAllBranches,
  getBranchById,
  createBranch,
  updateBranch,
  deleteBranch,
  restoreBranch
};
###
cat src/controllers/netDevice.controller.js
###
cat src/controllers/netDeviceOdc.controller.js
/**
 * Controller untuk endpoint net device ODC
 */

const oltRepository = require('../repositories/netDeviceOlt.repository');
const odcRepository = require('../repositories/netDeviceOdc.repository');
const branchRepository = require('../repositories/branch.repository'); // Untuk DeletedFilterTypes
const { softDeleteOdc } = require('../utils/recursiveSoftDelete.util');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan ODC berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getOdcById(req, res) {
  try {
    const context = getRequestContext();
    const { odc_id } = req.params;
    
    logDebug('Menerima request getOdcById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Ambil parameter dari query
    const { deleted } = req.query;
    
    // Tentukan filter deleted (defaultnya WITHOUT)
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }
    
    logDebug('Mengambil data ODC by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      filters: {
        deleted: deletedFilter
      }
    });
    
    const odc = await odcRepository.getOdcById(odc_id, deletedFilter);
    
    if (!odc) {
      logWarn('ODC tidak ditemukan', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        filters: {
          deleted: deletedFilter
        }
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODC not found'
      ));
    }
    
    logInfo('Berhasil mengambil data ODC by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      deleted: deletedFilter
    });
    
    res.status(200).json({
      data: odc
    });
  } catch (error) {
    logError('Error pada getOdcById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odcId: req.params.odc_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menambahkan ODC ke OLT pada port tertentu
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function addOdcToOlt(req, res) {
  try {
    const context = getRequestContext();
    const { olt_id } = req.params;
    
    logDebug('Menerima request addOdcToOlt', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Periksa apakah OLT ada
    logDebug('Memeriksa keberadaan OLT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id
    });
    
    const oltInfo = await oltRepository.getOltById(olt_id);
    
    if (!oltInfo || !oltInfo.olt) {
      logWarn('OLT tidak ditemukan untuk penambahan ODC', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'OLT not found'
      ));
    }
    
    // Periksa apakah port yang dimaksud ada di OLT
    logDebug('Memeriksa keberadaan port pada OLT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      requestedPort: req.body.pon_port
    });
    
    const ponPort = oltInfo.olt.pon_port.find(port => port.port === req.body.pon_port);
    
    if (!ponPort) {
      logWarn('Port tidak ditemukan pada OLT', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        requestedPort: req.body.pon_port
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        `Port ${req.body.pon_port} not found on OLT`
      ));
    }
    
    // Tambahkan ODC ke OLT pada port tertentu
    logDebug('Menambahkan ODC ke OLT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      ponPort: req.body.pon_port,
      odcLabel: req.body.label,
      availableTray: req.body.available_tray || 0,
      coresPerTray: req.body.cores_per_tray || 0
    });
    
    const updatedOltInfo = await oltRepository.addOdcToOlt(olt_id, req.body);
    
    logInfo('ODC berhasil ditambahkan ke OLT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      oltLabel: oltInfo.olt.label || 'unknown',
      ponPort: req.body.pon_port,
      odcLabel: req.body.label
    });
    
    res.status(200).json({
      message: 'ODC added to OLT successfully',
      data: updatedOltInfo.olt
    });
  } catch (error) {
    logError('Error pada addOdcToOlt', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      oltId: req.params.olt_id,
      requestBody: req.body
    });
    
    // Handling specific errors
    if (error.message && error.message.includes('not found')) {
      return res.status(404).json(createErrorResponse(
        404,
        error.message
      ));
    }
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan soft delete pada ODC dan semua ODP serta ONT di dalamnya
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteOdc(req, res) {
  try {
    const context = getRequestContext();
    const { odc_id } = req.params;
    
    logDebug('Menerima request deleteOdc', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah ODC ada
    logDebug('Memeriksa keberadaan ODC sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id
    });
    
    const odcInfo = await odcRepository.getOdcById(odc_id, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!odcInfo || !odcInfo.odc) {
      logWarn('ODC tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODC not found or already deleted'
      ));
    }
    
    // Lakukan soft delete rekursif pada ODC dan semua ODP serta ONT di dalamnya
    try {
      logDebug('Memulai proses soft delete ODC secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        odcLabel: odcInfo.odc.label,
        branchId: odcInfo.branchId,
        routerIndex: odcInfo.routerIndex,
        oltIndex: odcInfo.oltIndex,
        ponPortIndex: odcInfo.ponPortIndex
      });
      
      const result = await softDeleteOdc({
        branchId: odcInfo.branchId,
        routerIndex: odcInfo.routerIndex,
        oltIndex: odcInfo.oltIndex,
        ponPortIndex: odcInfo.ponPortIndex,
        odcIndex: odcInfo.odcIndex
      });
      
      if (!result) {
        logError('Soft delete ODC gagal', {
          requestId: context.getRequestId(),
          userId: context.getUserId(),
          odcId: odc_id,
          odcLabel: odcInfo.odc.label,
          branchId: odcInfo.branchId
        });
        
        return res.status(500).json(createErrorResponse(
          500,
          'Failed to delete ODC',
          { odcId: odc_id }
        ));
      }
      
      logDebug('Soft delete berhasil, mengambil data ODC yang sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id
      });
      
      // Dapatkan ODC yang sudah di-soft delete
      const deletedOdc = await odcRepository.getOdcById(odc_id, branchRepository.DeletedFilterTypes.WITH);
      
      logInfo('ODC berhasil di-soft delete secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        odcLabel: odcInfo.odc.label,
        branchId: odcInfo.branchId
      });
      
      // Sukses, kembalikan status 200 dengan data ODC yang sudah di-soft delete
      res.status(200).json({
        message: 'ODC and all ODPs and ONTs deleted successfully',
        data: deletedOdc?.odc || { _id: odc_id, deleted_at: new Date() }
      });
    } catch (deleteError) {
      logError('Error saat proses delete ODC', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        error: deleteError.message,
        stack: deleteError.stack
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        `Failed to delete ODC: ${deleteError.message || 'Unknown error'}`,
        deleteError
      ));
    }
  } catch (error) {
    logError('Error pada deleteOdc controller', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odcId: req.params.odc_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada ODC yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreOdc(req, res) {
  try {
    const context = getRequestContext();
    const { odc_id } = req.params;
    
    logDebug('Menerima request restoreOdc', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa status ODC terlebih dahulu - gunakan filter ONLY untuk mencari yang sudah dihapus
    logDebug('Memeriksa keberadaan ODC yang sudah dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id
    });
    
    const odcInfo = await odcRepository.getOdcById(odc_id, branchRepository.DeletedFilterTypes.ONLY);
    
    logDebug('Status pencarian ODC yang dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      ditemukan: odcInfo ? true : false
    });
    
    if (!odcInfo || !odcInfo.odc) {
      logWarn('ODC tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODC not found or already restored'
      ));
    }
    
    // Coba restore ODC
    logDebug('Mencoba melakukan restore ODC secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      odcLabel: odcInfo.odc.label,
      branchId: odcInfo.branchId
    });
    
    const result = await odcRepository.restore(odc_id);
    
    logDebug('Hasil restore ODC', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      berhasil: result ? true : false
    });
    
    if (!result) {
      logError('Gagal melakukan restore ODC', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        odcLabel: odcInfo.odc.label
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Failed to restore ODC'
      ));
    }
    
    // Dapatkan data ODC yang sudah di-restore menggunakan filter WITH untuk memastikan kita bisa menemukannya
    logDebug('Mengambil data ODC yang sudah di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id
    });
    
    const restoredOdc = await odcRepository.getOdcById(odc_id, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('ODC berhasil di-restore secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      odcLabel: restoredOdc?.odc?.label || 'unknown',
      branchId: odcInfo.branchId
    });
    
    res.status(200).json({
      message: 'ODC restored successfully',
      data: restoredOdc
    });
  } catch (error) {
    logError('Error pada restoreOdc', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odcId: req.params.odc_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getOdcById,
  addOdcToOlt,
  deleteOdc,
  restoreOdc
}; ###
cat src/controllers/netDeviceOdp.controller.js
/**
 * Controller untuk endpoint net device ODP
 */

const odcRepository = require('../repositories/netDeviceOdc.repository');
const odpRepository = require('../repositories/netDeviceOdp.repository');
const branchRepository = require('../repositories/branch.repository'); // Untuk DeletedFilterTypes
const { softDeleteOdp } = require('../utils/recursiveSoftDelete.util');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan ODP berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getOdpById(req, res) {
  try {
    const context = getRequestContext();
    const { odp_id } = req.params;
    
    logDebug('Menerima request getOdpById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    const { deleted } = req.query;
    
    // Tentukan filter deleted (defaultnya WITHOUT)
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }
    
    logDebug('Mengambil data ODP by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      filters: {
        deleted: deletedFilter
      }
    });
    
    const odp = await odpRepository.getOdpById(odp_id, deletedFilter);
    
    if (!odp) {
      logWarn('ODP tidak ditemukan', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        filters: {
          deleted: deletedFilter
        }
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODP not found'
      ));
    }
    
    logInfo('Berhasil mengambil data ODP by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      deleted: deletedFilter
    });
    
    res.status(200).json({
      data: odp
    });
  } catch (error) {
    logError('Error pada getOdpById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odpId: req.params.odp_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menambahkan ODP ke ODC pada tray tertentu
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function addOdpToOdc(req, res) {
  try {
    const context = getRequestContext();
    const { odc_id } = req.params;
    
    logDebug('Menerima request addOdpToOdc', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Periksa apakah ODC ada
    logDebug('Memeriksa keberadaan ODC', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id
    });
    
    const odcInfo = await odcRepository.getOdcById(odc_id);
    
    if (!odcInfo || !odcInfo.odc) {
      logWarn('ODC tidak ditemukan untuk penambahan ODP', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODC not found'
      ));
    }
    
    // Periksa apakah tray yang dimaksud ada di ODC
    logDebug('Memeriksa keberadaan tray pada ODC', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      requestedTray: req.body.tray
    });
    
    const tray = odcInfo.odc.trays.find(tray => tray.tray === req.body.tray);
    
    if (!tray) {
      logWarn('Tray tidak ditemukan pada ODC', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        requestedTray: req.body.tray
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        `Tray ${req.body.tray} not found on ODC`
      ));
    }
    
    // Validasi core_on_odc_tray
    logDebug('Validasi core_on_odc_tray', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      tray: req.body.tray,
      coreOnOdcTray: req.body.core_on_odc_tray,
      validRange: `${tray.start_core}-${tray.end_core}`
    });
    
    if (req.body.core_on_odc_tray < tray.start_core || req.body.core_on_odc_tray > tray.end_core) {
      logWarn('Nilai core_on_odc_tray tidak valid', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        tray: req.body.tray,
        coreOnOdcTray: req.body.core_on_odc_tray,
        validRange: `${tray.start_core}-${tray.end_core}`
      });
      
      return res.status(400).json(createErrorResponse(
        400,
        `core_on_odc_tray value (${req.body.core_on_odc_tray}) out of range for tray ${req.body.tray}. Valid range: ${tray.start_core}-${tray.end_core}`
      ));
    }
    
    // Tambahkan ODP ke ODC pada tray tertentu
    logDebug('Menambahkan ODP ke ODC', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      tray: req.body.tray,
      odpLabel: req.body.label,
      coreOnOdcTray: req.body.core_on_odc_tray
    });
    
    const updatedOdcInfo = await odcRepository.addOdpToOdc(odc_id, req.body);
    
    logInfo('ODP berhasil ditambahkan ke ODC', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      odcLabel: odcInfo.odc.label || 'unknown',
      tray: req.body.tray,
      odpLabel: req.body.label
    });
    
    res.status(200).json({
      message: 'ODP added to ODC successfully',
      data: updatedOdcInfo.odc
    });
  } catch (error) {
    logError('Error pada addOdpToOdc', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odcId: req.params.odc_id,
      requestBody: req.body
    });
    
    // Handling specific errors
    if (error.message && (error.message.includes('not found') || error.message.includes('out of range'))) {
      return res.status(400).json(createErrorResponse(
        400,
        error.message,
        error
      ));
    }
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan soft delete pada ODP dan semua ONT di dalamnya
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteOdp(req, res) {
  try {
    const context = getRequestContext();
    const { odp_id } = req.params;
    
    logDebug('Menerima request deleteOdp', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah ODP ada
    logDebug('Memeriksa keberadaan ODP sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id
    });
    
    const odpInfo = await odpRepository.getOdpById(odp_id, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!odpInfo || !odpInfo.odp) {
      logWarn('ODP tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODP not found or already deleted'
      ));
    }
    
    // Lakukan soft delete rekursif pada ODP dan semua ONT di dalamnya
    try {
      logDebug('Memulai proses soft delete ODP secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        odpLabel: odpInfo.odp.label,
        branchId: odpInfo.branchId,
        routerIndex: odpInfo.routerIndex,
        oltIndex: odpInfo.oltIndex,
        ponPortIndex: odpInfo.ponPortIndex,
        odcIndex: odpInfo.odcIndex,
        trayIndex: odpInfo.trayIndex
      });
      
      const result = await softDeleteOdp({
        branchId: odpInfo.branchId,
        routerIndex: odpInfo.routerIndex,
        oltIndex: odpInfo.oltIndex,
        ponPortIndex: odpInfo.ponPortIndex,
        odcIndex: odpInfo.odcIndex,
        trayIndex: odpInfo.trayIndex,
        odpIndex: odpInfo.odpIndex
      });
      
      if (!result) {
        logError('Soft delete ODP gagal', {
          requestId: context.getRequestId(),
          userId: context.getUserId(),
          odpId: odp_id,
          odpLabel: odpInfo.odp.label,
          branchId: odpInfo.branchId
        });
        
        return res.status(500).json(createErrorResponse(
          500,
          'Failed to delete ODP',
          { odpId: odp_id }
        ));
      }
      
      logDebug('Soft delete berhasil, mengambil data ODP yang sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id
      });
      
      // Dapatkan ODP yang sudah di-soft delete
      const deletedOdp = await odpRepository.getOdpById(odp_id, branchRepository.DeletedFilterTypes.WITH);
      
      logInfo('ODP berhasil di-soft delete secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        odpLabel: odpInfo.odp.label,
        branchId: odpInfo.branchId
      });
      
      // Sukses, kembalikan status 200 dengan data ODP yang sudah di-soft delete
      res.status(200).json({
        message: 'ODP and all ONTs deleted successfully',
        data: deletedOdp?.odp || { _id: odp_id, deleted_at: new Date() }
      });
    } catch (deleteError) {
      logError('Error saat proses delete ODP', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        error: deleteError.message,
        stack: deleteError.stack
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        `Failed to delete ODP: ${deleteError.message || 'Unknown error'}`,
        deleteError
      ));
    }
  } catch (error) {
    logError('Error pada deleteOdp controller', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odpId: req.params.odp_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada ODP yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreOdp(req, res) {
  try {
    const context = getRequestContext();
    const { odp_id } = req.params;
    
    logDebug('Menerima request restoreOdp', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa status ODP terlebih dahulu
    logDebug('Memeriksa keberadaan ODP yang sudah dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id
    });
    
    const odpInfo = await odpRepository.getOdpById(odp_id, branchRepository.DeletedFilterTypes.ONLY);
    
    logDebug('Status pencarian ODP yang dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      ditemukan: odpInfo ? true : false
    });
    
    if (!odpInfo || !odpInfo.odp) {
      logWarn('ODP tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODP not found or already restored'
      ));
    }
    
    // Coba restore ODP
    logDebug('Mencoba melakukan restore ODP secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      odpLabel: odpInfo.odp.label,
      branchId: odpInfo.branchId
    });
    
    const result = await odpRepository.restore(odp_id);
    
    logDebug('Hasil restore ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      berhasil: result ? true : false
    });
    
    if (!result) {
      logError('Gagal melakukan restore ODP', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        odpLabel: odpInfo.odp.label
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Failed to restore ODP'
      ));
    }
    
    // Dapatkan data ODP yang sudah di-restore
    logDebug('Mengambil data ODP yang sudah di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id
    });
    
    const restoredOdp = await odpRepository.getOdpById(odp_id, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('ODP berhasil di-restore secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      odpLabel: restoredOdp?.odp?.label || 'unknown',
      branchId: odpInfo.branchId
    });
    
    res.status(200).json({
      message: 'ODP restored successfully',
      data: restoredOdp
    });
  } catch (error) {
    logError('Error pada restoreOdp', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odpId: req.params.odp_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getOdpById,
  addOdpToOdc,
  deleteOdp,
  restoreOdp
}; ###
cat src/controllers/netDeviceOlt.controller.js
/**
 * Controller untuk endpoint net device OLT
 */

const routerRepository = require('../repositories/netDeviceRouter.repository');
const oltRepository = require('../repositories/netDeviceOlt.repository');
const branchRepository = require('../repositories/branch.repository'); // Untuk DeletedFilterTypes
const { softDeleteOlt } = require('../utils/recursiveSoftDelete.util');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan OLT berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getOltById(req, res) {
  try {
    const context = getRequestContext();
    const { olt_id } = req.params;
    
    logDebug('Menerima request getOltById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Ambil parameter dari query
    const { deleted } = req.query;
    
    // Tentukan filter deleted (defaultnya WITHOUT)
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }
    
    logDebug('Mengambil data OLT by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      filters: {
        deleted: deletedFilter
      }
    });
    
    const olt = await oltRepository.getOltById(olt_id, deletedFilter);
    
    if (!olt) {
      logWarn('OLT tidak ditemukan', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        filters: {
          deleted: deletedFilter
        }
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'OLT not found'
      ));
    }
    
    logInfo('Berhasil mengambil data OLT by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      deleted: deletedFilter
    });
    
    res.status(200).json({
      data: olt
    });
  } catch (error) {
    logError('Error pada getOltById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      oltId: req.params.olt_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menambahkan OLT ke router
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function addOltToRouter(req, res) {
  try {
    const context = getRequestContext();
    const { router_id } = req.params;
    
    logDebug('Menerima request addOltToRouter', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Periksa apakah router ada
    logDebug('Memeriksa keberadaan router', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id
    });
    
    const router = await routerRepository.getRouterById(router_id);
    
    if (!router) {
      logWarn('Router tidak ditemukan untuk penambahan OLT', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Router not found'
      ));
    }
    
    // Tambahkan OLT ke router
    logDebug('Menambahkan OLT ke router', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      oltLabel: req.body.label,
      availablePorts: req.body.available_pon || 0
    });
    
    const updatedRouter = await routerRepository.addOltToRouter(router_id, req.body);
    
    logInfo('OLT berhasil ditambahkan ke router', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      routerLabel: router.router?.label || 'unknown',
      oltLabel: req.body.label
    });
    
    res.status(200).json({
      message: 'OLT added to router successfully',
      data: updatedRouter
    });
  } catch (error) {
    logError('Error pada addOltToRouter', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      routerId: req.params.router_id,
      requestBody: req.body
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan soft delete pada OLT dan semua ODC, ODP, serta ONT di dalamnya
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteOlt(req, res) {
  try {
    const context = getRequestContext();
    const { olt_id } = req.params;
    
    logDebug('Menerima request deleteOlt', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah OLT ada
    logDebug('Memeriksa keberadaan OLT sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id
    });
    
    const oltInfo = await oltRepository.getOltById(olt_id, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!oltInfo || !oltInfo.olt) {
      logWarn('OLT tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'OLT not found or already deleted'
      ));
    }
    
    // Lakukan soft delete rekursif pada OLT dan semua ODC, ODP, serta ONT di dalamnya
    try {
      logDebug('Memulai proses soft delete OLT secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        oltLabel: oltInfo.olt.label,
        branchId: oltInfo.branchId,
        routerIndex: oltInfo.routerIndex
      });
      
      const result = await softDeleteOlt({
        branchId: oltInfo.branchId,
        routerIndex: oltInfo.routerIndex,
        oltIndex: oltInfo.oltIndex
      });
      
      // Periksa hasil soft delete (result adalah boolean)
      if (!result) {
        logError('Soft delete OLT gagal', {
          requestId: context.getRequestId(),
          userId: context.getUserId(),
          oltId: olt_id,
          oltLabel: oltInfo.olt.label,
          branchId: oltInfo.branchId
        });
        
        return res.status(500).json(createErrorResponse(
          500,
          'Failed to delete OLT',
          { oltId: olt_id }
        ));
      }
      
      logDebug('Soft delete berhasil, mengambil data OLT yang sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id
      });
      
      // Dapatkan OLT yang sudah di-soft delete
      const deletedOlt = await oltRepository.getOltById(olt_id, branchRepository.DeletedFilterTypes.WITH);
      
      logInfo('OLT berhasil di-soft delete secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        oltLabel: oltInfo.olt.label,
        branchId: oltInfo.branchId
      });
      
      // Sukses, kembalikan status 200 dengan data OLT yang sudah di-soft delete
      res.status(200).json({
        message: 'OLT and all ODCs, ODPs, and ONTs deleted successfully',
        data: deletedOlt?.olt || { _id: olt_id, deleted_at: new Date() }
      });
    } catch (deleteError) {
      logError('Error saat proses delete OLT', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        error: deleteError.message,
        stack: deleteError.stack
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        `Failed to delete OLT: ${deleteError.message || 'Unknown error'}`,
        deleteError
      ));
    }
  } catch (error) {
    logError('Error pada deleteOlt controller', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      oltId: req.params.olt_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada OLT yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreOlt(req, res) {
  try {
    const context = getRequestContext();
    const { olt_id } = req.params;
    
    logDebug('Menerima request restoreOlt', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa status OLT terlebih dahulu - gunakan filter ONLY untuk mencari yang sudah dihapus
    logDebug('Memeriksa keberadaan OLT yang sudah dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id
    });
    
    const oltInfo = await oltRepository.getOltById(olt_id, branchRepository.DeletedFilterTypes.ONLY);
    
    logDebug('Status pencarian OLT yang dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      ditemukan: oltInfo ? true : false
    });
    
    if (!oltInfo || !oltInfo.olt) {
      logWarn('OLT tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'OLT not found or already restored'
      ));
    }
    
    // Coba restore OLT
    logDebug('Mencoba melakukan restore OLT secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      oltLabel: oltInfo.olt.label,
      branchId: oltInfo.branchId
    });
    
    const result = await oltRepository.restore(olt_id);
    
    logDebug('Hasil restore OLT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      berhasil: result ? true : false
    });
    
    if (!result) {
      logError('Gagal melakukan restore OLT', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        oltLabel: oltInfo.olt.label
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Failed to restore OLT'
      ));
    }
    
    // Dapatkan data OLT yang sudah di-restore menggunakan filter WITH untuk memastikan kita bisa menemukannya
    logDebug('Mengambil data OLT yang sudah di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id
    });
    
    const restoredOlt = await oltRepository.getOltById(olt_id, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('OLT berhasil di-restore secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      oltLabel: restoredOlt?.olt?.label || 'unknown',
      branchId: oltInfo.branchId
    });
    
    res.status(200).json({
      message: 'OLT restored successfully',
      data: restoredOlt
    });
  } catch (error) {
    logError('Error pada restoreOlt', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      oltId: req.params.olt_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getOltById,
  addOltToRouter,
  deleteOlt,
  restoreOlt
}; ###
cat src/controllers/netDeviceOnt.controller.js
/**
 * Controller untuk endpoint net device ONT
 */

const odpRepository = require('../repositories/netDeviceOdp.repository');
const ontRepository = require('../repositories/netDeviceOnt.repository');
const branchRepository = require('../repositories/branch.repository'); // Untuk DeletedFilterTypes
const netDeviceOntService = require('../services/netDeviceOnt.service');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan ONT berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getOntById(req, res) {
  try {
    const context = getRequestContext();
    const { ont_id } = req.params;
    
    logDebug('Menerima request getOntById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    const { deleted } = req.query;
    
    logDebug('Mengambil data ONT by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      filters: {
        deleted: deleted || 'WITHOUT'
      }
    });
    
    const ont = await netDeviceOntService.getOntById(ont_id, deleted);
    
    logInfo('Berhasil mengambil data ONT by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      deleted: deleted || 'WITHOUT'
    });
    
    res.status(200).json({
      data: ont
    });
  } catch (error) {
    logError('Error pada getOntById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      ontId: req.params.ont_id
    });
    
    if (error.message === 'ONT not found') {
      return res.status(404).json(createErrorResponse(
        404,
        error.message
      ));
    }
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan soft delete pada ONT berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteOnt(req, res) {
  try {
    const context = getRequestContext();
    const { ont_id } = req.params;
    
    logDebug('Menerima request deleteOnt', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah ONT ada
    logDebug('Memeriksa keberadaan ONT sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id
    });
    
    const ont = await ontRepository.getOntById(ont_id, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!ont) {
      logWarn('ONT tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        ontId: ont_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ONT not found or already deleted'
      ));
    }
    
    // Lakukan soft delete
    logDebug('Memulai proses soft delete ONT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      ontLabel: ont.label || 'unknown'
    });
    
    const deletedOnt = await ontRepository.softDeleteOnt(ont_id);
    
    if (!deletedOnt) {
      logError('Soft delete ONT gagal', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        ontId: ont_id,
        ontLabel: ont.label || 'unknown'
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        'Failed to delete ONT',
        { ontId: ont_id }
      ));
    }
    
    logInfo('ONT berhasil di-soft delete', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      ontLabel: ont.label || 'unknown'
    });
    
    // Sukses, kembalikan status 200 dengan data ONT yang sudah di-soft delete
    res.status(200).json({
      message: 'ONT deleted successfully',
      data: deletedOnt
    });
  } catch (error) {
    logError('Error pada deleteOnt controller', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      ontId: req.params.ont_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menambahkan ONT ke ODP
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function addOntToOdp(req, res) {
  try {
    const context = getRequestContext();
    const { odp_id } = req.params;
    
    logDebug('Menerima request addOntToOdp', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Periksa apakah ODP ada
    logDebug('Memeriksa keberadaan ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id
    });
    
    const odpInfo = await odpRepository.getOdpById(odp_id);
    
    if (!odpInfo || !odpInfo.odp) {
      logWarn('ODP tidak ditemukan untuk penambahan ONT', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODP not found'
      ));
    }
    
    // Periksa kapasitas port ODP
    const maxAvailablePort = odpInfo.odp.available_port || 0;
    const currentOntCount = odpInfo.odp.children ? odpInfo.odp.children.length : 0;
    
    logDebug('Memeriksa kapasitas port ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      odpLabel: odpInfo.odp.label || 'unknown',
      maxAvailablePort: maxAvailablePort,
      currentOntCount: currentOntCount
    });
    
    if (currentOntCount >= maxAvailablePort) {
      logWarn('Kapasitas port ODP terlampaui', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        odpLabel: odpInfo.odp.label || 'unknown',
        maxAvailablePort: maxAvailablePort,
        currentOntCount: currentOntCount
      });
      
      return res.status(400).json(createErrorResponse(
        400,
        `ODP port capacity exceeded. Maximum port: ${maxAvailablePort}, current ONT count: ${currentOntCount}`
      ));
    }
    
    // Tambahkan ONT ke ODP
    logDebug('Menambahkan ONT ke ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      odpLabel: odpInfo.odp.label || 'unknown',
      ontLabel: req.body.label
    });
    
    const updatedOdpInfo = await odpRepository.addOntToOdp(odp_id, req.body);
    
    logInfo('ONT berhasil ditambahkan ke ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      odpLabel: odpInfo.odp.label || 'unknown',
      ontLabel: req.body.label
    });
    
    res.status(200).json({
      message: 'ONT added to ODP successfully',
      data: updatedOdpInfo.odp
    });
  } catch (error) {
    logError('Error pada addOntToOdp', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odpId: req.params.odp_id,
      requestBody: req.body
    });
    
    // Handling specific errors
    if (error.message && (error.message.includes('not found') || error.message.includes('exceeded'))) {
      return res.status(400).json(createErrorResponse(
        400,
        error.message,
        error
      ));
    }
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada ONT yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreOnt(req, res) {
  try {
    const context = getRequestContext();
    const { ont_id } = req.params;
    
    logDebug('Menerima request restoreOnt', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    logDebug('Mencoba melakukan restore ONT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id
    });
    
    const ont = await netDeviceOntService.restoreOnt(ont_id);
    
    logInfo('ONT berhasil di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      ontLabel: ont.label || 'unknown'
    });
    
    res.status(200).json({
      message: 'ONT restored successfully',
      data: ont
    });
  } catch (error) {
    logError('Error pada restoreOnt', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      ontId: req.params.ont_id
    });
    
    if (error.message === 'ONT not found or already restored') {
      return res.status(404).json(createErrorResponse(
        404,
        error.message
      ));
    }
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getOntById,
  addOntToOdp,
  deleteOnt,
  restoreOnt
}; ###
cat src/controllers/netDeviceRouter.controller.js
/**
 * Controller untuk endpoint net device router
 */

const branchRepository = require('../repositories/branch.repository');
const routerRepository = require('../repositories/netDeviceRouter.repository');
const { softDeleteRouter } = require('../utils/recursiveSoftDelete.util');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan router berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getRouterById(req, res) {
  try {
    const context = getRequestContext();
    const { router_id } = req.params;
    
    logDebug('Menerima request getRouterById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    const { deleted } = req.query;
    
    // Tentukan filter deleted (defaultnya WITHOUT)
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }
    
    logDebug('Mengambil data router by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      filters: {
        deleted: deletedFilter
      }
    });
    
    const router = await routerRepository.getRouterById(router_id, deletedFilter);
    
    if (!router) {
      logWarn('Router tidak ditemukan', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id,
        filters: {
          deleted: deletedFilter
        }
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Router not found'
      ));
    }
    
    logInfo('Berhasil mengambil data router by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      deleted: deletedFilter
    });
    
    res.status(200).json({
      data: router
    });
  } catch (error) {
    logError('Error pada getRouterById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      routerId: req.params.router_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menambahkan router ke branch
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function addRouterToBranch(req, res) {
  try {
    const context = getRequestContext();
    const { branch_id } = req.params;
    
    logDebug('Menerima request addRouterToBranch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: branch_id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Periksa apakah branch ada
    logDebug('Memeriksa keberadaan branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: branch_id
    });
    
    const branch = await branchRepository.getBranchById(branch_id);
    
    if (!branch) {
      logWarn('Branch tidak ditemukan untuk penambahan router', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: branch_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Branch not found'
      ));
    }
    
    // Tambahkan router ke branch
    logDebug('Menambahkan router ke branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: branch_id,
      routerLabel: req.body.label
    });
    
    const updatedBranch = await branchRepository.addRouterToBranch(branch_id, req.body);
    
    logInfo('Router berhasil ditambahkan ke branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: branch_id,
      branchName: branch.name,
      routerLabel: req.body.label
    });
    
    res.status(200).json({
      message: 'Router added to branch successfully',
      data: updatedBranch
    });
  } catch (error) {
    logError('Error pada addRouterToBranch', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      branchId: req.params.branch_id,
      requestBody: req.body
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan soft delete pada Router dan semua OLT, ODC, ODP, serta ONT di dalamnya
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteRouter(req, res) {
  try {
    const context = getRequestContext();
    const { router_id } = req.params;
    
    logDebug('Menerima request deleteRouter', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah Router ada
    logDebug('Memeriksa keberadaan router sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id
    });
    
    const routerInfo = await routerRepository.getRouterById(router_id, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!routerInfo || !routerInfo.router) {
      logWarn('Router tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Router not found or already deleted'
      ));
    }
    
    // Lakukan soft delete rekursif pada Router dan semua device di dalamnya
    try {
      logDebug('Memulai proses soft delete router secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id,
        routerLabel: routerInfo.router.label,
        branchId: routerInfo.branchId
      });
      
      const result = await softDeleteRouter({
        branchId: routerInfo.branchId,
        routerIndex: routerInfo.routerIndex
      });
      
      if (!result) {
        logError('Soft delete router gagal', {
          requestId: context.getRequestId(),
          userId: context.getUserId(),
          routerId: router_id,
          routerLabel: routerInfo.router.label,
          branchId: routerInfo.branchId
        });
        
        return res.status(500).json(createErrorResponse(
          500,
          'Failed to delete Router',
          { routerId: router_id }
        ));
      }
      
      logDebug('Soft delete berhasil, mengambil data Router yang sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id
      });
      
      // Dapatkan Router yang sudah di-soft delete
      const deletedRouter = await routerRepository.getRouterById(router_id, branchRepository.DeletedFilterTypes.WITH);
      
      logInfo('Router berhasil di-soft delete secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id,
        routerLabel: routerInfo.router.label,
        branchId: routerInfo.branchId
      });
      
      // Sukses, kembalikan status 200 dengan data Router yang sudah di-soft delete
      res.status(200).json({
        message: 'Router and all OLTs, ODCs, ODPs, and ONTs deleted successfully',
        data: deletedRouter?.router || { _id: router_id, deleted_at: new Date() }
      });
    } catch (deleteError) {
      logError('Error saat proses delete router', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id,
        error: deleteError.message,
        stack: deleteError.stack
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        `Failed to delete Router: ${deleteError.message || 'Unknown error'}`,
        deleteError
      ));
    }
  } catch (error) {
    logError('Error pada deleteRouter controller', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      routerId: req.params.router_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada Router yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreRouter(req, res) {
  try {
    const context = getRequestContext();
    const { router_id } = req.params;
    
    logDebug('Menerima request restoreRouter', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa status Router terlebih dahulu
    logDebug('Memeriksa keberadaan router yang sudah dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id
    });
    
    const routerInfo = await routerRepository.getRouterById(router_id, branchRepository.DeletedFilterTypes.ONLY);
    
    logDebug('Status pencarian router yang dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      ditemukan: routerInfo ? true : false
    });
    
    if (!routerInfo || !routerInfo.router) {
      logWarn('Router tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Router not found or already restored'
      ));
    }
    
    // Coba restore Router
    logDebug('Mencoba melakukan restore router secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      routerLabel: routerInfo.router.label,
      branchId: routerInfo.branchId
    });
    
    const result = await routerRepository.restore(router_id);
    
    logDebug('Hasil restore router', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      berhasil: result ? true : false
    });
    
    if (!result) {
      logError('Gagal melakukan restore router', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id,
        routerLabel: routerInfo.router.label
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Failed to restore Router'
      ));
    }
    
    // Dapatkan data Router yang sudah di-restore
    logDebug('Mengambil data router yang sudah di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id
    });
    
    const restoredRouter = await routerRepository.getRouterById(router_id, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('Router berhasil di-restore secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      routerLabel: restoredRouter?.router?.label || 'unknown',
      branchId: routerInfo.branchId
    });
    
    res.status(200).json({
      message: 'Router restored successfully',
      data: restoredRouter
    });
  } catch (error) {
    logError('Error pada restoreRouter', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      routerId: req.params.router_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getRouterById,
  addRouterToBranch,
  deleteRouter,
  restoreRouter
}; ###
cat src/repositories/branch.repository.js
/**
 * Repository untuk operasi CRUD pada collection branches
 */

const { getCollection } = require('./database.connector');
const { createBranchEntity } = require('../entities/branch.entity');
const { createNetDeviceRouterEntity } = require('../entities/netDeviceRouter.entity');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { recursiveDeletedCheck, DeletedFilterTypes } = require('../utils/recursiveDeletedCheck.util');
const { logDebug, logError, logTrace } = require('../services/logger.service');

// Nama collection
const COLLECTION = 'branches';

// Enum untuk tipe scope level
const ResultTypes = {
  BRANCHES: 'BRANCHES',
  ROUTERS: 'ROUTERS',
  OLTS: 'OLTS',
  ODCS: 'ODCS',
  ODPS: 'ODPS',
  ONTS: 'ONTS'
};

/**
 * Mendapatkan semua branches dengan level detail tertentu dan filter akses
 * @param {string} scopeLevel - Level scope data (BRANCHES, ROUTERS, OLTS, ODCS, ODPS, ONTS)
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @param {Array<ObjectId>} [accessibleBranchIds] - Array of branch IDs yang bisa diakses
 * @returns {Promise<Array>} - Array berisi data branches sesuai level detail dan filter
 */
async function getAllBranches(scopeLevel = null, deletedFilter = DeletedFilterTypes.WITHOUT, accessibleBranchIds = null) {
  try {
    logDebug('Memulai query getAllBranches', {
      scopeLevel,
      deletedFilter,
      hasAccessFilter: !!accessibleBranchIds
    });

    const collection = getCollection(COLLECTION);
    const startTime = Date.now();

    // Buat query berdasarkan akses
    const query = accessibleBranchIds ? { _id: { $in: accessibleBranchIds } } : {};
    const branches = await collection.find(query).toArray();
    
    logTrace('Query database selesai', {
      executionTime: Date.now() - startTime,
      resultCount: branches.length,
      accessFilterApplied: !!accessibleBranchIds
    });
    
    const filteredBranches = branches
      .map(branch => recursiveDeletedCheck(branch, deletedFilter, scopeLevel))
      .filter(branch => branch !== null);
    
    logDebug('Filtering branches selesai', {
      originalCount: branches.length,
      filteredCount: filteredBranches.length,
      filters: {
        scopeLevel,
        deletedFilter,
        accessFiltered: !!accessibleBranchIds
      }
    });

    return filteredBranches;
  } catch (error) {
    logError('Error pada getAllBranches repository', {
      error: error.message,
      stack: error.stack,
      collection: COLLECTION
    });
    throw error;
  }
}

/**
 * Mendapatkan branch berdasarkan ID dengan level detail tertentu
 * @param {string} id - ID branch
 * @param {string} scopeLevel - Level scope data (BRANCHES, ROUTERS, OLTS, ODCS, ODPS, ONTS)
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object>} - Data branch sesuai level detail dan filter
 */
async function getBranchById(id, scopeLevel = null, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    const collection = getCollection(COLLECTION);
    const branch = await collection.findOne({ _id: new ObjectId(id) });
    
    if (!branch) {
      return null;
    }
    
    // Terapkan recursive deleted check
    return recursiveDeletedCheck(branch, deletedFilter, scopeLevel);
  } catch (error) {
    console.error('Error getting branch by ID:', error);
    throw error;
  }
}

/**
 * Membuat branch baru
 * @param {Object} branchData - Data branch yang akan dibuat
 * @returns {Promise<Object>} - Data branch yang sudah dibuat
 */
async function createBranch(branchData) {
  try {
    const collection = getCollection(COLLECTION);
    const branch = createBranchEntity(branchData);
    const result = await collection.insertOne(branch);
    return { ...branch, _id: result.insertedId };
  } catch (error) {
    console.error('Error creating branch:', error);
    throw error;
  }
}

/**
 * Mengupdate branch berdasarkan ID
 * @param {string} id - ID branch
 * @param {Object} branchData - Data branch yang akan diupdate
 * @returns {Promise<Object>} - Data branch yang sudah diupdate
 */
async function updateBranch(id, branchData) {
  try {
    const collection = getCollection(COLLECTION);
    const branch = createBranchEntity(branchData);
    delete branch._id; // Hapus _id agar tidak diupdate
    
    await collection.updateOne(
      { _id: new ObjectId(id) },
      { $set: branch }
    );
    
    // Panggil getBranchById tanpa parameter result untuk mendapatkan data lengkap
    return getBranchById(id, null);
  } catch (error) {
    console.error(`Error updating branch with ID ${id}:`, error);
    throw error;
  }
}

/**
 * Menghapus branch berdasarkan ID
 * @param {string} id - ID branch
 * @returns {Promise<boolean>} - True jika berhasil dihapus
 */
async function deleteBranch(id) {
  try {
    const collection = getCollection(COLLECTION);
    const result = await collection.deleteOne({ _id: new ObjectId(id) });
    return result.deletedCount > 0;
  } catch (error) {
    console.error(`Error deleting branch with ID ${id}:`, error);
    throw error;
  }
}

/**
 * Menambahkan router ke branch berdasarkan ID branch
 * @param {string} id - ID branch
 * @param {Object} routerData - Data router yang akan ditambahkan
 * @returns {Promise<Object>} - Data branch yang sudah diupdate dengan router baru
 */
async function addRouterToBranch(id, routerData) {
  try {
    const collection = getCollection(COLLECTION);
    
    // Buat entity router dengan ObjectId baru
    const routerId = new ObjectId();
    const router = createNetDeviceRouterEntity({
      ...routerData,
      _id: routerId
    });
    
    // Update branch, tambahkan router ke children
    const result = await collection.updateOne(
      { _id: new ObjectId(id) },
      { 
        $push: { children: router },
        $set: { updatedAt: new Date() }
      }
    );
    
    if (result.matchedCount === 0) {
      return null;
    }
    
    // Panggil getBranchById tanpa parameter result untuk mendapatkan data lengkap
    return getBranchById(id, null);
  } catch (error) {
    console.error(`Error adding router to branch with ID ${id}:`, error);
    throw error;
  }
}

/**
 * Melakukan restore pada branch yang telah di-soft delete
 * @param {string} branchId - ID branch yang akan di-restore
 * @returns {Promise<Object|null>} - Hasil restore atau null jika branch tidak ditemukan/tidak bisa di-restore
 */
async function restore(branchId) {
  try {
    console.log(`[restore] Mencoba restore branch dengan ID: ${branchId}`);
    
    // Import fungsi restore
    const { restoreBranch } = require('../utils/recursiveRestore.util');
    
    // Cari branch yang memiliki deleted_at
    const branch = await getBranchById(branchId, null, DeletedFilterTypes.ONLY);
    console.log(`[restore] Status pencarian branch yang dihapus:`, branch ? 'Ditemukan' : 'Tidak ditemukan');
    
    if (!branch) {
      console.log('[restore] Branch tidak ditemukan atau sudah di-restore');
      return null;
    }

    // Simpan timestamp deleted_at untuk digunakan dalam restore
    const deletedAt = branch.deleted_at;
    console.log(`[restore] Branch ditemukan dengan deleted_at: ${deletedAt}`);
    
    // Lakukan restore
    console.log('[restore] Memanggil fungsi restoreBranch');
    const result = await restoreBranch(branchId, deletedAt);
    console.log(`[restore] Hasil restore:`, result ? 'Berhasil' : 'Gagal');
    
    if (!result) {
      console.log('[restore] Gagal melakukan restore branch');
      return null;
    }
    
    // Ambil data branch yang sudah di-restore
    const restoredBranch = await getBranchById(branchId, null, DeletedFilterTypes.WITHOUT);
    console.log('[restore] Berhasil mengambil data branch yang sudah di-restore');
    
    return restoredBranch;
  } catch (error) {
    console.error('[restore] Error saat melakukan restore branch:', error);
    throw error;
  }
}

module.exports = {
  getAllBranches,
  getBranchById,
  createBranch,
  updateBranch,
  deleteBranch,
  addRouterToBranch,
  ResultTypes,
  DeletedFilterTypes,
  restore
};
###
cat src/repositories/branchAccess.repository.js
const { ObjectId } = require('mongodb');
const { getCollection } = require('./database.connector');
const { createBranchAccess, validateBranchAccess } = require('../entities/branchAccess.entity');
const { logDebug, logError } = require('../services/logger.service');

class BranchAccessRepository {
  constructor() {
    this.collectionName = 'branch_access';
  }

  /**
   * Mendapatkan collection
   * @private
   */
  getCollection() {
    return getCollection(this.collectionName);
  }

  /**
   * Memeriksa akses user ke branch tertentu
   * @param {string} userId - UUID dari user
   * @param {string|ObjectId} branchId - ID dari branch
   * @returns {Promise<Object|null>} - Document branch_access jika ditemukan
   */
  async checkAccess(userId, branchId) {
    try {
      const branchObjectId = typeof branchId === 'string' ? new ObjectId(branchId) : branchId;
      
      const access = await this.getCollection().findOne({
        user_id: userId,
        branch_id: branchObjectId
      });

      logDebug('Checked branch access', {
        userId,
        branchId: branchObjectId.toString(),
        hasAccess: !!access,
        permission: access?.permission
      });

      return access;
    } catch (error) {
      logError('Error checking branch access', {
        userId,
        branchId,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Mendapatkan list branch yang dapat diakses oleh user
   * @param {string} userId - UUID dari user
   * @returns {Promise<Array>} - Array dari branch_id yang dapat diakses
   */
  async getAccessibleBranches(userId) {
    try {
      const accessList = await this.getCollection().find({
        user_id: userId
      }).toArray();

      logDebug('Retrieved accessible branches', {
        userId,
        count: accessList.length
      });

      return accessList;
    } catch (error) {
      logError('Error getting accessible branches', {
        userId,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Menambahkan akses branch baru
   * @param {Object} data - Data akses branch
   * @returns {Promise<Object>} - Document yang dibuat
   */
  async addAccess(data) {
    try {
      validateBranchAccess(data);
      const branchAccess = createBranchAccess(data);
      
      await this.getCollection().insertOne(branchAccess);

      logDebug('Added branch access', {
        userId: data.user_id,
        branchId: branchAccess.branch_id.toString(),
        permission: data.permission
      });

      return branchAccess;
    } catch (error) {
      logError('Error adding branch access', {
        data,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Mengupdate permission akses branch
   * @param {string} userId - UUID dari user
   * @param {string|ObjectId} branchId - ID dari branch
   * @param {string} permission - Permission baru (R/RW)
   * @returns {Promise<Object>} - Result dari update
   */
  async updateAccess(userId, branchId, permission) {
    try {
      const branchObjectId = typeof branchId === 'string' ? new ObjectId(branchId) : branchId;
      
      const result = await this.getCollection().updateOne(
        {
          user_id: userId,
          branch_id: branchObjectId
        },
        {
          $set: { permission }
        }
      );

      logDebug('Updated branch access', {
        userId,
        branchId: branchObjectId.toString(),
        permission,
        modified: result.modifiedCount
      });

      return result;
    } catch (error) {
      logError('Error updating branch access', {
        userId,
        branchId,
        permission,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Menghapus akses branch
   * @param {string} userId - UUID dari user
   * @param {string|ObjectId} branchId - ID dari branch
   * @returns {Promise<Object>} - Result dari delete
   */
  async removeAccess(userId, branchId) {
    try {
      const branchObjectId = typeof branchId === 'string' ? new ObjectId(branchId) : branchId;
      
      const result = await this.getCollection().deleteOne({
        user_id: userId,
        branch_id: branchObjectId
      });

      logDebug('Removed branch access', {
        userId,
        branchId: branchObjectId.toString(),
        deleted: result.deletedCount
      });

      return result;
    } catch (error) {
      logError('Error removing branch access', {
        userId,
        branchId,
        error: error.message
      });
      throw error;
    }
  }
}

// Export singleton instance
const branchAccessRepository = new BranchAccessRepository();
module.exports = branchAccessRepository; ###
cat src/repositories/database.connector.js
/**
 * Database connector untuk mengakses connection pool MongoDB
 */

const { getConnection } = require('../../connections/mongodb_conn');
const dbConfig = require('../../config/database.config');

/**
 * Mendapatkan referensi ke database
 * @returns {Object} - Objek database MongoDB
 */
const getDatabase = () => {
  const connection = getConnection();
  if (!connection) {
    throw new Error('Database connection not established');
  }
  return connection.connection.useDb(dbConfig.database);
};

/**
 * Mendapatkan collection tertentu dari database
 * @param {string} collectionName - Nama collection
 * @returns {Object} - Objek collection MongoDB
 */
const getCollection = (collectionName) => {
  const db = getDatabase();
  return db.collection(collectionName);
};

module.exports = {
  getDatabase,
  getCollection
};
###
cat src/repositories/log.repository.js
/**
 * Repository untuk operasi logging ke Elasticsearch
 */

const { Client } = require('@elastic/elasticsearch');
const config = require('../../config/app.config');
const { createLogEntity } = require('../entities/log.entity');

// Inisialisasi Elasticsearch client
const client = new Client({
  node: config.elasticsearch.node,
  auth: {
    username: config.elasticsearch.auth.username,
    password: config.elasticsearch.auth.password
  }
});

/**
 * Menyimpan log ke Elasticsearch
 * @param {Object} logData - Data log yang akan disimpan
 * @returns {Promise<Object>} - Response dari Elasticsearch
 */
async function createLog(logData) {
  try {
    const logEntity = createLogEntity(logData);
    
    const result = await client.index({
      index: config.elasticsearch.index,
      id: logEntity._id,
      document: logEntity
    });

    return result;
  } catch (error) {
    console.error('Error creating log in Elasticsearch:', error);
    throw error;
  }
}

/**
 * Mencari log berdasarkan kriteria
 * @param {Object} criteria - Kriteria pencarian
 * @returns {Promise<Array>} - Array of logs
 */
async function searchLogs(criteria) {
  try {
    const { body } = await client.search({
      index: config.elasticsearch.index,
      body: {
        query: {
          bool: {
            must: Object.entries(criteria).map(([key, value]) => ({
              match: { [key]: value }
            }))
          }
        },
        sort: [{ timestamp: 'desc' }]
      }
    });

    return body.hits.hits.map(hit => hit._source);
  } catch (error) {
    console.error('Error searching logs in Elasticsearch:', error);
    throw error;
  }
}

module.exports = {
  createLog,
  searchLogs
}; ###
cat src/repositories/netDeviceOdc.repository.js
/**
 * Repository untuk operasi pada collection branches terkait net device ODC
 */

const { getCollection } = require('./database.connector');
const { createNetDeviceOdpEntity } = require('../entities/netDeviceOdp.entity');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { DeletedFilterTypes } = require('./branch.repository');
const { restoreOdc } = require('../utils/recursiveRestore.util');

// Nama collection
const COLLECTION = 'branches';

// Enum untuk tipe result
const ResultTypes = {
  ODCS: 'ODCS',
  ODPS: 'ODPS'
};

/**
 * Mendapatkan ODC berdasarkan ID
 * @param {string} odcId - ID ODC
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object>} - Data ODC
 */
async function getOdcById(odcId, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    console.log(`[getOdcById] Mencari ODC dengan ID: ${odcId}, filter: ${deletedFilter}`);
    const collection = getCollection('branches');
    const objectId = new ObjectId(odcId);
    
    // Cari branch yang memiliki ODC dengan ID tertentu
    const branch = await collection.findOne({
      'children.children.pon_port.children._id': objectId
    });
    
    console.log(`[getOdcById] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;
    
    // Variabel untuk menyimpan indeks dan data
    let routerIndex = -1;
    let oltIndex = -1;
    let ponPortIndex = -1;
    let odcIndex = -1;
    let odcData = null;
    
    // Loop melalui branch > router > olt > pon_port > odc
    outerLoop: for (let i = 0; i < branch.children.length; i++) {
      const router = branch.children[i];
      
      if (router.children && Array.isArray(router.children)) {
        for (let j = 0; j < router.children.length; j++) {
          const olt = router.children[j];
          
          if (olt.pon_port && Array.isArray(olt.pon_port)) {
            for (let k = 0; k < olt.pon_port.length; k++) {
              const ponPort = olt.pon_port[k];
              
              if (ponPort.children && Array.isArray(ponPort.children)) {
                for (let l = 0; l < ponPort.children.length; l++) {
                  const odc = ponPort.children[l];
                  
                  if (odc._id.toString() === odcId.toString()) {
                    console.log(`[getOdcById] ODC ditemukan dengan deleted_at: ${odc.deleted_at || 'tidak ada'}`);
                    
                    // Periksa filter
                    if (deletedFilter === DeletedFilterTypes.ONLY && !odc.deleted_at) {
                      console.log('[getOdcById] ODC tidak memiliki deleted_at, tapi filter ONLY');
                      continue;
                    }
                    if (deletedFilter === DeletedFilterTypes.WITHOUT && odc.deleted_at) {
                      console.log('[getOdcById] ODC memiliki deleted_at, tapi filter WITHOUT');
                      continue;
                    }
                    
                    routerIndex = i;
                    oltIndex = j;
                    ponPortIndex = k;
                    odcIndex = l;
                    odcData = odc;
                    break outerLoop;
                  }
                }
              }
            }
          }
        }
      }
    }
    
    // Jika ODC tidak ditemukan atau tidak memenuhi filter
    if (!odcData) {
      console.log('[getOdcById] ODC tidak ditemukan atau tidak memenuhi filter');
      return null;
    }
    
    console.log('[getOdcById] ODC berhasil ditemukan dan memenuhi filter');
    
    // Return objek dengan data ODC dan indeksnya
    return {
      odc: odcData,
      branchId: branch._id,
      routerIndex,
      oltIndex,
      ponPortIndex,
      odcIndex
    };
  } catch (error) {
    console.error('Error getting ODC by ID:', error);
    throw error;
  }
}

/**
 * Mendapatkan detail ODC berdasarkan ID dengan level detail tertentu
 * @param {string} odcId - ID ODC
 * @param {string} resultType - Tipe hasil (ODCS, ODPS)
 * @returns {Promise<Object>} - Data ODC sesuai level detail
 */
async function getOdcDetailById(odcId, resultType = null) {
  try {
    const odcInfo = await getOdcById(odcId);
    
    if (!odcInfo || !odcInfo.odc) {
      return null;
    }
    
    // Ambil data ODC
    const odc = odcInfo.odc;
    
    // Jika resultType tidak dispesifikasikan, kembalikan data lengkap seperti biasa
    if (!resultType || !Object.values(ResultTypes).includes(resultType)) {
      return odcInfo;
    }
    
    // Filter data sesuai resultType
    const odcCopy = { ...odc };
    
    // ODCS: Hapus children dari setiap tray di trays
    if (resultType === ResultTypes.ODCS) {
      if (odcCopy.trays && Array.isArray(odcCopy.trays)) {
        odcCopy.trays = odcCopy.trays.map(tray => {
          const trayCopy = { ...tray };
          delete trayCopy.children;
          return trayCopy;
        });
      }
      return {
        ...odcInfo,
        odc: odcCopy
      };
    }
    
    // ODPS: Hapus children dari setiap ODP
    if (resultType === ResultTypes.ODPS) {
      if (odcCopy.trays && Array.isArray(odcCopy.trays)) {
        odcCopy.trays = odcCopy.trays.map(tray => {
          const trayCopy = { ...tray };
          
          if (trayCopy.children && Array.isArray(trayCopy.children)) {
            trayCopy.children = trayCopy.children.map(odp => {
              const odpCopy = { ...odp };
              delete odpCopy.children;
              return odpCopy;
            });
          }
          
          return trayCopy;
        });
      }
      return {
        ...odcInfo,
        odc: odcCopy
      };
    }
    
    return odcInfo;
  } catch (error) {
    console.error(`Error getting ODC detail with ID ${odcId}:`, error);
    throw error;
  }
}

/**
 * Menambahkan ODP ke ODC pada tray tertentu
 * @param {string} odcId - ID ODC
 * @param {Object} odpData - Data ODP yang akan ditambahkan
 * @returns {Promise<Object>} - Data ODC yang sudah diupdate dengan ODP baru
 */
async function addOdpToOdc(odcId, odpData) {
  try {
    const collection = getCollection(COLLECTION);
    
    // Dapatkan informasi ODC
    const odcInfo = await getOdcById(odcId);
    if (!odcInfo || !odcInfo.odc) {
      return null;
    }
    
    const { odc, branchId, routerIndex, oltIndex, ponPortIndex, odcIndex } = odcInfo;
    
    // Cari tray yang sesuai
    const trayIndex = odc.trays.findIndex(tray => tray.tray === odpData.tray);
    if (trayIndex === -1) {
      throw new Error(`Tray ${odpData.tray} not found on ODC ${odcId}`);
    }
    
    const tray = odc.trays[trayIndex];
    
    // Validasi core_on_odc_tray
    if (odpData.core_on_odc_tray < tray.start_core || odpData.core_on_odc_tray > tray.end_core) {
      throw new Error(`core_on_odc_tray value (${odpData.core_on_odc_tray}) out of range for tray ${odpData.tray}. Valid range: ${tray.start_core}-${tray.end_core}`);
    }
    
    // Simpan nilai tray untuk digunakan di entity, lalu hapus dari data input
    const trayNumber = odpData.tray;
    delete odpData.tray;
    
    // Buat entity ODP dengan ObjectId baru
    const odpId = new ObjectId();
    const odp = createNetDeviceOdpEntity({
      ...odpData,
      _id: odpId
    });
    
    // Path untuk update
    const trayPath = `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children`;
    
    // Update branch, tambahkan ODP ke tray ODC
    const result = await collection.updateOne(
      { _id: branchId },
      { 
        $push: { [trayPath]: odp },
        $set: { updatedAt: new Date() }
      }
    );
    
    if (result.matchedCount === 0) {
      return null;
    }
    
    // Dapatkan ODC yang sudah diupdate
    return getOdcById(odcId);
  } catch (error) {
    console.error(`Error adding ODP to ODC with ID ${odcId}:`, error);
    throw error;
  }
}

/**
 * Melakukan restore pada ODC yang telah di-soft delete
 * @param {string} odcId - ID ODC yang akan di-restore
 * @returns {Promise<Object|null>} - Hasil restore atau null jika ODC tidak ditemukan/tidak bisa di-restore
 */
async function restore(odcId) {
  try {
    const result = await restoreOdc(odcId);
    return result;
  } catch (error) {
    console.error('Error in ODC repository - restore:', error);
    throw error;
  }
}

module.exports = {
  getOdcById,
  getOdcDetailById,
  addOdpToOdc,
  ResultTypes,
  restore
}; ###
cat src/repositories/netDeviceOdp.repository.js
/**
 * Repository untuk operasi pada collection branches terkait net device ODP
 */

const { getCollection } = require('./database.connector');
const { createNetDeviceOntEntity } = require('../entities/netDeviceOnt.entity');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { DeletedFilterTypes } = require('./branch.repository');
const { restoreOdp } = require('../utils/recursiveRestore.util');

// Nama collection
const COLLECTION = 'branches';

// Enum untuk tipe result
const ResultTypes = {
  ODPS: 'ODPS'
};

/**
 * Mendapatkan ODP berdasarkan ID
 * @param {string} odpId - ID ODP
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object>} - Data ODP
 */
async function getOdpById(odpId, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    const { logDebug, logInfo, logWarn, logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    const context = getRequestContext();
    
    logDebug(`Mencari ODP dengan ID: ${odpId}, filter: ${deletedFilter}`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      filter: deletedFilter
    });
    
    const branchCollection = getCollection('branches');
    const objectId = new ObjectId(odpId);
    
    // Pipeline aggregation untuk mencari branch yang berisi ODP dengan ID tertentu
    const pipeline = [
      // Match branches yang memiliki ODP dengan ID tertentu
      {
        $match: {
          'children.children.pon_port.children.trays.children._id': objectId
        }
      }
    ];
    
    // Tambahkan filter deleted
    if (deletedFilter === DeletedFilterTypes.ONLY) {
      pipeline[0].$match['children.children.pon_port.children.trays.children.deleted_at'] = { $exists: true };
      logDebug('Menambahkan filter ONLY - mencari yang memiliki deleted_at', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
    } else if (deletedFilter === DeletedFilterTypes.WITHOUT) {
      pipeline[0].$match['children.children.pon_port.children.trays.children.deleted_at'] = { $exists: false };
      logDebug('Menambahkan filter WITHOUT - mencari yang tidak memiliki deleted_at', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
    }
    
    logDebug('Query MongoDB untuk mencari ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      pipeline: JSON.stringify(pipeline)
    });
    
    // Eksekusi query untuk mendapatkan branch
    const branches = await branchCollection.aggregate(pipeline).toArray();
    logDebug(`Jumlah branches ditemukan: ${branches.length}`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      branchCount: branches.length
    });
    
    if (!branches || branches.length === 0) {
      logWarn('Tidak ada branch yang ditemukan untuk ODP', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
      return null;
    }
    
    // Ambil branch pertama yang memiliki ODP tersebut
    const branch = branches[0];
    
    // Variabel untuk menyimpan indeks dan data
    let routerIndex = -1;
    let oltIndex = -1;
    let ponPortIndex = -1;
    let odcIndex = -1;
    let trayIndex = -1;
    let odpIndex = -1;
    let odpData = null;
    
    // Loop melalui branch > router > olt > pon_port > odc > tray > odp
    outerLoop: for (let i = 0; i < branch.children.length; i++) {
      const router = branch.children[i];
      
      if (router.children && Array.isArray(router.children)) {
        for (let j = 0; j < router.children.length; j++) {
          const olt = router.children[j];
          
          if (olt.pon_port && Array.isArray(olt.pon_port)) {
            for (let k = 0; k < olt.pon_port.length; k++) {
              const ponPort = olt.pon_port[k];
              
              if (ponPort.children && Array.isArray(ponPort.children)) {
                for (let l = 0; l < ponPort.children.length; l++) {
                  const odc = ponPort.children[l];
                  
                  if (odc.trays && Array.isArray(odc.trays)) {
                    for (let m = 0; m < odc.trays.length; m++) {
                      const tray = odc.trays[m];
                      
                      if (tray.children && Array.isArray(tray.children)) {
                        for (let n = 0; n < tray.children.length; n++) {
                          const odp = tray.children[n];
                          
                          if (odp._id.toString() === odpId.toString()) {
                            logDebug(`ODP ditemukan dengan deleted_at: ${odp.deleted_at || 'tidak ada'}`, {
                              requestId: context.getRequestId(),
                              userId: context.getUserId(),
                              odpId: odpId,
                              hasDeletedAt: !!odp.deleted_at
                            });
                            
                            // Periksa filter
                            if (deletedFilter === DeletedFilterTypes.ONLY && !odp.deleted_at) {
                              logDebug('ODP tidak memiliki deleted_at, tapi filter ONLY', {
                                requestId: context.getRequestId(),
                                userId: context.getUserId(),
                                odpId: odpId
                              });
                              continue;
                            }
                            if (deletedFilter === DeletedFilterTypes.WITHOUT && odp.deleted_at) {
                              logDebug('ODP memiliki deleted_at, tapi filter WITHOUT', {
                                requestId: context.getRequestId(),
                                userId: context.getUserId(),
                                odpId: odpId
                              });
                              continue;
                            }
                            
                            routerIndex = i;
                            oltIndex = j;
                            ponPortIndex = k;
                            odcIndex = l;
                            trayIndex = m;
                            odpIndex = n;
                            odpData = odp;
                            break outerLoop;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    
    // Jika ODP tidak ditemukan
    if (!odpData) {
      logWarn('ODP tidak ditemukan atau tidak memenuhi filter', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId,
        filter: deletedFilter
      });
      return null;
    }
    
    logInfo('ODP berhasil ditemukan dan memenuhi filter', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      filter: deletedFilter,
      odpLabel: odpData.label || 'unknown'
    });
    
    // Return objek dengan data ODP dan indeksnya
    return {
      odp: odpData,
      branchId: branch._id,
      routerIndex,
      oltIndex,
      ponPortIndex,
      odcIndex,
      trayIndex,
      odpIndex
    };
  } catch (error) {
    const { logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    
    logError('Error getting ODP by ID:', {
      requestId: getRequestContext().getRequestId(),
      userId: getRequestContext().getUserId(),
      odpId: odpId,
      error: error.message,
      stack: error.stack
    });
    
    throw error;
  }
}

/**
 * Mendapatkan detail ODP berdasarkan ID dengan level detail tertentu
 * @param {string} odpId - ID ODP
 * @param {string} resultType - Tipe hasil (ODPS)
 * @returns {Promise<Object>} - Data ODP sesuai level detail
 */
async function getOdpDetailById(odpId, resultType = null) {
  try {
    const { logDebug, logInfo, logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    const context = getRequestContext();
    
    logDebug(`Mencari detail ODP dengan ID: ${odpId}, result type: ${resultType || 'default'}`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      resultType: resultType || 'default'
    });
    
    const odpInfo = await getOdpById(odpId);
    
    if (!odpInfo || !odpInfo.odp) {
      logDebug(`ODP dengan ID ${odpId} tidak ditemukan`, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
      return null;
    }
    
    // Ambil data ODP
    const odp = odpInfo.odp;
    
    // Jika resultType tidak dispesifikasikan, kembalikan data lengkap seperti biasa
    if (!resultType || !Object.values(ResultTypes).includes(resultType)) {
      logDebug(`Mengembalikan data ODP lengkap dengan ID: ${odpId}`, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId,
        odpLabel: odp.label || 'unknown'
      });
      return odpInfo;
    }
    
    // Filter data sesuai resultType
    const odpCopy = { ...odp };
    
    // ODPS: Hapus children dari ODP
    if (resultType === ResultTypes.ODPS) {
      logDebug(`Mengembalikan data ODP yang difilter (tanpa ONT children) untuk ID: ${odpId}`, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId,
        odpLabel: odp.label || 'unknown',
        resultType: resultType
      });
      
      delete odpCopy.children;
      return {
        ...odpInfo,
        odp: odpCopy
      };
    }
    
    return odpInfo;
  } catch (error) {
    const { logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    
    logError(`Error getting ODP detail with ID ${odpId}:`, {
      requestId: getRequestContext().getRequestId(),
      userId: getRequestContext().getUserId(),
      odpId: odpId,
      resultType: resultType || 'default',
      error: error.message,
      stack: error.stack
    });
    
    throw error;
  }
}

/**
 * Menambahkan ONT ke ODP
 * @param {string} odpId - ID ODP
 * @param {Object} ontData - Data ONT yang akan ditambahkan
 * @returns {Promise<Object>} - Data ODP yang sudah diupdate dengan ONT baru
 */
async function addOntToOdp(odpId, ontData) {
  try {
    const { logDebug, logInfo, logWarn, logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    const context = getRequestContext();
    
    const collection = getCollection(COLLECTION);
    
    logDebug(`Memulai proses penambahan ONT ke ODP`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      ontLabel: ontData.label
    });
    
    // Dapatkan informasi ODP
    const odpInfo = await getOdpById(odpId);
    if (!odpInfo || !odpInfo.odp) {
      logWarn(`ODP tidak ditemukan untuk penambahan ONT`, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
      return null;
    }
    
    const { 
      odp, branchId, routerIndex, oltIndex, 
      ponPortIndex, odcIndex, trayIndex, odpIndex 
    } = odpInfo;
    
    // Validasi jumlah ONT tidak melebihi kapasitas port ODP
    const maxAvailablePort = odp.available_port || 0;
    const currentOntCount = odp.children ? odp.children.length : 0;
    
    logDebug(`Validasi kapasitas port ODP untuk ONT baru`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      odpLabel: odp.label || 'unknown',
      maxAvailablePort: maxAvailablePort,
      currentOntCount: currentOntCount
    });
    
    if (currentOntCount >= maxAvailablePort) {
      const errorMsg = `ODP port capacity exceeded. Maximum port: ${maxAvailablePort}, current ONT count: ${currentOntCount}`;
      logWarn(errorMsg, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId,
        odpLabel: odp.label || 'unknown',
        maxAvailablePort: maxAvailablePort,
        currentOntCount: currentOntCount
      });
      throw new Error(errorMsg);
    }

    // Buat entity ONT dengan ObjectId baru
    const ontId = new ObjectId();
    const ont = createNetDeviceOntEntity({
      ...ontData,
      _id: ontId
    });
    
    // Path untuk update
    const odpPath = `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children.${odpIndex}.children`;
    
    logDebug(`Menambahkan ONT ke ODP menggunakan path: ${odpPath}`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      odpLabel: odp.label || 'unknown',
      branchId: branchId.toString(),
      ontId: ontId.toString()
    });
    
    // Update branch, tambahkan ONT ke ODP
    const result = await collection.updateOne(
      { _id: branchId },
      { 
        $push: { [odpPath]: ont },
        $set: { updatedAt: new Date() }
      }
    );
    
    if (result.matchedCount === 0) {
      logWarn(`Gagal menambahkan ONT ke ODP, branch tidak ditemukan`, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId,
        branchId: branchId.toString()
      });
      return null;
    }
    
    logInfo(`ONT berhasil ditambahkan ke ODP`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      odpLabel: odp.label || 'unknown',
      ontId: ontId.toString(),
      ontLabel: ont.label
    });
    
    // Dapatkan data ODP yang telah diupdate
    return getOdpById(odpId);
  } catch (error) {
    const { logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    
    logError(`Error in addOntToOdp:`, {
      requestId: getRequestContext().getRequestId(),
      userId: getRequestContext().getUserId(),
      odpId: odpId,
      error: error.message,
      stack: error.stack
    });
    
    throw error;
  }
}

/**
 * Melakukan restore pada ODP yang telah di-soft delete
 * @param {string} odpId - ID ODP yang akan di-restore
 * @returns {Promise<Object|null>} - Hasil restore atau null jika ODP tidak ditemukan/tidak bisa di-restore
 */
async function restore(odpId) {
  try {
    const { logDebug, logInfo, logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    const context = getRequestContext();
    
    logDebug(`Mencoba restore ODP dengan ID: ${odpId}`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId
    });
    
    // Cari ODP yang memiliki deleted_at
    const odpInfo = await getOdpById(odpId, DeletedFilterTypes.ONLY);
    
    if (!odpInfo || !odpInfo.odp) {
      logDebug('ODP tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
      return null;
    }
    
    // Lakukan restore
    logDebug('Memanggil fungsi restoreOdp', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      odpLabel: odpInfo.odp.label || 'unknown'
    });
    
    const result = await restoreOdp(odpId);
    
    logInfo(`ODP berhasil di-restore`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      hasil: !!result
    });
    
    return result;
  } catch (error) {
    const { logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    
    logError('Error in ODP repository - restore:', {
      requestId: getRequestContext().getRequestId(),
      userId: getRequestContext().getUserId(),
      odpId: odpId,
      error: error.message,
      stack: error.stack
    });
    
    throw error;
  }
}

module.exports = {
  getOdpById,
  getOdpDetailById,
  addOntToOdp,
  ResultTypes,
  restore
}; ###
cat src/repositories/netDeviceOlt.repository.js
/**
 * Repository untuk operasi pada collection branches terkait net device OLT
 */

const { getCollection } = require('./database.connector');
const { createNetDeviceOdcEntity } = require('../entities/netDeviceOdc.entity');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { DeletedFilterTypes } = require('./branch.repository');
const { restoreOlt } = require('../utils/recursiveRestore.util');

// Nama collection
const COLLECTION = 'branches';

// Enum untuk tipe result
const ResultTypes = {
  OLTS: 'OLTS',
  ODCS: 'ODCS',
  ODPS: 'ODPS'
};

/**
 * Mendapatkan OLT berdasarkan ID
 * @param {string} oltId - ID OLT
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object>} - Data OLT
 */
async function getOltById(oltId, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    console.log(`[getOltById] Mencari OLT dengan ID: ${oltId}, filter: ${deletedFilter}`);
    const collection = getCollection(COLLECTION);
    const objectId = new ObjectId(oltId);
    
    // Cari branch yang memiliki OLT dengan ID tertentu
    const branch = await collection.findOne({
      'children.children._id': objectId
    });
    
    console.log(`[getOltById] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;
    
    // Variabel untuk menyimpan indeks dan data
    let routerIndex = -1;
    let oltIndex = -1;
    let oltData = null;
    
    // Loop melalui branch > router > olt
    outerLoop: for (let i = 0; i < branch.children.length; i++) {
      const router = branch.children[i];
      
      if (router.children && Array.isArray(router.children)) {
        for (let j = 0; j < router.children.length; j++) {
          const olt = router.children[j];
          
          if (olt._id.toString() === oltId.toString()) {
            console.log(`[getOltById] OLT ditemukan dengan deleted_at: ${olt.deleted_at || 'tidak ada'}`);
            
            // Periksa filter
            if (deletedFilter === DeletedFilterTypes.ONLY && !olt.deleted_at) {
              console.log('[getOltById] OLT tidak memiliki deleted_at, tapi filter ONLY');
              continue;
            }
            if (deletedFilter === DeletedFilterTypes.WITHOUT && olt.deleted_at) {
              console.log('[getOltById] OLT memiliki deleted_at, tapi filter WITHOUT');
              continue;
            }
            
            routerIndex = i;
            oltIndex = j;
            oltData = olt;
            break outerLoop;
          }
        }
      }
    }
    
    // Jika OLT tidak ditemukan atau tidak memenuhi filter
    if (!oltData) {
      console.log('[getOltById] OLT tidak ditemukan atau tidak memenuhi filter');
      return null;
    }
    
    console.log('[getOltById] OLT berhasil ditemukan dan memenuhi filter');
    
    // Return objek dengan data OLT dan indeksnya
    return {
      olt: oltData,
      branchId: branch._id,
      routerIndex,
      oltIndex
    };
  } catch (error) {
    console.error('Error getting OLT by ID:', error);
    throw error;
  }
}

/**
 * Mendapatkan detail OLT berdasarkan ID dengan level detail tertentu
 * @param {string} oltId - ID OLT
 * @param {string} resultType - Tipe hasil (OLTS, ODCS, ODPS)
 * @returns {Promise<Object>} - Data OLT sesuai level detail
 */
async function getOltDetailById(oltId, resultType = null) {
  try {
    const oltInfo = await getOltById(oltId);
    
    if (!oltInfo || !oltInfo.olt) {
      return null;
    }
    
    // Ambil data OLT
    const olt = oltInfo.olt;
    
    // Jika resultType tidak dispesifikasikan, kembalikan data lengkap seperti biasa
    if (!resultType || !Object.values(ResultTypes).includes(resultType)) {
      return oltInfo;
    }
    
    // Filter data sesuai resultType
    const oltCopy = { ...olt };
    
    // OLTS: Hapus children dari setiap port di pon_port
    if (resultType === ResultTypes.OLTS) {
      if (oltCopy.pon_port && Array.isArray(oltCopy.pon_port)) {
        oltCopy.pon_port = oltCopy.pon_port.map(port => {
          const portCopy = { ...port };
          delete portCopy.children;
          return portCopy;
        });
      }
      return {
        ...oltInfo,
        olt: oltCopy
      };
    }
    
    // ODCS: Hapus children dari setiap tray di trays dari ODC
    if (resultType === ResultTypes.ODCS) {
      if (oltCopy.pon_port && Array.isArray(oltCopy.pon_port)) {
        oltCopy.pon_port = oltCopy.pon_port.map(port => {
          const portCopy = { ...port };
          
          if (portCopy.children && Array.isArray(portCopy.children)) {
            portCopy.children = portCopy.children.map(odc => {
              const odcCopy = { ...odc };
              
              // Tetap menyertakan trays tapi hapus children dari setiap tray
              if (odcCopy.trays && Array.isArray(odcCopy.trays)) {
                odcCopy.trays = odcCopy.trays.map(tray => {
                  const trayCopy = { ...tray };
                  delete trayCopy.children;
                  return trayCopy;
                });
              }
              
              return odcCopy;
            });
          }
          
          return portCopy;
        });
      }
      return {
        ...oltInfo,
        olt: oltCopy
      };
    }
    
    // ODPS: Hapus children dari setiap ODP
    if (resultType === ResultTypes.ODPS) {
      if (oltCopy.pon_port && Array.isArray(oltCopy.pon_port)) {
        oltCopy.pon_port = oltCopy.pon_port.map(port => {
          const portCopy = { ...port };
          
          if (portCopy.children && Array.isArray(portCopy.children)) {
            portCopy.children = portCopy.children.map(odc => {
              const odcCopy = { ...odc };
              
              if (odcCopy.trays && Array.isArray(odcCopy.trays)) {
                odcCopy.trays = odcCopy.trays.map(tray => {
                  const trayCopy = { ...tray };
                  
                  if (trayCopy.children && Array.isArray(trayCopy.children)) {
                    trayCopy.children = trayCopy.children.map(odp => {
                      const odpCopy = { ...odp };
                      delete odpCopy.children;
                      return odpCopy;
                    });
                  }
                  
                  return trayCopy;
                });
              }
              
              return odcCopy;
            });
          }
          
          return portCopy;
        });
      }
      return {
        ...oltInfo,
        olt: oltCopy
      };
    }
    
    return oltInfo;
  } catch (error) {
    console.error(`Error getting OLT detail with ID ${oltId}:`, error);
    throw error;
  }
}

/**
 * Menambahkan ODC ke OLT berdasarkan ID OLT pada port tertentu
 * @param {string} oltId - ID OLT
 * @param {Object} odcData - Data ODC yang akan ditambahkan
 * @returns {Promise<Object>} - Data OLT yang sudah diupdate dengan ODC baru di port tertentu
 */
async function addOdcToOlt(oltId, odcData) {
  try {
    const collection = getCollection(COLLECTION);
    
    // Dapatkan informasi OLT
    const oltInfo = await getOltById(oltId);
    if (!oltInfo || !oltInfo.olt) {
      return null;
    }
    
    const { olt, branchId, routerIndex, oltIndex } = oltInfo;
    
    // Cari port yang sesuai dengan pon_port
    const ponPortIndex = olt.pon_port.findIndex(port => port.port === odcData.pon_port);
    if (ponPortIndex === -1) {
      throw new Error(`Port ${odcData.pon_port} not found on OLT ${oltId}`);
    }
    
    // Buat trays berdasarkan available_tray dan cores_per_tray
    const trays = [];
    const availableTray = odcData.available_tray || 0;
    const coresPerTray = odcData.cores_per_tray || 0;
    
    for (let i = 0; i < availableTray; i++) {
      trays.push({
        tray: i + 1,
        start_core: 1 + (coresPerTray * i),
        end_core: coresPerTray * (i + 1),
        children: []
      });
    }
    
    // Hapus properti pon_port dan cores_per_tray dari data
    delete odcData.pon_port;
    delete odcData.cores_per_tray;
    
    // Buat entity ODC dengan ObjectId baru
    const odcId = new ObjectId();
    const odc = createNetDeviceOdcEntity({
      ...odcData,
      _id: odcId,
      trays
    });
    
    // Path untuk update
    const oltPath = `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children`;
    
    // Update branch, tambahkan ODC ke port OLT
    const result = await collection.updateOne(
      { _id: branchId },
      { 
        $push: { [oltPath]: odc },
        $set: { updatedAt: new Date() }
      }
    );
    
    if (result.matchedCount === 0) {
      return null;
    }
    
    // Dapatkan OLT yang sudah diupdate
    return getOltById(oltId);
  } catch (error) {
    console.error(`Error adding ODC to OLT with ID ${oltId}:`, error);
    throw error;
  }
}

/**
 * Melakukan restore pada OLT yang telah di-soft delete
 * @param {string} oltId - ID OLT yang akan di-restore
 * @returns {Promise<Object|null>} - Hasil restore atau null jika OLT tidak ditemukan/tidak bisa di-restore
 */
async function restore(oltId) {
  try {
    console.log(`[restore] Mencoba restore OLT dengan ID: ${oltId}`);
    
    // Cari OLT yang memiliki deleted_at
    const oltInfo = await getOltById(oltId, DeletedFilterTypes.ONLY);
    console.log(`[restore] Status pencarian OLT yang dihapus:`, oltInfo);
    
    if (!oltInfo || !oltInfo.olt) {
      console.log('[restore] OLT tidak ditemukan atau sudah di-restore');
      return null;
    }
    
    // Lakukan restore
    console.log('[restore] Memanggil fungsi restoreOlt');
    const result = await restoreOlt(oltId);
    console.log(`[restore] Hasil restore:`, result);
    
    return result;
  } catch (error) {
    console.error('Error in OLT repository - restore:', error);
    throw error;
  }
}

module.exports = {
  getOltById,
  getOltDetailById,
  addOdcToOlt,
  restore,
  ResultTypes
}; ###
cat src/repositories/netDeviceOnt.repository.js
/**
 * Repository untuk operasi pada collection branches terkait net device ONT
 */

const { getCollection } = require('./database.connector');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { DeletedFilterTypes } = require('./branch.repository');
const { recursiveDeletedCheck } = require('../utils/recursiveDeletedCheck.util');

// Nama collection
const COLLECTION = 'branches';

/**
 * Mendapatkan ONT berdasarkan ID
 * @param {string} ontId - ID ONT
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object|null>} ONT yang ditemukan atau null
 */
async function getOntById(ontId, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    console.log(`[getOntById] Mencari ONT dengan ID: ${ontId}, filter: ${deletedFilter}`);
    
    const collection = getCollection(COLLECTION);
    
    // Cari branch yang memiliki ONT dengan ID yang sesuai
    const query = {
      $or: [
        { 'children.children.pon_port.children.trays.children.children.children._id': new ObjectId(ontId) },
        { 'children.children.pon_port.children.trays.children.children._id': new ObjectId(ontId) }
      ]
    };
    
    console.log('[getOntById] Query MongoDB:', JSON.stringify(query, null, 2));
    
    const branch = await collection.findOne(query);
    
    console.log(`[getOntById] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;

    // Cari ONT dalam struktur nested
    let foundOnt = null;
    const searchOnt = (obj) => {
      // Log untuk debugging
      if (obj._id) {
        console.log(`[searchOnt] Memeriksa object dengan ID: ${obj._id.toString()}`);
      }
      
      if (obj._id && obj._id.toString() === ontId.toString()) {
        console.log('[searchOnt] ONT ditemukan!');
        foundOnt = { ...obj };
        return;
      }
      
      // Cek children
      if (obj.children && Array.isArray(obj.children)) {
        obj.children.forEach(child => searchOnt(child));
      }
      
      // Cek pon_port dan children-nya
      if (obj.pon_port && Array.isArray(obj.pon_port)) {
        obj.pon_port.forEach(port => {
          if (port.children) {
            port.children.forEach(child => searchOnt(child));
          }
        });
      }
      
      // Cek trays dan children-nya
      if (obj.trays && Array.isArray(obj.trays)) {
        obj.trays.forEach(tray => {
          if (tray.children) {
            tray.children.forEach(child => searchOnt(child));
          }
        });
      }
    };

    searchOnt(branch);
    
    console.log(`[getOntById] ONT ditemukan setelah pencarian: ${foundOnt ? 'Ya' : 'Tidak'}`);
    
    // Jika ONT tidak ditemukan
    if (!foundOnt) {
      console.log('[getOntById] ONT tidak ditemukan setelah pencarian mendalam');
      return null;
    }

    // Log status deleted
    console.log(`[getOntById] Status deleted_at ONT: ${foundOnt.deleted_at ? 'Ada' : 'Tidak ada'}`);
    
    // Terapkan filter deleted
    if (deletedFilter === DeletedFilterTypes.ONLY && !foundOnt.deleted_at) {
      console.log('[getOntById] ONT tidak memiliki deleted_at, tapi filter ONLY');
      return null;
    }
    if (deletedFilter === DeletedFilterTypes.WITHOUT && foundOnt.deleted_at) {
      console.log('[getOntById] ONT memiliki deleted_at, tapi filter WITHOUT');
      return null;
    }
    
    console.log('[getOntById] ONT berhasil ditemukan dan memenuhi filter');
    return foundOnt;
  } catch (error) {
    console.error('Error getting ONT by ID:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada ONT berdasarkan ID
 * @param {string} ontId - ID ONT
 * @returns {Promise<Object>} - ONT yang sudah di-soft delete
 */
async function softDeleteOnt(ontId) {
  try {
    console.log(`[softDeleteOnt] Mencoba soft delete ONT dengan ID: ${ontId}`);
    
    // Dapatkan informasi ONT
    const ont = await getOntById(ontId, DeletedFilterTypes.WITHOUT);
    if (!ont) {
      console.log('[softDeleteOnt] ONT tidak ditemukan atau sudah dihapus');
      return null;
    }

    const collection = getCollection(COLLECTION);
    
    // Update ONT menggunakan array filters
    const result = await collection.updateOne(
      {
        $or: [
          { 'children.children.pon_port.children.trays.children.children.children._id': new ObjectId(ontId) },
          { 'children.children.pon_port.children.trays.children.children._id': new ObjectId(ontId) }
        ]
      },
      {
        $set: {
          'children.$[].children.$[].pon_port.$[].children.$[].trays.$[].children.$[].children.$[ont].deleted_at': new Date(),
          updatedAt: new Date()
        }
      },
      {
        arrayFilters: [
          { 'ont._id': new ObjectId(ontId) }
        ]
      }
    );

    console.log(`[softDeleteOnt] Update result: matchedCount=${result.matchedCount}, modifiedCount=${result.modifiedCount}`);
    
    if (result.modifiedCount === 0) {
      console.log('[softDeleteOnt] Gagal melakukan soft delete ONT');
      return null;
    }

    // Dapatkan ONT yang sudah diupdate (dengan WITH filter karena sudah di-soft delete)
    const updatedOnt = await getOntById(ontId, DeletedFilterTypes.WITH);
    console.log('[softDeleteOnt] ONT berhasil di-soft delete');
    
    return updatedOnt;
  } catch (error) {
    console.error('Error soft deleting ONT:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada ONT yang sudah di-soft delete
 * @param {string} ontId - ID ONT yang akan di-restore
 * @returns {Promise<Object|null>} ONT yang sudah di-restore atau null jika tidak ditemukan
 */
async function restoreOnt(ontId) {
  try {
    console.log(`[restoreOnt] Mencoba restore ONT dengan ID: ${ontId}`);
    
    const collection = getCollection(COLLECTION);
    
    // Cari ONT yang memiliki deleted_at
    const ont = await getOntById(ontId, DeletedFilterTypes.ONLY);
    console.log(`[restoreOnt] ONT ditemukan dengan filter ONLY: ${ont ? 'Ya' : 'Tidak'}`);
    
    if (!ont) {
      console.log('[restoreOnt] ONT tidak ditemukan atau sudah di-restore');
      return null;
    }

    // Update ONT dengan menghapus field deleted_at menggunakan array filters
    const result = await collection.updateOne(
      {
        $or: [
          { 'children.children.pon_port.children.trays.children.children.children._id': new ObjectId(ontId) },
          { 'children.children.pon_port.children.trays.children.children._id': new ObjectId(ontId) }
        ]
      },
      {
        $unset: {
          'children.$[].children.$[].pon_port.$[].children.$[].trays.$[].children.$[].children.$[ont].deleted_at': ""
        },
        $set: {
          updatedAt: new Date()
        }
      },
      {
        arrayFilters: [
          { 'ont._id': new ObjectId(ontId) }
        ]
      }
    );

    console.log(`[restoreOnt] Update result: matchedCount=${result.matchedCount}, modifiedCount=${result.modifiedCount}`);

    if (result.modifiedCount === 0) {
      console.log('[restoreOnt] Gagal melakukan restore ONT');
      return null;
    }

    // Ambil data ONT yang sudah di-restore
    const restoredOnt = await getOntById(ontId, DeletedFilterTypes.WITHOUT);
    console.log('[restoreOnt] ONT berhasil di-restore');
    
    return restoredOnt;
  } catch (error) {
    console.error('Error restoring ONT:', error);
    throw error;
  }
}

module.exports = {
  getOntById,
  softDeleteOnt,
  restoreOnt
}; ###
cat src/repositories/netDeviceRouter.repository.js
/**
 * Repository untuk operasi pada collection branches terkait net device router
 */

const { getCollection } = require('./database.connector');
const { createNetDeviceOltEntity } = require('../entities/netDeviceOlt.entity');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { DeletedFilterTypes } = require('./branch.repository');
const { restoreRouter } = require('../utils/recursiveRestore.util');

// Nama collection
const COLLECTION = 'branches';

// Enum untuk tipe result
const ResultTypes = {
  ROUTERS: 'ROUTERS',
  OLTS: 'OLTS',
  ODCS: 'ODCS',
  ODPS: 'ODPS'
};

/**
 * Mendapatkan Router berdasarkan ID
 * @param {string} routerId - ID Router
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object>} - Data Router
 */
async function getRouterById(routerId, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    console.log(`[getRouterById] Mencari Router dengan ID: ${routerId}, filter: ${deletedFilter}`);
    const collection = getCollection(COLLECTION);
    const objectId = new ObjectId(routerId);
    
    // Cari branch yang memiliki Router dengan ID tertentu
    const branch = await collection.findOne({
      'children._id': objectId
    });
    
    console.log(`[getRouterById] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;
    
    // Variabel untuk menyimpan indeks dan data
    let routerIndex = -1;
    let routerData = null;
    
    // Loop melalui branch > router
    for (let i = 0; i < branch.children.length; i++) {
      const router = branch.children[i];
      
      if (router._id.toString() === routerId.toString()) {
        console.log(`[getRouterById] Router ditemukan dengan deleted_at: ${router.deleted_at || 'tidak ada'}`);
        
        // Periksa filter
        if (deletedFilter === DeletedFilterTypes.ONLY && !router.deleted_at) {
          console.log('[getRouterById] Router tidak memiliki deleted_at, tapi filter ONLY');
          continue;
        }
        if (deletedFilter === DeletedFilterTypes.WITHOUT && router.deleted_at) {
          console.log('[getRouterById] Router memiliki deleted_at, tapi filter WITHOUT');
          continue;
        }
        
        routerIndex = i;
        routerData = router;
        break;
      }
    }
    
    // Jika Router tidak ditemukan atau tidak memenuhi filter
    if (!routerData) {
      console.log('[getRouterById] Router tidak ditemukan atau tidak memenuhi filter');
      return null;
    }
    
    console.log('[getRouterById] Router berhasil ditemukan dan memenuhi filter');
    
    // Return objek dengan data Router dan indeksnya
    return {
      router: routerData,
      branchId: branch._id,
      routerIndex
    };
  } catch (error) {
    console.error('Error getting Router by ID:', error);
    throw error;
  }
}

/**
 * Menambahkan OLT ke Router
 * @param {string} routerId - ID Router
 * @param {Object} oltData - Data OLT yang akan ditambahkan
 * @returns {Promise<Object>} - Data Router yang sudah diupdate dengan OLT baru
 */
async function addOltToRouter(routerId, oltData) {
  try {
    const collection = getCollection(COLLECTION);
    
    // Dapatkan informasi Router
    const routerInfo = await getRouterById(routerId);
    if (!routerInfo || !routerInfo.router) {
      return null;
    }
    
    const { router, branchId, routerIndex } = routerInfo;
    
    // Buat entity OLT dengan ObjectId baru
    const oltId = new ObjectId();
    const olt = createNetDeviceOltEntity({
      ...oltData,
      _id: oltId
    });
    
    // Update branch, tambahkan OLT ke Router
    const result = await collection.updateOne(
      { _id: branchId },
      { 
        $push: { [`children.${routerIndex}.children`]: olt },
        $set: { updatedAt: new Date() }
      }
    );
    
    if (result.matchedCount === 0) {
      return null;
    }
    
    // Dapatkan Router yang sudah diupdate
    return getRouterById(routerId);
  } catch (error) {
    console.error(`Error adding OLT to Router with ID ${routerId}:`, error);
    throw error;
  }
}

/**
 * Melakukan restore pada Router yang telah di-soft delete
 * @param {string} routerId - ID Router yang akan di-restore
 * @returns {Promise<Object|null>} - Hasil restore atau null jika Router tidak ditemukan/tidak bisa di-restore
 */
async function restore(routerId) {
  try {
    console.log(`[restore] Mencoba restore Router dengan ID: ${routerId}`);
    
    // Cari Router yang memiliki deleted_at
    const routerInfo = await getRouterById(routerId, DeletedFilterTypes.ONLY);
    console.log(`[restore] Status pencarian Router yang dihapus:`, routerInfo);
    
    if (!routerInfo || !routerInfo.router) {
      console.log('[restore] Router tidak ditemukan atau sudah di-restore');
      return null;
    }
    
    // Lakukan restore
    console.log('[restore] Memanggil fungsi restoreRouter');
    const result = await restoreRouter(routerId);
    console.log(`[restore] Hasil restore:`, result);
    
    return result;
  } catch (error) {
    console.error('Error in Router repository - restore:', error);
    throw error;
  }
}

module.exports = {
  getRouterById,
  addOltToRouter,
  restore,
  ResultTypes
}; ###
cat src/entities/address.entity.js
/**
 * Entity untuk address (alamat)
 */

/**
 * Fungsi untuk membuat objek address
 * @param {Object} data - Data alamat
 * @returns {Object} - Objek address
 */
function createAddressEntity(data = {}) {
  return {
    country: data.country || 'ID', // Default Indonesia
    province: data.province || '',
    city: data.city || '',
    district: data.district || '',
    village: data.village || '',
    detail: data.detail || '',
    zip_code: data.zip_code || ''
  };
}

/**
 * Fungsi untuk memvalidasi data address
 * @param {Object} data - Data address
 * @returns {boolean} - True jika valid
 */
function validateAddressEntity(data) {
  if (!data) {
    return false;
  }
  
  // Validasi country (harus ada dan string)
  if (!data.country || typeof data.country !== 'string') {
    return false;
  }
  
  // Validasi tipe data
  const stringFields = ['province', 'city', 'district', 'village', 'detail', 'zip_code'];
  for (const field of stringFields) {
    if (data[field] && typeof data[field] !== 'string') {
      return false;
    }
  }
  
  return true;
}

module.exports = {
  createAddressEntity,
  validateAddressEntity
}; ###
cat src/entities/branch.entity.js
/**
 * Entity untuk branch (cabang)
 */

const { createLocationEntity, validateLocationEntity } = require('./location.entity');
const { createAddressEntity, validateAddressEntity } = require('./address.entity');
const { createContactEntity, validateContactEntity } = require('./contact.entity');
const { validateNetDeviceRouterEntity } = require('./netDeviceRouter.entity');

/**
 * Fungsi untuk membuat objek branch
 * @param {Object} data - Data branch
 * @returns {Object} - Objek branch
 */
function createBranchEntity(data = {}) {
  return {
    _id: data._id || null,
    name: data.name || '',
    location: data.location ? createLocationEntity(data.location) : createLocationEntity(),
    address: data.address ? createAddressEntity(data.address) : createAddressEntity(),
    contact: data.contact ? createContactEntity(data.contact) : createContactEntity(),
    children: data.children || [],
    createdAt: data.createdAt || new Date(),
    updatedAt: data.updatedAt || new Date()
  };
}

/**
 * Fungsi untuk memvalidasi data branch
 * @param {Object} data - Data branch
 * @returns {boolean} - True jika valid
 */
function validateBranchEntity(data) {
  if (!data.name || typeof data.name !== 'string') {
    return false;
  }
  
  if (data.name.length < 3 || data.name.length > 64) {
    return false;
  }
  
  // Validasi location jika ada
  if (data.location && !validateLocationEntity(data.location)) {
    return false;
  }
  
  // Validasi address jika ada
  if (data.address && !validateAddressEntity(data.address)) {
    return false;
  }
  
  // Validasi contact jika ada
  if (data.contact && !validateContactEntity(data.contact)) {
    return false;
  }
  
  // Validasi children jika ada
  if (data.children) {
    if (!Array.isArray(data.children)) {
      return false;
    }
    
    // Validasi setiap item dalam children harus berupa netDeviceRouter
    for (const child of data.children) {
      if (!validateNetDeviceRouterEntity(child)) {
        return false;
      }
    }
  }
  
  return true;
}

module.exports = {
  createBranchEntity,
  validateBranchEntity
};
###
cat src/entities/branchAccess.entity.js
const { ObjectId } = require('mongodb');

/**
 * @typedef {Object} BranchAccess
 * @property {ObjectId} _id - ID dari dokumen branch access
 * @property {ObjectId} branch_id - ID dari branch yang diakses
 * @property {string} user_id - UUID dari user yang memiliki akses
 * @property {('R'|'RW')} permission - Tipe akses: R (read) atau RW (read-write)
 */

/**
 * Membuat objek BranchAccess baru
 * @param {Object} data - Data untuk membuat BranchAccess
 * @param {string|ObjectId} data.branch_id - ID dari branch
 * @param {string} data.user_id - UUID dari user
 * @param {string} data.permission - Tipe akses (R/RW)
 * @returns {BranchAccess}
 */
function createBranchAccess(data) {
  return {
    _id: new ObjectId(),
    branch_id: typeof data.branch_id === 'string' ? new ObjectId(data.branch_id) : data.branch_id,
    user_id: data.user_id,
    permission: data.permission
  };
}

/**
 * Memvalidasi data BranchAccess
 * @param {Object} data - Data yang akan divalidasi
 * @throws {Error} Jika validasi gagal
 */
function validateBranchAccess(data) {
  if (!data.branch_id) {
    throw new Error('branch_id is required');
  }
  if (!data.user_id) {
    throw new Error('user_id is required');
  }
  if (!data.permission || !['R', 'RW'].includes(data.permission)) {
    throw new Error('permission must be either R or RW');
  }
}

module.exports = {
  createBranchAccess,
  validateBranchAccess
}; ###
cat src/entities/contact.entity.js
/**
 * Entity untuk contact (kontak)
 */

/**
 * Fungsi untuk membuat objek contact
 * @param {Object} data - Data kontak
 * @returns {Object} - Objek contact
 */
function createContactEntity(data = {}) {
  return {
    email: data.email || '',
    phone: data.phone || ''
  };
}

/**
 * Fungsi untuk memvalidasi data contact
 * @param {Object} data - Data contact
 * @returns {boolean} - True jika valid
 */
function validateContactEntity(data) {
  if (!data) {
    return false;
  }
  
  // Validasi email jika ada
  if (data.email) {
    if (typeof data.email !== 'string') {
      return false;
    }
    
    // Simple email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(data.email)) {
      return false;
    }
  }
  
  // Validasi phone jika ada
  if (data.phone) {
    if (typeof data.phone !== 'string') {
      return false;
    }
    
    // Simple phone validation (at least 8 digits)
    const phoneRegex = /^\+?[0-9]{8,15}$/;
    if (!phoneRegex.test(data.phone)) {
      return false;
    }
  }
  
  return true;
}

module.exports = {
  createContactEntity,
  validateContactEntity
}; ###
cat src/entities/location.entity.js
/**
 * Entity untuk location (lokasi) menggunakan format GeoJSON Point
 */

/**
 * Fungsi untuk membuat objek location
 * @param {Object} data - Data lokasi
 * @returns {Object} - Objek location dalam format GeoJSON Point
 */
function createLocationEntity(data = {}) {
  return {
    type: data.type || "Point",
    coordinates: data.coordinates || [0, 0] // [longitude, latitude]
  };
}

/**
 * Fungsi untuk memvalidasi data location
 * @param {Object} data - Data location
 * @returns {boolean} - True jika valid
 */
function validateLocationEntity(data) {
  if (!data || !data.type || !data.coordinates) {
    return false;
  }
  
  if (data.type !== "Point") {
    return false;
  }
  
  if (!Array.isArray(data.coordinates) || data.coordinates.length !== 2) {
    return false;
  }
  
  // Validasi longitude (-180 sampai 180)
  if (typeof data.coordinates[0] !== 'number' || 
      data.coordinates[0] < -180 || 
      data.coordinates[0] > 180) {
    return false;
  }
  
  // Validasi latitude (-90 sampai 90)
  if (typeof data.coordinates[1] !== 'number' || 
      data.coordinates[1] < -90 || 
      data.coordinates[1] > 90) {
    return false;
  }
  
  return true;
}

module.exports = {
  createLocationEntity,
  validateLocationEntity
}; ###
cat src/entities/log.entity.js
/**
 * Entity untuk log
 */

const { generateUUID } = require('../utils/uuid.util');

/**
 * Membuat log entity
 * @param {Object} logData - Data log yang akan dibuat
 * @returns {Object} Log entity
 */
function createLogEntity(logData) {
  const now = new Date();
  
  return {
    _id: generateUUID(),
    timestamp: now.toISOString(),
    level: logData.level,
    message: logData.message,
    context: {
      service: 'infrastructure-service',
      environment: process.env.NODE_ENV || 'development',
      requestId: logData.requestId,
      userId: logData.userId,
      method: logData.method,
      url: logData.url,
      statusCode: logData.statusCode,
      responseTime: logData.responseTime,
      userAgent: logData.userAgent,
      ip: logData.ip
    },
    metadata: logData.metadata || {},
    labels: {
      type: logData.type || 'application',
      component: logData.component || 'general'
    },
    createdAt: now,
    updatedAt: now
  };
}

module.exports = {
  createLogEntity
}; ###
cat src/entities/netDevice.entity.js
/**
 * Entity untuk netDevice (perangkat jaringan)
 */

const { createLocationEntity, validateLocationEntity } = require('./location.entity');
const { createAddressEntity, validateAddressEntity } = require('./address.entity');

/**
 * Fungsi untuk membuat objek netDevice
 * @param {Object} data - Data perangkat jaringan
 * @returns {Object} - Objek netDevice
 */
function createNetDeviceEntity(data = {}) {
  return {
    _id: data._id || null,
    label: data.label || '',
    type: data.type || '',
    location: data.location ? createLocationEntity(data.location) : createLocationEntity(),
    address: data.address ? createAddressEntity(data.address) : createAddressEntity(),
    createdAt: data.createdAt || new Date(),
    updatedAt: data.updatedAt || new Date()
  };
}

/**
 * Fungsi untuk memvalidasi data netDevice
 * @param {Object} data - Data netDevice
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceEntity(data) {
  if (!data.label || typeof data.label !== 'string') {
    return false;
  }
  
  if (!data.type || typeof data.type !== 'string') {
    return false;
  }
  
  // Validasi location jika ada
  if (data.location && !validateLocationEntity(data.location)) {
    return false;
  }
  
  // Validasi address jika ada
  if (data.address && !validateAddressEntity(data.address)) {
    return false;
  }
  
  return true;
}

module.exports = {
  createNetDeviceEntity,
  validateNetDeviceEntity
};
###
cat src/entities/netDeviceConn.entity.js
/**
 * Entity untuk berbagai jenis koneksi perangkat jaringan
 * File ini berisi definisi entity untuk koneksi telnet, ssh, dan snmp
 */

/**
 * Fungsi untuk validasi alamat IP v4
 * @param {string} ip - Alamat IP yang akan divalidasi
 * @returns {boolean} - True jika valid
 */
function isValidIPv4(ip) {
  if (typeof ip !== 'string') return false;
  
  // Pola IPv4: xxx.xxx.xxx.xxx
  const pattern = /^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  return pattern.test(ip);
}

/**
 * Fungsi untuk validasi port yang valid
 * @param {number} port - Nomor port yang akan divalidasi
 * @returns {boolean} - True jika valid
 */
function isValidPort(port) {
  return Number.isInteger(port) && port > 0 && port <= 65535;
}

/**
 * Fungsi untuk membuat objek koneksi telnet
 * @param {Object} data - Data koneksi telnet
 * @returns {Object} - Objek koneksi telnet
 */
function createTelnetConnEntity(data = {}) {
  return {
    ip_addr: data.ip_addr || '',
    port: data.port || 23, // Default telnet port
    username: data.username || '',
    password: data.password || ''
  };
}

/**
 * Fungsi untuk validasi koneksi telnet
 * @param {Object} data - Data koneksi telnet
 * @returns {boolean} - True jika valid
 */
function validateTelnetConnEntity(data) {
  if (!isValidIPv4(data.ip_addr)) {
    return false;
  }

  if (!isValidPort(data.port)) {
    return false;
  }

  if (typeof data.username !== 'string') {
    return false;
  }

  if (typeof data.password !== 'string') {
    return false;
  }

  return true;
}

/**
 * Fungsi untuk membuat objek koneksi SSH
 * @param {Object} data - Data koneksi SSH
 * @returns {Object} - Objek koneksi SSH
 */
function createSshConnEntity(data = {}) {
  return {
    ip_addr: data.ip_addr || '',
    port: data.port || 22, // Default SSH port
    username: data.username || '',
    password: data.password || ''
  };
}

/**
 * Fungsi untuk validasi koneksi SSH
 * @param {Object} data - Data koneksi SSH
 * @returns {boolean} - True jika valid
 */
function validateSshConnEntity(data) {
  if (!isValidIPv4(data.ip_addr)) {
    return false;
  }

  if (!isValidPort(data.port)) {
    return false;
  }

  if (typeof data.username !== 'string') {
    return false;
  }

  if (typeof data.password !== 'string') {
    return false;
  }

  return true;
}

/**
 * Fungsi untuk membuat objek koneksi SNMP
 * @param {Object} data - Data koneksi SNMP
 * @returns {Object} - Objek koneksi SNMP
 */
function createSnmpConnEntity(data = {}) {
  return {
    ip_addr: data.ip_addr || '',
    port: data.port || 161, // Default SNMP port
    community_read: data.community_read || 'public',
    community_write: data.community_write || 'private'
  };
}

/**
 * Fungsi untuk validasi koneksi SNMP
 * @param {Object} data - Data koneksi SNMP
 * @returns {boolean} - True jika valid
 */
function validateSnmpConnEntity(data) {
  if (!isValidIPv4(data.ip_addr)) {
    return false;
  }

  if (!isValidPort(data.port)) {
    return false;
  }

  if (typeof data.community_read !== 'string') {
    return false;
  }

  if (typeof data.community_write !== 'string') {
    return false;
  }

  return true;
}

module.exports = {
  createTelnetConnEntity,
  validateTelnetConnEntity,
  createSshConnEntity,
  validateSshConnEntity,
  createSnmpConnEntity,
  validateSnmpConnEntity,
  isValidIPv4,
  isValidPort
}; ###
cat src/entities/netDeviceOdc.entity.js
/**
 * Entity untuk netDeviceOdc (perangkat Optical Distribution Cabinet)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Fungsi untuk memeriksa tipe anak yang valid untuk ODC Tray
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidTrayChild(child) {
  // Hanya menerima netDeviceOdp
  return child && child.type && child.type === 'odp';
}

/**
 * Fungsi untuk membuat objek Tray ODC
 * @param {Object} data - Data tray
 * @returns {Object} - Objek tray
 */
function createOdcTrayEntity(data = {}) {
  return {
    tray: data.tray || 1,
    start_core: data.start_core || 1,
    end_core: data.end_core || 1,
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data tray ODC
 * @param {Object} data - Data tray
 * @param {Array} existingTrays - Array tray yang sudah ada (untuk validasi keunikan)
 * @returns {boolean} - True jika valid
 */
function validateOdcTrayEntity(data, existingTrays = []) {
  // Validasi tray number (harus integer dan dimulai dari 1)
  if (typeof data.tray !== 'number' || !Number.isInteger(data.tray) || data.tray < 1) {
    return false;
  }
  
  // Validasi keunikan tray number
  if (existingTrays.some(t => t.tray === data.tray)) {
    return false;
  }
  
  // Validasi start_core (harus integer)
  if (typeof data.start_core !== 'number' || !Number.isInteger(data.start_core) || data.start_core < 1) {
    return false;
  }
  
  // Validasi end_core (harus integer dan >= start_core)
  if (typeof data.end_core !== 'number' || !Number.isInteger(data.end_core) || data.end_core < data.start_core) {
    return false;
  }
  
  // Validasi children
  if (!Array.isArray(data.children)) {
    return false;
  }
  
  // Validasi setiap anak, pastikan tipenya adalah ODP
  for (const child of data.children) {
    if (!isValidTrayChild(child)) {
      return false;
    }
  }
  
  return true;
}

/**
 * Fungsi untuk membuat objek netDeviceOdc
 * @param {Object} data - Data ODC
 * @returns {Object} - Objek netDeviceOdc
 */
function createNetDeviceOdcEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'odc'
  });
  
  // Buat array trays jika ada
  const trays = [];
  if (Array.isArray(data.trays)) {
    data.trays.forEach(trayData => {
      trays.push(createOdcTrayEntity(trayData));
    });
  }
  
  // Tambahkan properti khusus ODC
  return {
    ...baseEntity,
    available_tray: data.available_tray || 0,
    trays: trays
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOdc
 * @param {Object} data - Data ODC
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOdcEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'odc'})) {
    return false;
  }
  
  // Validasi available_tray
  if (typeof data.available_tray !== 'number' || !Number.isInteger(data.available_tray) || data.available_tray < 0) {
    return false;
  }
  
  // Validasi trays
  if (data.trays) {
    if (!Array.isArray(data.trays)) {
      return false;
    }
    
    const existingTrays = [];
    for (const tray of data.trays) {
      if (!validateOdcTrayEntity(tray, existingTrays)) {
        return false;
      }
      existingTrays.push(tray);
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceOdcEntity,
  validateNetDeviceOdcEntity,
  createOdcTrayEntity,
  validateOdcTrayEntity
};
###
cat src/entities/netDeviceOdp.entity.js
/**
 * Entity untuk netDeviceOdp (perangkat Optical Distribution Point)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Fungsi untuk memeriksa tipe anak yang valid untuk ODP
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidChild(child) {
  // Hanya menerima netDeviceOnt
  return child && child.type && child.type === 'ont';
}

/**
 * Fungsi untuk membuat objek netDeviceOdp
 * @param {Object} data - Data ODP
 * @returns {Object} - Objek netDeviceOdp
 */
function createNetDeviceOdpEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'odp'
  });
  
  // Tambahkan properti khusus ODP
  return {
    ...baseEntity,
    core_on_odc_tray: data.core_on_odc_tray || 1,
    available_port: data.available_port || 0,
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOdp
 * @param {Object} data - Data ODP
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOdpEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'odp'})) {
    return false;
  }
  
  // Validasi core_on_odc_tray (harus integer dan dimulai dari 1)
  if (typeof data.core_on_odc_tray !== 'number' || !Number.isInteger(data.core_on_odc_tray) || data.core_on_odc_tray < 1) {
    return false;
  }
  
  // Validasi available_port (harus integer lebih besar dari 0)
  if (typeof data.available_port !== 'number' || !Number.isInteger(data.available_port) || data.available_port < 0) {
    return false;
  }
  
  // Validasi children
  if (data.children) {
    if (!Array.isArray(data.children)) {
      return false;
    }
    
    // Validasi setiap anak, pastikan tipenya adalah ONT
    for (const child of data.children) {
      if (!isValidChild(child)) {
        return false;
      }
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceOdpEntity,
  validateNetDeviceOdpEntity
};
###
cat src/entities/netDeviceOlt.entity.js
/**
 * Entity untuk netDeviceOlt (perangkat Optical Line Terminal)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');
const { 
  createTelnetConnEntity, validateTelnetConnEntity,
  createSshConnEntity, validateSshConnEntity,
  createSnmpConnEntity, validateSnmpConnEntity
} = require('./netDeviceConn.entity');

/**
 * Enum untuk tipe PON
 * @enum {string}
 */
const PonTypes = {
  GPON: 'GPON',
  EPON: 'EPON'
};

/**
 * Fungsi untuk memeriksa tipe anak yang valid untuk port PON
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidPortChild(child) {
  // Hanya menerima netDeviceOdc
  return child && child.type && child.type === 'odc';
}

/**
 * Fungsi untuk membuat objek PON port
 * @param {Object} data - Data port PON
 * @returns {Object} - Objek port PON
 */
function createPonPortEntity(data = {}) {
  return {
    port: data.port || 1,
    max_client: data.max_client || 1,
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data PON port
 * @param {Object} data - Data port PON
 * @param {Array} existingPorts - Array port yang sudah ada (untuk validasi keunikan)
 * @returns {boolean} - True jika valid
 */
function validatePonPortEntity(data, existingPorts = []) {
  // Validasi port number (harus integer dan dimulai dari 1)
  if (typeof data.port !== 'number' || !Number.isInteger(data.port) || data.port < 1) {
    return false;
  }
  
  // Validasi keunikan port number
  if (existingPorts.some(p => p.port === data.port)) {
    return false;
  }
  
  // Validasi max_client (harus integer lebih besar dari 0)
  if (typeof data.max_client !== 'number' || !Number.isInteger(data.max_client) || data.max_client < 1) {
    return false;
  }
  
  // Validasi children
  if (!Array.isArray(data.children)) {
    return false;
  }
  
  // Validasi setiap anak, pastikan tipenya adalah ODC
  for (const child of data.children) {
    if (!isValidPortChild(child)) {
      return false;
    }
  }
  
  return true;
}

/**
 * Fungsi untuk membuat objek netDeviceOlt
 * @param {Object} data - Data OLT
 * @returns {Object} - Objek netDeviceOlt
 */
function createNetDeviceOltEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'olt'
  });
  
  // Buat array pon_port berdasarkan available_pon
  const ponPorts = [];
  const availablePon = data.available_pon || 0;
  
  // Jika available_pon ada, buat port sejumlah available_pon
  if (availablePon > 0) {
    for (let i = 1; i <= availablePon; i++) {
      ponPorts.push(createPonPortEntity({
        port: i,
        max_client: 64, // Default max client untuk GPON
        children: []
      }));
    }
  } 
  // Jika pon_port sudah ada di data, gunakan itu
  else if (Array.isArray(data.pon_port)) {
    data.pon_port.forEach(portData => {
      ponPorts.push(createPonPortEntity(portData));
    });
  }
  
  // Tambahkan properti khusus OLT
  return {
    ...baseEntity,
    vendor: data.vendor || '',
    model: data.model || '',
    sn: data.sn || '',
    telnet_conn: data.telnet_conn ? createTelnetConnEntity(data.telnet_conn) : null,
    ssh_conn: data.ssh_conn ? createSshConnEntity(data.ssh_conn) : null,
    snmp_conn: data.snmp_conn ? createSnmpConnEntity(data.snmp_conn) : null,
    pon_type: data.pon_type || PonTypes.GPON,
    pon_port: ponPorts
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOlt
 * @param {Object} data - Data OLT
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOltEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'olt'})) {
    return false;
  }
  
  // Validasi properti vendor
  if (typeof data.vendor !== 'string') {
    return false;
  }
  
  // Validasi properti model
  if (typeof data.model !== 'string') {
    return false;
  }
  
  // Validasi properti serial number
  if (typeof data.sn !== 'string') {
    return false;
  }
  
  // Validasi koneksi telnet
  if (data.telnet_conn && !validateTelnetConnEntity(data.telnet_conn)) {
    return false;
  }
  
  // Validasi koneksi SSH
  if (data.ssh_conn && !validateSshConnEntity(data.ssh_conn)) {
    return false;
  }
  
  // Validasi koneksi SNMP
  if (data.snmp_conn && !validateSnmpConnEntity(data.snmp_conn)) {
    return false;
  }
  
  // Validasi pon_type
  if (data.pon_type && !Object.values(PonTypes).includes(data.pon_type)) {
    return false;
  }
  
  // Validasi pon_port
  if (data.pon_port) {
    if (!Array.isArray(data.pon_port)) {
      return false;
    }
    
    const existingPorts = [];
    for (const port of data.pon_port) {
      if (!validatePonPortEntity(port, existingPorts)) {
        return false;
      }
      existingPorts.push(port);
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceOltEntity,
  validateNetDeviceOltEntity,
  PonTypes,
  createPonPortEntity,
  validatePonPortEntity
};
###
cat src/entities/netDeviceOnt.entity.js
/**
 * Entity untuk netDeviceOnt (perangkat Optical Network Terminal)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Fungsi untuk membuat objek netDeviceOnt
 * @param {Object} data - Data ONT
 * @returns {Object} - Objek netDeviceOnt
 */
function createNetDeviceOntEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'ont'
  });
  
  // Tambahkan properti khusus ONT
  return {
    ...baseEntity,
    vendor: data.vendor || '',
    model: data.model || '',
    sn: data.sn || ''
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOnt
 * @param {Object} data - Data ONT
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOntEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'ont'})) {
    return false;
  }
  
  // Validasi properti vendor
  if (typeof data.vendor !== 'string') {
    return false;
  }
  
  // Validasi properti model
  if (typeof data.model !== 'string') {
    return false;
  }
  
  // Validasi properti serial number
  if (typeof data.sn !== 'string') {
    return false;
  }
  
  return true;
}

module.exports = {
  createNetDeviceOntEntity,
  validateNetDeviceOntEntity
};
###
cat src/entities/netDeviceRouter.entity.js
/**
 * Entity untuk netDeviceRouter (perangkat router)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Enum untuk tipe koneksi router
 * @enum {string}
 */
const ConnectionTypes = {
  OPENVPN: 'OPENVPN',
  PUBLIC: 'PUBLIC',
  ZEROTIER: 'ZEROTIER'
};

/**
 * Fungsi untuk validasi alamat IP v4
 * @param {string} ip - Alamat IP yang akan divalidasi
 * @returns {boolean} - True jika valid
 */
function isValidIPv4(ip) {
  if (typeof ip !== 'string') return false;
  
  // Pola IPv4: xxx.xxx.xxx.xxx
  const pattern = /^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  return pattern.test(ip);
}

/**
 * Fungsi untuk memeriksa tipe anak yang valid
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidChild(child) {
  // Hanya menerima netDeviceOlt
  const validTypes = ['olt'];
  return child && child.type && validTypes.includes(child.type);
}

/**
 * Fungsi untuk membuat objek netDeviceRouter
 * @param {Object} data - Data router
 * @returns {Object} - Objek netDeviceRouter
 */
function createNetDeviceRouterEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'router'
  });
  
  // Tambahkan properti khusus router
  return {
    ...baseEntity,
    connection_type: data.connection_type || ConnectionTypes.PUBLIC,
    ip_addr: data.ip_addr || '',
    // Children hanya bisa berisi OLT
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceRouter
 * @param {Object} data - Data router
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceRouterEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'router'})) {
    return false;
  }
  
  // Validasi connection_type
  if (data.connection_type && !Object.values(ConnectionTypes).includes(data.connection_type)) {
    return false;
  }
  
  // Validasi ip_addr
  if (data.ip_addr && !isValidIPv4(data.ip_addr)) {
    return false;
  }
  
  // Validasi children
  if (data.children) {
    if (!Array.isArray(data.children)) {
      return false;
    }
    
    // Validasi setiap anak, pastikan tipenya valid
    for (const child of data.children) {
      if (!isValidChild(child)) {
        return false;
      }
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceRouterEntity,
  validateNetDeviceRouterEntity,
  ConnectionTypes,
  isValidChild
};
###
cat src/services/address.entity.js
###
cat src/services/branch.entity.js
###
cat src/services/branchAccess.entity.js
###
cat src/services/contact.entity.js
###
cat src/services/location.entity.js
###
cat src/services/log.entity.js
###
cat src/services/netDevice.entity.js
###
cat src/services/netDeviceConn.entity.js
###
cat src/services/netDeviceOdc.entity.js
###
cat src/services/netDeviceOdp.entity.js
###
cat src/services/netDeviceOlt.entity.js
###
cat src/services/netDeviceOnt.entity.js
###
cat src/services/netDeviceRouter.entity.js
###
cat src/utils/errorHandler.js
###
cat src/utils/jwksHelper.js
###
cat src/utils/recursiveDeletedCheck.util.js
/**
 * Utility untuk melakukan pemeriksaan deleted_at secara recursive
 */

const DeletedFilterTypes = {
  ONLY: 'ONLY',    // Hanya data yang dihapus (memiliki deleted_at)
  WITH: 'WITH',    // Semua data, termasuk yang dihapus
  WITHOUT: 'WITHOUT' // Hanya data yang tidak dihapus (default)
};

/**
 * Memeriksa apakah sebuah object memenuhi kriteria filter deleted
 * @param {Object} obj - Object yang akan diperiksa
 * @param {string} deletedFilter - Tipe filter yang digunakan (ONLY, WITH, WITHOUT)
 * @returns {boolean} - True jika object memenuhi kriteria
 */
function isMatchingDeletedFilter(obj, deletedFilter) {
  if (deletedFilter === DeletedFilterTypes.WITH) return true;
  if (deletedFilter === DeletedFilterTypes.ONLY) return obj.deleted_at !== undefined;
  if (deletedFilter === DeletedFilterTypes.WITHOUT) return obj.deleted_at === undefined;
  return false;
}

/**
 * Memeriksa dan memfilter children dari pon_port OLT
 * @param {Array} ponPorts - Array port dari OLT
 * @param {string} deletedFilter - Tipe filter yang digunakan
 * @param {string} scopeLevel - Level scope data yang akan dikembalikan
 * @returns {Array} - Array port yang sudah difilter
 */
function checkPonPorts(ponPorts, deletedFilter, scopeLevel) {
  if (!ponPorts || !Array.isArray(ponPorts)) return [];
  
  return ponPorts
    .map(port => {
      const portCopy = { ...port };
      
      if (portCopy.children && Array.isArray(portCopy.children)) {
        // Filter ODC di children
        portCopy.children = portCopy.children
          .filter(odc => isMatchingDeletedFilter(odc, deletedFilter))
          .map(odc => {
            const odcCopy = { ...odc };
            
            if (odcCopy.trays && Array.isArray(odcCopy.trays)) {
              // Filter ODP di trays
              odcCopy.trays = odcCopy.trays
                .map(tray => {
                  const trayCopy = { ...tray };
                  
                  // Jika scopeLevel adalah ODCS, hapus children dari tray (yang berisi ODP)
                  if (scopeLevel === 'ODCS') {
                    delete trayCopy.children;
                    return trayCopy;
                  }
                  
                  if (trayCopy.children && Array.isArray(trayCopy.children)) {
                    // Filter ODP
                    trayCopy.children = trayCopy.children
                      .filter(odp => isMatchingDeletedFilter(odp, deletedFilter))
                      .map(odp => {
                        const odpCopy = { ...odp };
                        
                        // Jika scopeLevel adalah ODPS, hapus children (ONT)
                        if (scopeLevel === 'ODPS') {
                          delete odpCopy.children;
                          return odpCopy;
                        }
                        
                        if (odpCopy.children && Array.isArray(odpCopy.children)) {
                          // Filter ONT
                          odpCopy.children = odpCopy.children
                            .filter(ont => isMatchingDeletedFilter(ont, deletedFilter));
                        }
                        
                        return odpCopy;
                      });
                  }
                  
                  return trayCopy;
                });
            }
            
            return odcCopy;
          });
      }
      
      return portCopy;
    });
}

/**
 * Melakukan pemeriksaan deleted_at secara recursive pada branch dan children-nya
 * @param {Object} branch - Data branch yang akan diperiksa
 * @param {string} deletedFilter - Tipe filter yang digunakan (ONLY, WITH, WITHOUT)
 * @param {string} scopeLevel - Level scope data yang akan dikembalikan
 * @returns {Object|null} - Branch yang sudah difilter atau null jika tidak memenuhi kriteria
 */
function recursiveDeletedCheck(branch, deletedFilter = DeletedFilterTypes.WITHOUT, scopeLevel = null) {
  // Periksa apakah branch memenuhi kriteria filter
  if (!isMatchingDeletedFilter(branch, deletedFilter)) {
    return null;
  }
  
  const branchCopy = { ...branch };
  
  // Jika tidak ada children atau scopeLevel adalah BRANCHES, return early
  if (!branchCopy.children || !Array.isArray(branchCopy.children) || scopeLevel === 'BRANCHES') {
    delete branchCopy.children;
    return branchCopy;
  }
  
  // Filter dan map router
  branchCopy.children = branchCopy.children
    .filter(router => isMatchingDeletedFilter(router, deletedFilter))
    .map(router => {
      const routerCopy = { ...router };
      
      // Jika scopeLevel adalah ROUTERS, hapus children router
      if (scopeLevel === 'ROUTERS') {
        delete routerCopy.children;
        return routerCopy;
      }
      
      if (routerCopy.children && Array.isArray(routerCopy.children)) {
        // Filter dan map OLT
        routerCopy.children = routerCopy.children
          .filter(olt => isMatchingDeletedFilter(olt, deletedFilter))
          .map(olt => {
            const oltCopy = { ...olt };
            
            // Jika scopeLevel adalah OLTS, hapus children dari pon_port
            if (scopeLevel === 'OLTS') {
              if (oltCopy.pon_port && Array.isArray(oltCopy.pon_port)) {
                oltCopy.pon_port = oltCopy.pon_port.map(port => {
                  const portCopy = { ...port };
                  delete portCopy.children;
                  return portCopy;
                });
              }
              return oltCopy;
            }
            
            // Proses pon_port dan children-nya (ODC, ODP, ONT)
            if (oltCopy.pon_port && Array.isArray(oltCopy.pon_port)) {
              oltCopy.pon_port = checkPonPorts(oltCopy.pon_port, deletedFilter, scopeLevel);
            }
            
            return oltCopy;
          });
      }
      
      return routerCopy;
    });
  
  return branchCopy;
}

module.exports = {
  recursiveDeletedCheck,
  DeletedFilterTypes
}; ###
cat src/utils/recursiveRestore.util.js
/**
 * Utilitas untuk melakukan restore secara rekursif pada perangkat jaringan
 */

const { getCollection } = require('../repositories/database.connector');
const { ObjectId } = require('mongoose').Types;

/**
 * Helper untuk melakukan restore pada device dan children-nya
 * @param {Object} query - Query untuk mencari device
 * @param {Object} device - Device yang akan di-restore
 * @param {string} devicePath - Path ke device dalam struktur data
 * @param {Date} deletedAt - Timestamp deleted_at yang akan di-restore
 * @returns {Promise<Object>} - Hasil restore
 */
async function restoreDeviceAndChildren(query, device, devicePath, deletedAt) {
  const collection = getCollection('branches');
  
  // Restore device itu sendiri
  const restoreResult = await collection.updateOne(
    {
      ...query,
      [`${devicePath}.deleted_at`]: deletedAt // Hanya restore jika deleted_at sama
    },
    {
      $unset: {
        [`${devicePath}.deleted_at`]: ""
      },
      $set: {
        updatedAt: new Date()
      }
    }
  );
  
  return restoreResult;
}

/**
 * Melakukan restore pada ONT
 * @param {string} ontId - ID ONT yang akan di-restore
 * @returns {Promise<Object>} - Hasil restore
 */
async function restoreOnt(ontId) {
  try {
    const collection = getCollection('branches');
    
    // Cari ONT dan dapatkan timestamp deleted_at nya
    const branch = await collection.findOne({
      'children.children.pon_port.children.trays.children.children.children._id': new ObjectId(ontId)
    });
    
    if (!branch) return null;
    
    // Cari ONT dalam struktur nested
    let foundOnt = null;
    const searchOnt = (obj) => {
      if (obj._id && obj._id.toString() === ontId.toString()) {
        foundOnt = obj;
        return;
      }
      if (obj.children && Array.isArray(obj.children)) {
        obj.children.forEach(searchOnt);
      }
      if (obj.pon_port && Array.isArray(obj.pon_port)) {
        obj.pon_port.forEach(port => {
          if (port.children) port.children.forEach(searchOnt);
        });
      }
      if (obj.trays && Array.isArray(obj.trays)) {
        obj.trays.forEach(tray => {
          if (tray.children) tray.children.forEach(searchOnt);
        });
      }
    };
    
    searchOnt(branch);
    
    if (!foundOnt || !foundOnt.deleted_at) return null;
    
    const deletedAt = foundOnt.deleted_at;
    
    // Restore ONT
    const result = await collection.updateOne(
      {
        'children.children.pon_port.children.trays.children.children.children._id': new ObjectId(ontId),
        'children.children.pon_port.children.trays.children.children.children.deleted_at': deletedAt
      },
      {
        $unset: {
          'children.$[].children.$[].pon_port.$[].children.$[].trays.$[].children.$[].children.$[ont].deleted_at': ""
        },
        $set: {
          updatedAt: new Date()
        }
      },
      {
        arrayFilters: [
          { 'ont._id': new ObjectId(ontId) }
        ]
      }
    );
    
    return result;
  } catch (error) {
    console.error('Error restoring ONT:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada ODP dan children-nya
 * @param {string} odpId - ID ODP yang akan di-restore
 * @returns {Promise<Object>} - Hasil restore
 */
async function restoreOdp(odpId) {
  try {
    console.log(`[recursiveRestore.restoreOdp] Mencoba restore ODP dengan ID: ${odpId}`);
    const collection = getCollection('branches');
    
    // Cari ODP dan dapatkan timestamp deleted_at nya
    const branch = await collection.findOne({
      'children.children.pon_port.children.trays.children._id': new ObjectId(odpId)
    });
    
    console.log(`[recursiveRestore.restoreOdp] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;
    
    // Cari ODP dalam struktur nested
    let foundOdp = null;
    let odpPath = '';
    const searchOdp = (obj, path = '') => {
      if (obj._id && obj._id.toString() === odpId.toString()) {
        console.log('[recursiveRestore.restoreOdp] ODP ditemukan dalam struktur');
        foundOdp = obj;
        odpPath = path;
        return;
      }
      if (obj.children && Array.isArray(obj.children)) {
        obj.children.forEach((child, idx) => searchOdp(child, path ? `${path}.children.${idx}` : `children.${idx}`));
      }
      if (obj.pon_port && Array.isArray(obj.pon_port)) {
        obj.pon_port.forEach((port, idx) => {
          if (port.children) {
            port.children.forEach((child, childIdx) => 
              searchOdp(child, path ? `${path}.pon_port.${idx}.children.${childIdx}` : `pon_port.${idx}.children.${childIdx}`));
          }
        });
      }
      if (obj.trays && Array.isArray(obj.trays)) {
        obj.trays.forEach((tray, idx) => {
          if (tray.children) {
            tray.children.forEach((child, childIdx) => 
              searchOdp(child, path ? `${path}.trays.${idx}.children.${childIdx}` : `trays.${idx}.children.${childIdx}`));
          }
        });
      }
    };
    
    searchOdp(branch);
    
    console.log(`[recursiveRestore.restoreOdp] Status ODP:`, {
      found: !!foundOdp,
      hasDeletedAt: foundOdp ? !!foundOdp.deleted_at : false,
      path: odpPath
    });
    
    if (!foundOdp || !foundOdp.deleted_at) return null;
    
    const deletedAt = foundOdp.deleted_at;
    
    // 1. Restore ODP
    console.log('[recursiveRestore.restoreOdp] Mencoba update ODP di database');
    const odpResult = await collection.updateOne(
      {
        _id: branch._id,
        [`${odpPath}.deleted_at`]: deletedAt // Pastikan kita update ODP dengan deleted_at yang tepat
      },
      {
        $unset: {
          [`${odpPath}.deleted_at`]: ""
        },
        $set: {
          updatedAt: new Date()
        }
      }
    );
    
    console.log(`[recursiveRestore.restoreOdp] Hasil update ODP:`, {
      matchedCount: odpResult.matchedCount,
      modifiedCount: odpResult.modifiedCount
    });
    
    // 2. Restore ONTs yang memiliki deleted_at yang sama persis
    if (foundOdp.children && Array.isArray(foundOdp.children)) {
      console.log('[recursiveRestore.restoreOdp] Mencoba restore ONTs');
      const ontRestorePromises = foundOdp.children
        .map((ont, idx) => {
          if (ont.deleted_at && ont.deleted_at.getTime() === deletedAt.getTime()) {
            return collection.updateOne(
              {
                _id: branch._id,
                [`${odpPath}.children.${idx}.deleted_at`]: deletedAt
              },
              {
                $unset: {
                  [`${odpPath}.children.${idx}.deleted_at`]: ""
                },
                $set: {
                  updatedAt: new Date()
                }
              }
            );
          }
          return null;
        })
        .filter(Boolean);
      
      if (ontRestorePromises.length > 0) {
        console.log(`[recursiveRestore.restoreOdp] Merestore ${ontRestorePromises.length} ONT`);
        await Promise.all(ontRestorePromises);
      }
    }
    
    return odpResult.modifiedCount > 0 ? odpResult : null;
  } catch (error) {
    console.error('Error restoring ODP:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada ODC dan children-nya
 * @param {string} odcId - ID ODC yang akan di-restore
 * @returns {Promise<Object>} - Hasil restore
 */
async function restoreOdc(odcId) {
  try {
    const collection = getCollection('branches');
    
    // Cari ODC dan dapatkan timestamp deleted_at nya
    const branch = await collection.findOne({
      'children.children.pon_port.children._id': new ObjectId(odcId)
    });
    
    if (!branch) return null;
    
    // Cari ODC dalam struktur nested
    let foundOdc = null;
    const searchOdc = (obj) => {
      if (obj._id && obj._id.toString() === odcId.toString()) {
        foundOdc = obj;
        return;
      }
      if (obj.children && Array.isArray(obj.children)) {
        obj.children.forEach(searchOdc);
      }
      if (obj.pon_port && Array.isArray(obj.pon_port)) {
        obj.pon_port.forEach(port => {
          if (port.children) port.children.forEach(searchOdc);
        });
      }
    };
    
    searchOdc(branch);
    
    if (!foundOdc || !foundOdc.deleted_at) return null;
    
    const deletedAt = foundOdc.deleted_at;
    
    // 1. Restore ODC
    const odcResult = await collection.updateOne(
      {
        'children.children.pon_port.children._id': new ObjectId(odcId),
        'children.children.pon_port.children.deleted_at': deletedAt
      },
      {
        $unset: {
          'children.$[].children.$[].pon_port.$[].children.$[odc].deleted_at': ""
        },
        $set: {
          updatedAt: new Date()
        }
      },
      {
        arrayFilters: [
          { 'odc._id': new ObjectId(odcId) }
        ]
      }
    );
    
    // 2. Restore ODPs yang memiliki deleted_at yang sama
    if (foundOdc.trays && Array.isArray(foundOdc.trays)) {
      for (const tray of foundOdc.trays) {
        if (tray.children && Array.isArray(tray.children)) {
          const odpRestorePromises = tray.children
            .filter(odp => odp.deleted_at && odp.deleted_at.getTime() === deletedAt.getTime())
            .map(odp => restoreOdp(odp._id.toString()));
          
          await Promise.all(odpRestorePromises);
        }
      }
    }
    
    return odcResult;
  } catch (error) {
    console.error('Error restoring ODC:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada OLT dan semua ODC, ODP, dan ONT di dalamnya
 * @param {string} oltId - ID OLT yang akan di-restore
 * @returns {Promise<Object>} - Hasil restore
 */
async function restoreOlt(oltId) {
  try {
    console.log(`[recursiveRestore.restoreOlt] Mencoba restore OLT dengan ID: ${oltId}`);
    const collection = getCollection('branches');
    
    // Cari OLT dan dapatkan timestamp deleted_at nya
    const branch = await collection.findOne({
      'children.children._id': new ObjectId(oltId)
    });
    
    console.log(`[recursiveRestore.restoreOlt] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;
    
    // Cari OLT dalam struktur nested
    let foundOlt = null;
    let oltPath = '';
    const searchOlt = (obj, path = '') => {
      if (obj._id && obj._id.toString() === oltId.toString()) {
        console.log('[recursiveRestore.restoreOlt] OLT ditemukan dalam struktur');
        foundOlt = obj;
        oltPath = path;
        return;
      }
      if (obj.children && Array.isArray(obj.children)) {
        obj.children.forEach((child, idx) => searchOlt(child, path ? `${path}.children.${idx}` : `children.${idx}`));
      }
    };
    
    searchOlt(branch);
    
    console.log(`[recursiveRestore.restoreOlt] Status OLT:`, {
      found: !!foundOlt,
      hasDeletedAt: foundOlt ? !!foundOlt.deleted_at : false,
      path: oltPath
    });
    
    if (!foundOlt || !foundOlt.deleted_at) return null;
    
    const deletedAt = foundOlt.deleted_at;
    
    // 1. Restore OLT
    console.log('[recursiveRestore.restoreOlt] Mencoba update OLT di database');
    const oltResult = await collection.updateOne(
      {
        _id: branch._id,
        [`${oltPath}.deleted_at`]: deletedAt // Pastikan kita update OLT dengan deleted_at yang tepat
      },
      {
        $unset: {
          [`${oltPath}.deleted_at`]: ""
        },
        $set: {
          updatedAt: new Date()
        }
      }
    );
    
    console.log(`[recursiveRestore.restoreOlt] Hasil update OLT:`, {
      matchedCount: oltResult.matchedCount,
      modifiedCount: oltResult.modifiedCount
    });
    
    // 2. Restore ODCs yang memiliki deleted_at yang sama
    if (foundOlt.pon_port && Array.isArray(foundOlt.pon_port)) {
      console.log('[recursiveRestore.restoreOlt] Mencoba restore ODCs');
      for (const [ponPortIndex, ponPort] of foundOlt.pon_port.entries()) {
        if (ponPort.children && Array.isArray(ponPort.children)) {
          const odcRestorePromises = ponPort.children
            .filter(odc => odc.deleted_at && odc.deleted_at.getTime() === deletedAt.getTime())
            .map(odc => restoreOdc(odc._id.toString()));
          
          if (odcRestorePromises.length > 0) {
            console.log(`[recursiveRestore.restoreOlt] Merestore ${odcRestorePromises.length} ODC di port ${ponPort.port}`);
            await Promise.all(odcRestorePromises);
          }
        }
      }
    }
    
    return oltResult.modifiedCount > 0 ? oltResult : null;
  } catch (error) {
    console.error('Error restoring OLT:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada Router dan semua OLT, ODC, ODP, serta ONT di dalamnya
 * @param {string} routerId - ID Router yang akan di-restore
 * @returns {Promise<Object|null>} - Router yang sudah di-restore atau null jika gagal
 */
async function restoreRouter(routerId) {
  try {
    console.log(`[restoreRouter] Mencoba restore Router dengan ID: ${routerId}`);
    const collection = getCollection('branches');
    
    // Cari branch yang memiliki Router dengan ID yang sesuai
    const branch = await collection.findOne({
      'children._id': new ObjectId(routerId)
    });
    
    if (!branch) {
      console.log('[restoreRouter] Branch tidak ditemukan');
      return null;
    }
    
    // Cari Router dan dapatkan informasi lengkapnya
    let routerIndex = -1;
    let routerData = null;
    let routerDeletedAt = null;
    
    for (let i = 0; i < branch.children.length; i++) {
      const router = branch.children[i];
      if (router._id.toString() === routerId.toString()) {
        routerIndex = i;
        routerData = router;
        routerDeletedAt = router.deleted_at;
        break;
      }
    }
    
    if (!routerData || !routerDeletedAt) {
      console.log('[restoreRouter] Router tidak ditemukan atau tidak memiliki deleted_at');
      return null;
    }
    
    console.log(`[restoreRouter] Router ditemukan dengan deleted_at: ${routerDeletedAt}`);
    
    // Restore Router dengan menghapus deleted_at
    const routerResult = await restoreDeviceAndChildren(
      { _id: branch._id },
      'router',
      `children.${routerIndex}`,
      routerDeletedAt
    );
    
    if (!routerResult) {
      console.log('[restoreRouter] Gagal melakukan restore Router');
      return null;
    }
    
    // Restore semua OLT yang memiliki deleted_at yang sama
    if (routerData.children && Array.isArray(routerData.children)) {
      for (let oltIndex = 0; oltIndex < routerData.children.length; oltIndex++) {
        const olt = routerData.children[oltIndex];
        
        // Hanya restore OLT yang memiliki deleted_at yang sama dengan Router
        if (olt.deleted_at && olt.deleted_at.getTime() === routerDeletedAt.getTime()) {
          console.log(`[restoreRouter] Mencoba restore OLT di index ${oltIndex}`);
          
          // Restore OLT dan semua device di bawahnya
          await restoreDeviceAndChildren(
            { _id: branch._id },
            'olt',
            `children.${routerIndex}.children.${oltIndex}`,
            routerDeletedAt
          );
          
          // Restore ODCs
          if (olt.pon_port && Array.isArray(olt.pon_port)) {
            for (let ponPortIndex = 0; ponPortIndex < olt.pon_port.length; ponPortIndex++) {
              const ponPort = olt.pon_port[ponPortIndex];
              if (ponPort.children && Array.isArray(ponPort.children)) {
                for (let odcIndex = 0; odcIndex < ponPort.children.length; odcIndex++) {
                  const odc = ponPort.children[odcIndex];
                  
                  // Hanya restore ODC yang memiliki deleted_at yang sama
                  if (odc.deleted_at && odc.deleted_at.getTime() === routerDeletedAt.getTime()) {
                    console.log(`[restoreRouter] Mencoba restore ODC di port ${ponPortIndex}, index ${odcIndex}`);
                    
                    await restoreDeviceAndChildren(
                      { _id: branch._id },
                      'odc',
                      `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}`,
                      routerDeletedAt
                    );
                    
                    // Restore ODPs
                    if (odc.trays && Array.isArray(odc.trays)) {
                      for (let trayIndex = 0; trayIndex < odc.trays.length; trayIndex++) {
                        const tray = odc.trays[trayIndex];
                        if (tray.children && Array.isArray(tray.children)) {
                          for (let odpIndex = 0; odpIndex < tray.children.length; odpIndex++) {
                            const odp = tray.children[odpIndex];
                            
                            // Hanya restore ODP yang memiliki deleted_at yang sama
                            if (odp.deleted_at && odp.deleted_at.getTime() === routerDeletedAt.getTime()) {
                              console.log(`[restoreRouter] Mencoba restore ODP di tray ${trayIndex}, index ${odpIndex}`);
                              
                              await restoreDeviceAndChildren(
                                { _id: branch._id },
                                'odp',
                                `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children.${odpIndex}`,
                                routerDeletedAt
                              );
                              
                              // Restore ONTs
                              if (odp.children && Array.isArray(odp.children)) {
                                for (let ontIndex = 0; ontIndex < odp.children.length; ontIndex++) {
                                  const ont = odp.children[ontIndex];
                                  
                                  // Hanya restore ONT yang memiliki deleted_at yang sama
                                  if (ont.deleted_at && ont.deleted_at.getTime() === routerDeletedAt.getTime()) {
                                    console.log(`[restoreRouter] Mencoba restore ONT di index ${ontIndex}`);
                                    
                                    await restoreDeviceAndChildren(
                                      { _id: branch._id },
                                      'ont',
                                      `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children.${odpIndex}.children.${ontIndex}`,
                                      routerDeletedAt
                                    );
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    
    console.log('[restoreRouter] Router dan semua device di bawahnya berhasil di-restore');
    return true;
  } catch (error) {
    console.error('Error in restoreRouter:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada branch dan semua device di dalamnya
 * @param {string} branchId - ID branch yang akan di-restore
 * @returns {Promise<Object|null>} - Branch yang sudah di-restore atau null jika gagal
 */
async function restoreBranch(branchId) {
  try {
    console.log(`[restoreBranch] Mencoba restore branch dengan ID: ${branchId}`);
    const collection = getCollection('branches');

    // Cari branch yang memiliki deleted_at
    const branch = await collection.findOne({ 
      _id: new ObjectId(branchId),
      deleted_at: { $exists: true }
    });

    if (!branch) {
      console.log('[restoreBranch] Branch tidak ditemukan atau sudah di-restore');
      return null;
    }

    // Simpan timestamp deleted_at untuk digunakan dalam restore device
    const deletedAt = branch.deleted_at;
    console.log(`[restoreBranch] Timestamp deleted_at branch: ${deletedAt}`);

    // Restore branch dengan menghapus field deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(branchId) },
      {
        $unset: { deleted_at: "" },
        $set: { updatedAt: new Date() }
      }
    );

    if (result.modifiedCount === 0) {
      console.log('[restoreBranch] Gagal melakukan restore branch');
      return null;
    }

    // Restore semua router yang memiliki deleted_at yang sama
    if (branch.children && Array.isArray(branch.children)) {
      for (let routerIndex = 0; routerIndex < branch.children.length; routerIndex++) {
        const router = branch.children[routerIndex];
        if (router.deleted_at && router.deleted_at.getTime() === deletedAt.getTime()) {
          const routerId = router._id.toString();
          console.log(`[restoreBranch] Mencoba restore router dengan ID: ${routerId}`);
          
          await restoreRouter(routerId);
        }
      }
    }

    // Ambil data branch yang sudah di-restore
    const restoredBranch = await collection.findOne({ _id: new ObjectId(branchId) });
    console.log('[restoreBranch] Branch dan semua device berhasil di-restore');
    
    return restoredBranch;
  } catch (error) {
    console.error('Error restoring branch:', error);
    throw error;
  }
}

module.exports = {
  restoreDeviceAndChildren,
  restoreOnt,
  restoreOdp,
  restoreOdc,
  restoreOlt,
  restoreRouter,
  restoreBranch
}; ###
cat src/utils/recursiveSoftDelete.util.js
/**
 * Utilitas untuk melakukan soft delete secara rekursif pada perangkat jaringan
 */

const { getCollection } = require('../repositories/database.connector');
const { ObjectId } = require('mongoose').Types;

/**
 * Helper untuk membuat path update berdasarkan indeks dalam nested document
 * @param {string} device - Jenis perangkat (router, olt, odc, odp, ont)
 * @param {Object} indexes - Indeks untuk setiap level hierarki
 * @returns {string} - Path update untuk MongoDB
 */
function buildDevicePath(device, indexes) {
  const { routerIndex, oltIndex, ponPortIndex, odcIndex, trayIndex, odpIndex, ontIndex } = indexes;
  
  switch (device) {
    case 'router':
      return `children.${routerIndex}`;
    case 'olt':
      return `children.${routerIndex}.children.${oltIndex}`;
    case 'odc':
      return `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}`;
    case 'odp':
      return `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children.${odpIndex}`;
    case 'ont':
      return `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children.${odpIndex}.children.${ontIndex}`;
    default:
      throw new Error(`Jenis perangkat tidak didukung: ${device}`);
  }
}

/**
 * Melakukan soft delete pada ONT
 * @param {Object} ontData - Data ONT yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteOnt(ontData, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteOnt] Mencoba soft delete ONT di branch ${ontData.branchId}`);
    const collection = getCollection('branches');
    
    // Update ONT dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(ontData.branchId) },
      {
        $set: {
          [`children.${ontData.routerIndex}.children.${ontData.oltIndex}.pon_port.${ontData.ponPortIndex}.children.${ontData.odcIndex}.trays.${ontData.trayIndex}.children.${ontData.odpIndex}.children.${ontData.ontIndex}.deleted_at`]: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteOnt] ONT tidak ditemukan');
      return false;
    }

    console.log('[softDeleteOnt] ONT berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting ONT:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada ODP dan semua ONT di dalamnya
 * @param {Object} odpInfo - Informasi ODP yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteOdp(odpInfo, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteOdp] Mencoba soft delete ODP di branch ${odpInfo.branchId}`);
    const collection = getCollection('branches');
    
    // Update ODP dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(odpInfo.branchId) },
      {
        $set: {
          [`children.${odpInfo.routerIndex}.children.${odpInfo.oltIndex}.pon_port.${odpInfo.ponPortIndex}.children.${odpInfo.odcIndex}.trays.${odpInfo.trayIndex}.children.${odpInfo.odpIndex}.deleted_at`]: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteOdp] ODP tidak ditemukan');
      return false;
    }

    // Dapatkan data ODP untuk proses ONT
    const branch = await collection.findOne({ _id: new ObjectId(odpInfo.branchId) });
    if (!branch) {
      console.log('[softDeleteOdp] Branch tidak ditemukan');
      return false;
    }

    const odp = branch.children[odpInfo.routerIndex]?.children[odpInfo.oltIndex]?.pon_port[odpInfo.ponPortIndex]?.children[odpInfo.odcIndex]?.trays[odpInfo.trayIndex]?.children[odpInfo.odpIndex];
    if (!odp) {
      console.log('[softDeleteOdp] ODP tidak ditemukan di struktur');
      return false;
    }

    // Proses soft delete untuk setiap ONT yang belum dihapus
    if (odp.children && Array.isArray(odp.children)) {
      for (let ontIndex = 0; ontIndex < odp.children.length; ontIndex++) {
        const ont = odp.children[ontIndex];
        // Hanya proses ONT yang belum memiliki deleted_at
        if (!ont.deleted_at) {
          const ontResult = await softDeleteOnt({
            branchId: odpInfo.branchId,
            routerIndex: odpInfo.routerIndex,
            oltIndex: odpInfo.oltIndex,
            ponPortIndex: odpInfo.ponPortIndex,
            odcIndex: odpInfo.odcIndex,
            trayIndex: odpInfo.trayIndex,
            odpIndex: odpInfo.odpIndex,
            ontIndex
          }, deletedAt); // Gunakan timestamp yang sama

          if (!ontResult) {
            console.log(`[softDeleteOdp] Gagal melakukan soft delete pada ONT di index ${ontIndex}`);
            // Lanjutkan ke ONT berikutnya
            continue;
          }
        }
      }
    }

    console.log('[softDeleteOdp] ODP dan semua ONT berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting ODP:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada ODC dan semua ODP serta ONT di dalamnya
 * @param {Object} odcInfo - Informasi ODC yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteOdc(odcInfo, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteOdc] Mencoba soft delete ODC di branch ${odcInfo.branchId}`);
    const collection = getCollection('branches');
    
    // Update ODC dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(odcInfo.branchId) },
      {
        $set: {
          [`children.${odcInfo.routerIndex}.children.${odcInfo.oltIndex}.pon_port.${odcInfo.ponPortIndex}.children.${odcInfo.odcIndex}.deleted_at`]: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteOdc] ODC tidak ditemukan');
      return false;
    }

    // Dapatkan data ODC untuk proses ODP
    const branch = await collection.findOne({ _id: new ObjectId(odcInfo.branchId) });
    if (!branch) {
      console.log('[softDeleteOdc] Branch tidak ditemukan');
      return false;
    }

    const odc = branch.children[odcInfo.routerIndex]?.children[odcInfo.oltIndex]?.pon_port[odcInfo.ponPortIndex]?.children[odcInfo.odcIndex];
    if (!odc) {
      console.log('[softDeleteOdc] ODC tidak ditemukan di struktur');
      return false;
    }

    // Proses soft delete untuk setiap ODP di setiap tray yang belum dihapus
    if (odc.trays && Array.isArray(odc.trays)) {
      for (let trayIndex = 0; trayIndex < odc.trays.length; trayIndex++) {
        const tray = odc.trays[trayIndex];
        if (tray.children && Array.isArray(tray.children)) {
          for (let odpIndex = 0; odpIndex < tray.children.length; odpIndex++) {
            const odp = tray.children[odpIndex];
            // Hanya proses ODP yang belum memiliki deleted_at
            if (!odp.deleted_at) {
              const odpResult = await softDeleteOdp({
                branchId: odcInfo.branchId,
                routerIndex: odcInfo.routerIndex,
                oltIndex: odcInfo.oltIndex,
                ponPortIndex: odcInfo.ponPortIndex,
                odcIndex: odcInfo.odcIndex,
                trayIndex,
                odpIndex
              }, deletedAt); // Gunakan timestamp yang sama

              if (!odpResult) {
                console.log(`[softDeleteOdc] Gagal melakukan soft delete pada ODP di tray ${trayIndex}`);
                // Lanjutkan ke ODP berikutnya
                continue;
              }
            }
          }
        }
      }
    }

    console.log('[softDeleteOdc] ODC dan semua device di bawahnya berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting ODC:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada OLT dan semua ODC, ODP, serta ONT di dalamnya
 * @param {Object} oltInfo - Informasi OLT yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteOlt(oltInfo, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteOlt] Mencoba soft delete OLT di branch ${oltInfo.branchId}`);
    const collection = getCollection('branches');
    
    // Update OLT dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(oltInfo.branchId) },
      {
        $set: {
          [`children.${oltInfo.routerIndex}.children.${oltInfo.oltIndex}.deleted_at`]: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteOlt] OLT tidak ditemukan');
      return false;
    }

    // Dapatkan data OLT untuk proses ODC
    const branch = await collection.findOne({ _id: new ObjectId(oltInfo.branchId) });
    if (!branch) {
      console.log('[softDeleteOlt] Branch tidak ditemukan');
      return false;
    }

    const olt = branch.children[oltInfo.routerIndex]?.children[oltInfo.oltIndex];
    if (!olt) {
      console.log('[softDeleteOlt] OLT tidak ditemukan di struktur');
      return false;
    }

    // Proses soft delete untuk setiap ODC di setiap PON port yang belum dihapus
    if (olt.pon_port && Array.isArray(olt.pon_port)) {
      for (let ponPortIndex = 0; ponPortIndex < olt.pon_port.length; ponPortIndex++) {
        const ponPort = olt.pon_port[ponPortIndex];
        if (ponPort.children && Array.isArray(ponPort.children)) {
          for (let odcIndex = 0; odcIndex < ponPort.children.length; odcIndex++) {
            const odc = ponPort.children[odcIndex];
            // Hanya proses ODC yang belum memiliki deleted_at
            if (!odc.deleted_at) {
              const odcResult = await softDeleteOdc({
                branchId: oltInfo.branchId,
                routerIndex: oltInfo.routerIndex,
                oltIndex: oltInfo.oltIndex,
                ponPortIndex,
                odcIndex
              }, deletedAt); // Gunakan timestamp yang sama

              if (!odcResult) {
                console.log(`[softDeleteOlt] Gagal melakukan soft delete pada ODC di port ${ponPortIndex}`);
                // Lanjutkan ke ODC berikutnya
                continue;
              }
            }
          }
        }
      }
    }

    console.log('[softDeleteOlt] OLT dan semua device di bawahnya berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting OLT:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada Router dan semua OLT, ODC, ODP, serta ONT di dalamnya
 * @param {Object} routerData - Data Router yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteRouter(routerData, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteRouter] Mencoba soft delete Router di branch ${routerData.branchId}`);
    const collection = getCollection('branches');
    
    // Update Router dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(routerData.branchId) },
      {
        $set: {
          [`children.${routerData.routerIndex}.deleted_at`]: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteRouter] Router tidak ditemukan');
      return false;
    }

    // Dapatkan data Router untuk proses OLT
    const branch = await collection.findOne({ _id: new ObjectId(routerData.branchId) });
    if (!branch) {
      console.log('[softDeleteRouter] Branch tidak ditemukan');
      return false;
    }

    const router = branch.children[routerData.routerIndex];
    if (!router) {
      console.log('[softDeleteRouter] Router tidak ditemukan di struktur');
      return false;
    }

    // Proses soft delete untuk setiap OLT yang belum dihapus
    if (router.children && Array.isArray(router.children)) {
      for (let oltIndex = 0; oltIndex < router.children.length; oltIndex++) {
        const olt = router.children[oltIndex];
        // Hanya proses OLT yang belum memiliki deleted_at
        if (!olt.deleted_at) {
          const oltResult = await softDeleteOlt({
            branchId: routerData.branchId,
            routerIndex: routerData.routerIndex,
            oltIndex
          }, deletedAt); // Gunakan timestamp yang sama

          if (!oltResult) {
            console.log(`[softDeleteRouter] Gagal melakukan soft delete pada OLT di index ${oltIndex}`);
            // Lanjutkan ke OLT berikutnya
            continue;
          }
        }
      }
    }

    console.log('[softDeleteRouter] Router dan semua device di bawahnya berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting Router:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada branch dan semua device di dalamnya
 * @param {string} branchId - ID branch yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteBranch(branchId, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteBranch] Mencoba soft delete branch dengan ID: ${branchId}`);
    const collection = getCollection('branches');
    
    // Update branch dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { 
        _id: new ObjectId(branchId),
        deleted_at: { $exists: false } // Hanya update jika belum memiliki deleted_at
      },
      {
        $set: {
          deleted_at: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteBranch] Branch tidak ditemukan atau sudah memiliki deleted_at');
      return false;
    }

    // Dapatkan data branch untuk proses router
    const branch = await collection.findOne({ _id: new ObjectId(branchId) });
    if (!branch) {
      console.log('[softDeleteBranch] Branch tidak ditemukan setelah update');
      return false;
    }

    // Proses soft delete untuk setiap router yang belum dihapus
    if (branch.children && Array.isArray(branch.children)) {
      for (let routerIndex = 0; routerIndex < branch.children.length; routerIndex++) {
        const router = branch.children[routerIndex];
        // Hanya proses router yang belum memiliki deleted_at
        if (!router.deleted_at) {
          const routerResult = await softDeleteRouter({
            branchId: branchId,
            routerIndex
          }, deletedAt); // Gunakan timestamp yang sama

          if (!routerResult) {
            console.log(`[softDeleteBranch] Gagal melakukan soft delete pada router di index ${routerIndex}`);
            // Lanjutkan ke router berikutnya
            continue;
          }
        }
      }
    }

    console.log('[softDeleteBranch] Branch dan semua device di dalamnya berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting branch:', error);
    throw error;
  }
}

module.exports = {
  softDeleteOnt,
  softDeleteOdp,
  softDeleteOdc,
  softDeleteOlt,
  softDeleteRouter,
  softDeleteBranch
}; ###
cat src/utils/uuid.util.js
/**
 * UUID Helper
 * 
 * Modul ini menyediakan fungsi-fungsi helper untuk generate UUID
 * Secara default menggunakan UUID v7 yang memberikan keuntungan:
 * - Memiliki timestamp yang terintegrasi (time ordered)
 * - Memudahkan sorting berdasarkan waktu pembuatan
 * - Kompatibel dengan format UUID standar
 */

const { v7: uuidv7, v4: uuidv4 } = require('uuid');

/**
 * Generate UUID v7 (default)
 * UUID v7 menggabungkan timestamp dengan random bits
 * Sangat cocok untuk primary key yang perlu diurutkan berdasarkan waktu
 * 
 * @returns {string} UUID v7 string
 */
const generateUUID = () => {
  try {
    return uuidv7();
  } catch (error) {
    console.error(`Error generating UUID v7: ${error.message}`);
    // Fallback ke UUID v4 jika v7 tidak tersedia
    return uuidv4();
  }
};

/**
 * Generate UUID v4 (completely random)
 * 
 * @returns {string} UUID v4 string
 */
const generateRandomUUID = () => {
  return uuidv4();
};

/**
 * Memeriksa apakah string adalah UUID valid
 * 
 * @param {string} uuid - String yang akan diperiksa
 * @returns {boolean} true jika valid, false jika tidak
 */
const isValidUUID = (uuid) => {
  if (!uuid) return false;
  
  // Format regex untuk UUID
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-7][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
};

module.exports = {
  generateUUID,
  generateRandomUUID,
  isValidUUID
}; ###
cat src/utils/validator.js
###
cat src/controllers/branch.controller.js
/**
 * Controller untuk endpoint branch
 */

const branchRepository = require('../repositories/branch.repository');
const { validateBranchEntity } = require('../entities/branch.entity');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan semua branches
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getAllBranches(req, res) {
  try {
    const context = getRequestContext();
    logDebug('Menerima request getAllBranches', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name),
      hasAccessFilter: !!req.accessibleBranchIds
    });
    
    const { scope_level, deleted } = req.query;
    
    if (scope_level && !Object.values(branchRepository.ResultTypes).includes(scope_level)) {
      logWarn('Invalid scope_level parameter', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        invalidValue: scope_level,
        validValues: Object.values(branchRepository.ResultTypes)
      });
      return res.status(400).json(createErrorResponse(
        400,
        'Invalid scope_level type',
        { valid_values: Object.values(branchRepository.ResultTypes) }
      ));
    }
    
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }

    logDebug('Mengambil data branches', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      filters: {
        scope_level: scope_level || 'default',
        deleted: deletedFilter,
        accessibleBranchCount: req.accessibleBranchIds?.length
      }
    });
    
    // Gunakan accessible branch IDs jika ada (untuk non-Client Owner)
    const branches = await branchRepository.getAllBranches(
      scope_level, 
      deletedFilter,
      req.accessibleBranchIds // Ini akan null untuk Client Owner
    );
    
    logInfo('Berhasil mengambil data branches', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      count: branches.length,
      scope_level: scope_level || 'default',
      deleted: deletedFilter,
      filteredByAccess: !!req.accessibleBranchIds
    });
    
    res.status(200).json({
      data: branches
    });
  } catch (error) {
    logError('Error pada getAllBranches', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId()
    });
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Mendapatkan branch berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getBranchById(req, res) {
  try {
    const context = getRequestContext();
    const { id } = req.params;
    
    logDebug('Menerima request getBranchById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Ambil parameter scope_level dan deleted dari query
    const { scope_level, deleted } = req.query;
    
    // Validasi parameter scope_level jika ada
    if (scope_level && !Object.values(branchRepository.ResultTypes).includes(scope_level)) {
      logWarn('Invalid scope_level parameter pada getBranchById', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id,
        invalidValue: scope_level,
        validValues: Object.values(branchRepository.ResultTypes)
      });
      
      return res.status(400).json(createErrorResponse(
        400,
        'Invalid scope_level type',
        { valid_values: Object.values(branchRepository.ResultTypes) }
      ));
    }
    
    // Tentukan filter deleted (defaultnya WITHOUT)
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }
    
    logDebug('Mengambil data branch by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      filters: {
        scope_level: scope_level || 'default',
        deleted: deletedFilter
      }
    });
    
    const branch = await branchRepository.getBranchById(id, scope_level, deletedFilter);
    
    if (!branch) {
      logWarn('Branch tidak ditemukan', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id,
        filters: {
          scope_level: scope_level || 'default',
          deleted: deletedFilter
        }
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Branch not found'
      ));
    }
    
    logInfo('Berhasil mengambil data branch by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      scope_level: scope_level || 'default',
      deleted: deletedFilter
    });
    
    res.status(200).json({
      data: branch
    });
  } catch (error) {
    logError('Error pada getBranchById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      branchId: req.params.id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Membuat branch baru
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function createBranch(req, res) {
  try {
    const context = getRequestContext();
    
    logDebug('Menerima request createBranch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Validasi telah dilakukan di middleware validation
    logDebug('Membuat branch baru', {
      requestId: context.getRequestId(),
      userId: context.getUserId()
    });
    
    const branch = await branchRepository.createBranch(req.body);
    
    logInfo('Branch berhasil dibuat', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: branch._id,
      branchName: branch.name
    });
    
    res.status(200).json({
      message: 'Branch created successfully',
      data: branch
    });
  } catch (error) {
    logError('Error pada createBranch', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      requestBody: req.body
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Mengupdate branch berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function updateBranch(req, res) {
  try {
    const context = getRequestContext();
    const { id } = req.params;
    
    logDebug('Menerima request updateBranch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    logDebug('Mengupdate branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id
    });
    
    const branch = await branchRepository.updateBranch(id, req.body);
    
    if (!branch) {
      logWarn('Branch tidak ditemukan untuk update', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Branch not found'
      ));
    }
    
    logInfo('Branch berhasil diupdate', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      branchName: branch.name
    });
    
    res.status(200).json({
      data: branch
    });
  } catch (error) {
    logError('Error pada updateBranch', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      branchId: req.params.id,
      requestBody: req.body
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menghapus branch berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteBranch(req, res) {
  try {
    const context = getRequestContext();
    const { id } = req.params;
    
    logDebug('Menerima request deleteBranch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah Branch ada
    logDebug('Memeriksa keberadaan branch sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id
    });
    
    const branch = await branchRepository.getBranchById(id, null, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!branch) {
      logWarn('Branch tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Branch not found or already deleted'
      ));
    }
    
    // Import soft delete function
    const { softDeleteBranch } = require('../utils/recursiveSoftDelete.util');
    
    // Lakukan soft delete rekursif pada Branch dan semua Router, OLT, ODC, ODP, serta ONT di dalamnya
    logDebug('Melakukan soft delete rekursif pada branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      branchName: branch.name
    });
    
    const result = await softDeleteBranch(branch._id);
    
    if (!result) {
      logError('Gagal melakukan soft delete pada branch', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id,
        branchName: branch.name
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        'Failed to delete Branch',
        { branchId: id }
      ));
    }
    
    // Dapatkan Branch yang sudah di-soft delete
    const deletedBranch = await branchRepository.getBranchById(id, null, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('Branch berhasil di-soft delete secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      branchName: branch.name
    });
    
    // Sukses, kembalikan status 200 dengan data Branch yang sudah di-soft delete
    res.status(200).json({
      message: 'Branch and all Routers, OLTs, ODCs, ODPs, and ONTs deleted successfully',
      data: deletedBranch
    });
  } catch (error) {
    logError('Error pada deleteBranch', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      branchId: req.params.id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada branch yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreBranch(req, res) {
  try {
    const context = getRequestContext();
    const { id } = req.params;
    
    logDebug('Menerima request restoreBranch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa status branch terlebih dahulu
    logDebug('Memeriksa keberadaan branch yang sudah dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id
    });
    
    const branch = await branchRepository.getBranchById(id, null, branchRepository.DeletedFilterTypes.ONLY);
    
    logDebug('Status pencarian branch yang dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      ditemukan: branch ? true : false
    });
    
    if (!branch) {
      logWarn('Branch tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Branch not found or already restored'
      ));
    }
    
    // Coba restore branch
    logDebug('Mencoba melakukan restore branch secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      branchName: branch.name
    });
    
    const result = await branchRepository.restore(id);
    
    logDebug('Hasil restore branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      berhasil: result ? true : false
    });
    
    if (!result) {
      logError('Gagal melakukan restore branch', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: id,
        branchName: branch.name
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Failed to restore branch'
      ));
    }
    
    // Dapatkan data branch yang sudah di-restore
    logDebug('Mengambil data branch yang sudah di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id
    });
    
    const restoredBranch = await branchRepository.getBranchById(id, null, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('Branch berhasil di-restore secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: id,
      branchName: restoredBranch.name
    });
    
    res.status(200).json({
      message: 'Branch restored successfully',
      data: restoredBranch
    });
  } catch (error) {
    logError('Error pada restoreBranch', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      branchId: req.params.id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getAllBranches,
  getBranchById,
  createBranch,
  updateBranch,
  deleteBranch,
  restoreBranch
};
###
cat src/controllers/netDevice.controller.js
###
cat src/controllers/netDeviceOdc.controller.js
/**
 * Controller untuk endpoint net device ODC
 */

const oltRepository = require('../repositories/netDeviceOlt.repository');
const odcRepository = require('../repositories/netDeviceOdc.repository');
const branchRepository = require('../repositories/branch.repository'); // Untuk DeletedFilterTypes
const { softDeleteOdc } = require('../utils/recursiveSoftDelete.util');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan ODC berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getOdcById(req, res) {
  try {
    const context = getRequestContext();
    const { odc_id } = req.params;
    
    logDebug('Menerima request getOdcById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Ambil parameter dari query
    const { deleted } = req.query;
    
    // Tentukan filter deleted (defaultnya WITHOUT)
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }
    
    logDebug('Mengambil data ODC by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      filters: {
        deleted: deletedFilter
      }
    });
    
    const odc = await odcRepository.getOdcById(odc_id, deletedFilter);
    
    if (!odc) {
      logWarn('ODC tidak ditemukan', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        filters: {
          deleted: deletedFilter
        }
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODC not found'
      ));
    }
    
    logInfo('Berhasil mengambil data ODC by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      deleted: deletedFilter
    });
    
    res.status(200).json({
      data: odc
    });
  } catch (error) {
    logError('Error pada getOdcById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odcId: req.params.odc_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menambahkan ODC ke OLT pada port tertentu
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function addOdcToOlt(req, res) {
  try {
    const context = getRequestContext();
    const { olt_id } = req.params;
    
    logDebug('Menerima request addOdcToOlt', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Periksa apakah OLT ada
    logDebug('Memeriksa keberadaan OLT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id
    });
    
    const oltInfo = await oltRepository.getOltById(olt_id);
    
    if (!oltInfo || !oltInfo.olt) {
      logWarn('OLT tidak ditemukan untuk penambahan ODC', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'OLT not found'
      ));
    }
    
    // Periksa apakah port yang dimaksud ada di OLT
    logDebug('Memeriksa keberadaan port pada OLT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      requestedPort: req.body.pon_port
    });
    
    const ponPort = oltInfo.olt.pon_port.find(port => port.port === req.body.pon_port);
    
    if (!ponPort) {
      logWarn('Port tidak ditemukan pada OLT', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        requestedPort: req.body.pon_port
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        `Port ${req.body.pon_port} not found on OLT`
      ));
    }
    
    // Tambahkan ODC ke OLT pada port tertentu
    logDebug('Menambahkan ODC ke OLT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      ponPort: req.body.pon_port,
      odcLabel: req.body.label,
      availableTray: req.body.available_tray || 0,
      coresPerTray: req.body.cores_per_tray || 0
    });
    
    const updatedOltInfo = await oltRepository.addOdcToOlt(olt_id, req.body);
    
    logInfo('ODC berhasil ditambahkan ke OLT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      oltLabel: oltInfo.olt.label || 'unknown',
      ponPort: req.body.pon_port,
      odcLabel: req.body.label
    });
    
    res.status(200).json({
      message: 'ODC added to OLT successfully',
      data: updatedOltInfo.olt
    });
  } catch (error) {
    logError('Error pada addOdcToOlt', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      oltId: req.params.olt_id,
      requestBody: req.body
    });
    
    // Handling specific errors
    if (error.message && error.message.includes('not found')) {
      return res.status(404).json(createErrorResponse(
        404,
        error.message
      ));
    }
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan soft delete pada ODC dan semua ODP serta ONT di dalamnya
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteOdc(req, res) {
  try {
    const context = getRequestContext();
    const { odc_id } = req.params;
    
    logDebug('Menerima request deleteOdc', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah ODC ada
    logDebug('Memeriksa keberadaan ODC sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id
    });
    
    const odcInfo = await odcRepository.getOdcById(odc_id, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!odcInfo || !odcInfo.odc) {
      logWarn('ODC tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODC not found or already deleted'
      ));
    }
    
    // Lakukan soft delete rekursif pada ODC dan semua ODP serta ONT di dalamnya
    try {
      logDebug('Memulai proses soft delete ODC secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        odcLabel: odcInfo.odc.label,
        branchId: odcInfo.branchId,
        routerIndex: odcInfo.routerIndex,
        oltIndex: odcInfo.oltIndex,
        ponPortIndex: odcInfo.ponPortIndex
      });
      
      const result = await softDeleteOdc({
        branchId: odcInfo.branchId,
        routerIndex: odcInfo.routerIndex,
        oltIndex: odcInfo.oltIndex,
        ponPortIndex: odcInfo.ponPortIndex,
        odcIndex: odcInfo.odcIndex
      });
      
      if (!result) {
        logError('Soft delete ODC gagal', {
          requestId: context.getRequestId(),
          userId: context.getUserId(),
          odcId: odc_id,
          odcLabel: odcInfo.odc.label,
          branchId: odcInfo.branchId
        });
        
        return res.status(500).json(createErrorResponse(
          500,
          'Failed to delete ODC',
          { odcId: odc_id }
        ));
      }
      
      logDebug('Soft delete berhasil, mengambil data ODC yang sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id
      });
      
      // Dapatkan ODC yang sudah di-soft delete
      const deletedOdc = await odcRepository.getOdcById(odc_id, branchRepository.DeletedFilterTypes.WITH);
      
      logInfo('ODC berhasil di-soft delete secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        odcLabel: odcInfo.odc.label,
        branchId: odcInfo.branchId
      });
      
      // Sukses, kembalikan status 200 dengan data ODC yang sudah di-soft delete
      res.status(200).json({
        message: 'ODC and all ODPs and ONTs deleted successfully',
        data: deletedOdc?.odc || { _id: odc_id, deleted_at: new Date() }
      });
    } catch (deleteError) {
      logError('Error saat proses delete ODC', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        error: deleteError.message,
        stack: deleteError.stack
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        `Failed to delete ODC: ${deleteError.message || 'Unknown error'}`,
        deleteError
      ));
    }
  } catch (error) {
    logError('Error pada deleteOdc controller', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odcId: req.params.odc_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada ODC yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreOdc(req, res) {
  try {
    const context = getRequestContext();
    const { odc_id } = req.params;
    
    logDebug('Menerima request restoreOdc', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa status ODC terlebih dahulu - gunakan filter ONLY untuk mencari yang sudah dihapus
    logDebug('Memeriksa keberadaan ODC yang sudah dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id
    });
    
    const odcInfo = await odcRepository.getOdcById(odc_id, branchRepository.DeletedFilterTypes.ONLY);
    
    logDebug('Status pencarian ODC yang dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      ditemukan: odcInfo ? true : false
    });
    
    if (!odcInfo || !odcInfo.odc) {
      logWarn('ODC tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODC not found or already restored'
      ));
    }
    
    // Coba restore ODC
    logDebug('Mencoba melakukan restore ODC secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      odcLabel: odcInfo.odc.label,
      branchId: odcInfo.branchId
    });
    
    const result = await odcRepository.restore(odc_id);
    
    logDebug('Hasil restore ODC', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      berhasil: result ? true : false
    });
    
    if (!result) {
      logError('Gagal melakukan restore ODC', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        odcLabel: odcInfo.odc.label
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Failed to restore ODC'
      ));
    }
    
    // Dapatkan data ODC yang sudah di-restore menggunakan filter WITH untuk memastikan kita bisa menemukannya
    logDebug('Mengambil data ODC yang sudah di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id
    });
    
    const restoredOdc = await odcRepository.getOdcById(odc_id, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('ODC berhasil di-restore secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      odcLabel: restoredOdc?.odc?.label || 'unknown',
      branchId: odcInfo.branchId
    });
    
    res.status(200).json({
      message: 'ODC restored successfully',
      data: restoredOdc
    });
  } catch (error) {
    logError('Error pada restoreOdc', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odcId: req.params.odc_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getOdcById,
  addOdcToOlt,
  deleteOdc,
  restoreOdc
}; ###
cat src/controllers/netDeviceOdp.controller.js
/**
 * Controller untuk endpoint net device ODP
 */

const odcRepository = require('../repositories/netDeviceOdc.repository');
const odpRepository = require('../repositories/netDeviceOdp.repository');
const branchRepository = require('../repositories/branch.repository'); // Untuk DeletedFilterTypes
const { softDeleteOdp } = require('../utils/recursiveSoftDelete.util');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan ODP berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getOdpById(req, res) {
  try {
    const context = getRequestContext();
    const { odp_id } = req.params;
    
    logDebug('Menerima request getOdpById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    const { deleted } = req.query;
    
    // Tentukan filter deleted (defaultnya WITHOUT)
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }
    
    logDebug('Mengambil data ODP by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      filters: {
        deleted: deletedFilter
      }
    });
    
    const odp = await odpRepository.getOdpById(odp_id, deletedFilter);
    
    if (!odp) {
      logWarn('ODP tidak ditemukan', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        filters: {
          deleted: deletedFilter
        }
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODP not found'
      ));
    }
    
    logInfo('Berhasil mengambil data ODP by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      deleted: deletedFilter
    });
    
    res.status(200).json({
      data: odp
    });
  } catch (error) {
    logError('Error pada getOdpById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odpId: req.params.odp_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menambahkan ODP ke ODC pada tray tertentu
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function addOdpToOdc(req, res) {
  try {
    const context = getRequestContext();
    const { odc_id } = req.params;
    
    logDebug('Menerima request addOdpToOdc', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Periksa apakah ODC ada
    logDebug('Memeriksa keberadaan ODC', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id
    });
    
    const odcInfo = await odcRepository.getOdcById(odc_id);
    
    if (!odcInfo || !odcInfo.odc) {
      logWarn('ODC tidak ditemukan untuk penambahan ODP', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODC not found'
      ));
    }
    
    // Periksa apakah tray yang dimaksud ada di ODC
    logDebug('Memeriksa keberadaan tray pada ODC', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      requestedTray: req.body.tray
    });
    
    const tray = odcInfo.odc.trays.find(tray => tray.tray === req.body.tray);
    
    if (!tray) {
      logWarn('Tray tidak ditemukan pada ODC', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        requestedTray: req.body.tray
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        `Tray ${req.body.tray} not found on ODC`
      ));
    }
    
    // Validasi core_on_odc_tray
    logDebug('Validasi core_on_odc_tray', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      tray: req.body.tray,
      coreOnOdcTray: req.body.core_on_odc_tray,
      validRange: `${tray.start_core}-${tray.end_core}`
    });
    
    if (req.body.core_on_odc_tray < tray.start_core || req.body.core_on_odc_tray > tray.end_core) {
      logWarn('Nilai core_on_odc_tray tidak valid', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odcId: odc_id,
        tray: req.body.tray,
        coreOnOdcTray: req.body.core_on_odc_tray,
        validRange: `${tray.start_core}-${tray.end_core}`
      });
      
      return res.status(400).json(createErrorResponse(
        400,
        `core_on_odc_tray value (${req.body.core_on_odc_tray}) out of range for tray ${req.body.tray}. Valid range: ${tray.start_core}-${tray.end_core}`
      ));
    }
    
    // Tambahkan ODP ke ODC pada tray tertentu
    logDebug('Menambahkan ODP ke ODC', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      tray: req.body.tray,
      odpLabel: req.body.label,
      coreOnOdcTray: req.body.core_on_odc_tray
    });
    
    const updatedOdcInfo = await odcRepository.addOdpToOdc(odc_id, req.body);
    
    logInfo('ODP berhasil ditambahkan ke ODC', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odcId: odc_id,
      odcLabel: odcInfo.odc.label || 'unknown',
      tray: req.body.tray,
      odpLabel: req.body.label
    });
    
    res.status(200).json({
      message: 'ODP added to ODC successfully',
      data: updatedOdcInfo.odc
    });
  } catch (error) {
    logError('Error pada addOdpToOdc', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odcId: req.params.odc_id,
      requestBody: req.body
    });
    
    // Handling specific errors
    if (error.message && (error.message.includes('not found') || error.message.includes('out of range'))) {
      return res.status(400).json(createErrorResponse(
        400,
        error.message,
        error
      ));
    }
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan soft delete pada ODP dan semua ONT di dalamnya
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteOdp(req, res) {
  try {
    const context = getRequestContext();
    const { odp_id } = req.params;
    
    logDebug('Menerima request deleteOdp', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah ODP ada
    logDebug('Memeriksa keberadaan ODP sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id
    });
    
    const odpInfo = await odpRepository.getOdpById(odp_id, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!odpInfo || !odpInfo.odp) {
      logWarn('ODP tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODP not found or already deleted'
      ));
    }
    
    // Lakukan soft delete rekursif pada ODP dan semua ONT di dalamnya
    try {
      logDebug('Memulai proses soft delete ODP secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        odpLabel: odpInfo.odp.label,
        branchId: odpInfo.branchId,
        routerIndex: odpInfo.routerIndex,
        oltIndex: odpInfo.oltIndex,
        ponPortIndex: odpInfo.ponPortIndex,
        odcIndex: odpInfo.odcIndex,
        trayIndex: odpInfo.trayIndex
      });
      
      const result = await softDeleteOdp({
        branchId: odpInfo.branchId,
        routerIndex: odpInfo.routerIndex,
        oltIndex: odpInfo.oltIndex,
        ponPortIndex: odpInfo.ponPortIndex,
        odcIndex: odpInfo.odcIndex,
        trayIndex: odpInfo.trayIndex,
        odpIndex: odpInfo.odpIndex
      });
      
      if (!result) {
        logError('Soft delete ODP gagal', {
          requestId: context.getRequestId(),
          userId: context.getUserId(),
          odpId: odp_id,
          odpLabel: odpInfo.odp.label,
          branchId: odpInfo.branchId
        });
        
        return res.status(500).json(createErrorResponse(
          500,
          'Failed to delete ODP',
          { odpId: odp_id }
        ));
      }
      
      logDebug('Soft delete berhasil, mengambil data ODP yang sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id
      });
      
      // Dapatkan ODP yang sudah di-soft delete
      const deletedOdp = await odpRepository.getOdpById(odp_id, branchRepository.DeletedFilterTypes.WITH);
      
      logInfo('ODP berhasil di-soft delete secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        odpLabel: odpInfo.odp.label,
        branchId: odpInfo.branchId
      });
      
      // Sukses, kembalikan status 200 dengan data ODP yang sudah di-soft delete
      res.status(200).json({
        message: 'ODP and all ONTs deleted successfully',
        data: deletedOdp?.odp || { _id: odp_id, deleted_at: new Date() }
      });
    } catch (deleteError) {
      logError('Error saat proses delete ODP', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        error: deleteError.message,
        stack: deleteError.stack
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        `Failed to delete ODP: ${deleteError.message || 'Unknown error'}`,
        deleteError
      ));
    }
  } catch (error) {
    logError('Error pada deleteOdp controller', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odpId: req.params.odp_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada ODP yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreOdp(req, res) {
  try {
    const context = getRequestContext();
    const { odp_id } = req.params;
    
    logDebug('Menerima request restoreOdp', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa status ODP terlebih dahulu
    logDebug('Memeriksa keberadaan ODP yang sudah dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id
    });
    
    const odpInfo = await odpRepository.getOdpById(odp_id, branchRepository.DeletedFilterTypes.ONLY);
    
    logDebug('Status pencarian ODP yang dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      ditemukan: odpInfo ? true : false
    });
    
    if (!odpInfo || !odpInfo.odp) {
      logWarn('ODP tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODP not found or already restored'
      ));
    }
    
    // Coba restore ODP
    logDebug('Mencoba melakukan restore ODP secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      odpLabel: odpInfo.odp.label,
      branchId: odpInfo.branchId
    });
    
    const result = await odpRepository.restore(odp_id);
    
    logDebug('Hasil restore ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      berhasil: result ? true : false
    });
    
    if (!result) {
      logError('Gagal melakukan restore ODP', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        odpLabel: odpInfo.odp.label
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Failed to restore ODP'
      ));
    }
    
    // Dapatkan data ODP yang sudah di-restore
    logDebug('Mengambil data ODP yang sudah di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id
    });
    
    const restoredOdp = await odpRepository.getOdpById(odp_id, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('ODP berhasil di-restore secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      odpLabel: restoredOdp?.odp?.label || 'unknown',
      branchId: odpInfo.branchId
    });
    
    res.status(200).json({
      message: 'ODP restored successfully',
      data: restoredOdp
    });
  } catch (error) {
    logError('Error pada restoreOdp', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odpId: req.params.odp_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getOdpById,
  addOdpToOdc,
  deleteOdp,
  restoreOdp
}; ###
cat src/controllers/netDeviceOlt.controller.js
/**
 * Controller untuk endpoint net device OLT
 */

const routerRepository = require('../repositories/netDeviceRouter.repository');
const oltRepository = require('../repositories/netDeviceOlt.repository');
const branchRepository = require('../repositories/branch.repository'); // Untuk DeletedFilterTypes
const { softDeleteOlt } = require('../utils/recursiveSoftDelete.util');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan OLT berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getOltById(req, res) {
  try {
    const context = getRequestContext();
    const { olt_id } = req.params;
    
    logDebug('Menerima request getOltById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Ambil parameter dari query
    const { deleted } = req.query;
    
    // Tentukan filter deleted (defaultnya WITHOUT)
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }
    
    logDebug('Mengambil data OLT by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      filters: {
        deleted: deletedFilter
      }
    });
    
    const olt = await oltRepository.getOltById(olt_id, deletedFilter);
    
    if (!olt) {
      logWarn('OLT tidak ditemukan', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        filters: {
          deleted: deletedFilter
        }
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'OLT not found'
      ));
    }
    
    logInfo('Berhasil mengambil data OLT by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      deleted: deletedFilter
    });
    
    res.status(200).json({
      data: olt
    });
  } catch (error) {
    logError('Error pada getOltById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      oltId: req.params.olt_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menambahkan OLT ke router
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function addOltToRouter(req, res) {
  try {
    const context = getRequestContext();
    const { router_id } = req.params;
    
    logDebug('Menerima request addOltToRouter', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Periksa apakah router ada
    logDebug('Memeriksa keberadaan router', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id
    });
    
    const router = await routerRepository.getRouterById(router_id);
    
    if (!router) {
      logWarn('Router tidak ditemukan untuk penambahan OLT', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Router not found'
      ));
    }
    
    // Tambahkan OLT ke router
    logDebug('Menambahkan OLT ke router', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      oltLabel: req.body.label,
      availablePorts: req.body.available_pon || 0
    });
    
    const updatedRouter = await routerRepository.addOltToRouter(router_id, req.body);
    
    logInfo('OLT berhasil ditambahkan ke router', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      routerLabel: router.router?.label || 'unknown',
      oltLabel: req.body.label
    });
    
    res.status(200).json({
      message: 'OLT added to router successfully',
      data: updatedRouter
    });
  } catch (error) {
    logError('Error pada addOltToRouter', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      routerId: req.params.router_id,
      requestBody: req.body
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan soft delete pada OLT dan semua ODC, ODP, serta ONT di dalamnya
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteOlt(req, res) {
  try {
    const context = getRequestContext();
    const { olt_id } = req.params;
    
    logDebug('Menerima request deleteOlt', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah OLT ada
    logDebug('Memeriksa keberadaan OLT sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id
    });
    
    const oltInfo = await oltRepository.getOltById(olt_id, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!oltInfo || !oltInfo.olt) {
      logWarn('OLT tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'OLT not found or already deleted'
      ));
    }
    
    // Lakukan soft delete rekursif pada OLT dan semua ODC, ODP, serta ONT di dalamnya
    try {
      logDebug('Memulai proses soft delete OLT secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        oltLabel: oltInfo.olt.label,
        branchId: oltInfo.branchId,
        routerIndex: oltInfo.routerIndex
      });
      
      const result = await softDeleteOlt({
        branchId: oltInfo.branchId,
        routerIndex: oltInfo.routerIndex,
        oltIndex: oltInfo.oltIndex
      });
      
      // Periksa hasil soft delete (result adalah boolean)
      if (!result) {
        logError('Soft delete OLT gagal', {
          requestId: context.getRequestId(),
          userId: context.getUserId(),
          oltId: olt_id,
          oltLabel: oltInfo.olt.label,
          branchId: oltInfo.branchId
        });
        
        return res.status(500).json(createErrorResponse(
          500,
          'Failed to delete OLT',
          { oltId: olt_id }
        ));
      }
      
      logDebug('Soft delete berhasil, mengambil data OLT yang sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id
      });
      
      // Dapatkan OLT yang sudah di-soft delete
      const deletedOlt = await oltRepository.getOltById(olt_id, branchRepository.DeletedFilterTypes.WITH);
      
      logInfo('OLT berhasil di-soft delete secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        oltLabel: oltInfo.olt.label,
        branchId: oltInfo.branchId
      });
      
      // Sukses, kembalikan status 200 dengan data OLT yang sudah di-soft delete
      res.status(200).json({
        message: 'OLT and all ODCs, ODPs, and ONTs deleted successfully',
        data: deletedOlt?.olt || { _id: olt_id, deleted_at: new Date() }
      });
    } catch (deleteError) {
      logError('Error saat proses delete OLT', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        error: deleteError.message,
        stack: deleteError.stack
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        `Failed to delete OLT: ${deleteError.message || 'Unknown error'}`,
        deleteError
      ));
    }
  } catch (error) {
    logError('Error pada deleteOlt controller', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      oltId: req.params.olt_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada OLT yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreOlt(req, res) {
  try {
    const context = getRequestContext();
    const { olt_id } = req.params;
    
    logDebug('Menerima request restoreOlt', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa status OLT terlebih dahulu - gunakan filter ONLY untuk mencari yang sudah dihapus
    logDebug('Memeriksa keberadaan OLT yang sudah dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id
    });
    
    const oltInfo = await oltRepository.getOltById(olt_id, branchRepository.DeletedFilterTypes.ONLY);
    
    logDebug('Status pencarian OLT yang dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      ditemukan: oltInfo ? true : false
    });
    
    if (!oltInfo || !oltInfo.olt) {
      logWarn('OLT tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'OLT not found or already restored'
      ));
    }
    
    // Coba restore OLT
    logDebug('Mencoba melakukan restore OLT secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      oltLabel: oltInfo.olt.label,
      branchId: oltInfo.branchId
    });
    
    const result = await oltRepository.restore(olt_id);
    
    logDebug('Hasil restore OLT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      berhasil: result ? true : false
    });
    
    if (!result) {
      logError('Gagal melakukan restore OLT', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        oltId: olt_id,
        oltLabel: oltInfo.olt.label
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Failed to restore OLT'
      ));
    }
    
    // Dapatkan data OLT yang sudah di-restore menggunakan filter WITH untuk memastikan kita bisa menemukannya
    logDebug('Mengambil data OLT yang sudah di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id
    });
    
    const restoredOlt = await oltRepository.getOltById(olt_id, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('OLT berhasil di-restore secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      oltId: olt_id,
      oltLabel: restoredOlt?.olt?.label || 'unknown',
      branchId: oltInfo.branchId
    });
    
    res.status(200).json({
      message: 'OLT restored successfully',
      data: restoredOlt
    });
  } catch (error) {
    logError('Error pada restoreOlt', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      oltId: req.params.olt_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getOltById,
  addOltToRouter,
  deleteOlt,
  restoreOlt
}; ###
cat src/controllers/netDeviceOnt.controller.js
/**
 * Controller untuk endpoint net device ONT
 */

const odpRepository = require('../repositories/netDeviceOdp.repository');
const ontRepository = require('../repositories/netDeviceOnt.repository');
const branchRepository = require('../repositories/branch.repository'); // Untuk DeletedFilterTypes
const netDeviceOntService = require('../services/netDeviceOnt.service');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan ONT berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getOntById(req, res) {
  try {
    const context = getRequestContext();
    const { ont_id } = req.params;
    
    logDebug('Menerima request getOntById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    const { deleted } = req.query;
    
    logDebug('Mengambil data ONT by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      filters: {
        deleted: deleted || 'WITHOUT'
      }
    });
    
    const ont = await netDeviceOntService.getOntById(ont_id, deleted);
    
    logInfo('Berhasil mengambil data ONT by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      deleted: deleted || 'WITHOUT'
    });
    
    res.status(200).json({
      data: ont
    });
  } catch (error) {
    logError('Error pada getOntById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      ontId: req.params.ont_id
    });
    
    if (error.message === 'ONT not found') {
      return res.status(404).json(createErrorResponse(
        404,
        error.message
      ));
    }
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan soft delete pada ONT berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteOnt(req, res) {
  try {
    const context = getRequestContext();
    const { ont_id } = req.params;
    
    logDebug('Menerima request deleteOnt', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah ONT ada
    logDebug('Memeriksa keberadaan ONT sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id
    });
    
    const ont = await ontRepository.getOntById(ont_id, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!ont) {
      logWarn('ONT tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        ontId: ont_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ONT not found or already deleted'
      ));
    }
    
    // Lakukan soft delete
    logDebug('Memulai proses soft delete ONT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      ontLabel: ont.label || 'unknown'
    });
    
    const deletedOnt = await ontRepository.softDeleteOnt(ont_id);
    
    if (!deletedOnt) {
      logError('Soft delete ONT gagal', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        ontId: ont_id,
        ontLabel: ont.label || 'unknown'
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        'Failed to delete ONT',
        { ontId: ont_id }
      ));
    }
    
    logInfo('ONT berhasil di-soft delete', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      ontLabel: ont.label || 'unknown'
    });
    
    // Sukses, kembalikan status 200 dengan data ONT yang sudah di-soft delete
    res.status(200).json({
      message: 'ONT deleted successfully',
      data: deletedOnt
    });
  } catch (error) {
    logError('Error pada deleteOnt controller', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      ontId: req.params.ont_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menambahkan ONT ke ODP
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function addOntToOdp(req, res) {
  try {
    const context = getRequestContext();
    const { odp_id } = req.params;
    
    logDebug('Menerima request addOntToOdp', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Periksa apakah ODP ada
    logDebug('Memeriksa keberadaan ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id
    });
    
    const odpInfo = await odpRepository.getOdpById(odp_id);
    
    if (!odpInfo || !odpInfo.odp) {
      logWarn('ODP tidak ditemukan untuk penambahan ONT', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'ODP not found'
      ));
    }
    
    // Periksa kapasitas port ODP
    const maxAvailablePort = odpInfo.odp.available_port || 0;
    const currentOntCount = odpInfo.odp.children ? odpInfo.odp.children.length : 0;
    
    logDebug('Memeriksa kapasitas port ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      odpLabel: odpInfo.odp.label || 'unknown',
      maxAvailablePort: maxAvailablePort,
      currentOntCount: currentOntCount
    });
    
    if (currentOntCount >= maxAvailablePort) {
      logWarn('Kapasitas port ODP terlampaui', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odp_id,
        odpLabel: odpInfo.odp.label || 'unknown',
        maxAvailablePort: maxAvailablePort,
        currentOntCount: currentOntCount
      });
      
      return res.status(400).json(createErrorResponse(
        400,
        `ODP port capacity exceeded. Maximum port: ${maxAvailablePort}, current ONT count: ${currentOntCount}`
      ));
    }
    
    // Tambahkan ONT ke ODP
    logDebug('Menambahkan ONT ke ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      odpLabel: odpInfo.odp.label || 'unknown',
      ontLabel: req.body.label
    });
    
    const updatedOdpInfo = await odpRepository.addOntToOdp(odp_id, req.body);
    
    logInfo('ONT berhasil ditambahkan ke ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odp_id,
      odpLabel: odpInfo.odp.label || 'unknown',
      ontLabel: req.body.label
    });
    
    res.status(200).json({
      message: 'ONT added to ODP successfully',
      data: updatedOdpInfo.odp
    });
  } catch (error) {
    logError('Error pada addOntToOdp', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      odpId: req.params.odp_id,
      requestBody: req.body
    });
    
    // Handling specific errors
    if (error.message && (error.message.includes('not found') || error.message.includes('exceeded'))) {
      return res.status(400).json(createErrorResponse(
        400,
        error.message,
        error
      ));
    }
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada ONT yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreOnt(req, res) {
  try {
    const context = getRequestContext();
    const { ont_id } = req.params;
    
    logDebug('Menerima request restoreOnt', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    logDebug('Mencoba melakukan restore ONT', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id
    });
    
    const ont = await netDeviceOntService.restoreOnt(ont_id);
    
    logInfo('ONT berhasil di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      ontId: ont_id,
      ontLabel: ont.label || 'unknown'
    });
    
    res.status(200).json({
      message: 'ONT restored successfully',
      data: ont
    });
  } catch (error) {
    logError('Error pada restoreOnt', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      ontId: req.params.ont_id
    });
    
    if (error.message === 'ONT not found or already restored') {
      return res.status(404).json(createErrorResponse(
        404,
        error.message
      ));
    }
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getOntById,
  addOntToOdp,
  deleteOnt,
  restoreOnt
}; ###
cat src/controllers/netDeviceRouter.controller.js
/**
 * Controller untuk endpoint net device router
 */

const branchRepository = require('../repositories/branch.repository');
const routerRepository = require('../repositories/netDeviceRouter.repository');
const { softDeleteRouter } = require('../utils/recursiveSoftDelete.util');
const { logDebug, logError, logInfo, logWarn, createErrorResponse } = require('../services/logger.service');
const { getRequestContext } = require('../services/requestContext.service');

/**
 * Mendapatkan router berdasarkan ID
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function getRouterById(req, res) {
  try {
    const context = getRequestContext();
    const { router_id } = req.params;
    
    logDebug('Menerima request getRouterById', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      query: req.query,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    const { deleted } = req.query;
    
    // Tentukan filter deleted (defaultnya WITHOUT)
    let deletedFilter = branchRepository.DeletedFilterTypes.WITHOUT;
    if (deleted && Object.values(branchRepository.DeletedFilterTypes).includes(deleted)) {
      deletedFilter = deleted;
    }
    
    logDebug('Mengambil data router by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      filters: {
        deleted: deletedFilter
      }
    });
    
    const router = await routerRepository.getRouterById(router_id, deletedFilter);
    
    if (!router) {
      logWarn('Router tidak ditemukan', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id,
        filters: {
          deleted: deletedFilter
        }
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Router not found'
      ));
    }
    
    logInfo('Berhasil mengambil data router by ID', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      deleted: deletedFilter
    });
    
    res.status(200).json({
      data: router
    });
  } catch (error) {
    logError('Error pada getRouterById', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      routerId: req.params.router_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Menambahkan router ke branch
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function addRouterToBranch(req, res) {
  try {
    const context = getRequestContext();
    const { branch_id } = req.params;
    
    logDebug('Menerima request addRouterToBranch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: branch_id,
      userRoles: context.getUserRoles().map(r => r.name),
      requestBody: req.body
    });
    
    // Periksa apakah branch ada
    logDebug('Memeriksa keberadaan branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: branch_id
    });
    
    const branch = await branchRepository.getBranchById(branch_id);
    
    if (!branch) {
      logWarn('Branch tidak ditemukan untuk penambahan router', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        branchId: branch_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Branch not found'
      ));
    }
    
    // Tambahkan router ke branch
    logDebug('Menambahkan router ke branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: branch_id,
      routerLabel: req.body.label
    });
    
    const updatedBranch = await branchRepository.addRouterToBranch(branch_id, req.body);
    
    logInfo('Router berhasil ditambahkan ke branch', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      branchId: branch_id,
      branchName: branch.name,
      routerLabel: req.body.label
    });
    
    res.status(200).json({
      message: 'Router added to branch successfully',
      data: updatedBranch
    });
  } catch (error) {
    logError('Error pada addRouterToBranch', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      branchId: req.params.branch_id,
      requestBody: req.body
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan soft delete pada Router dan semua OLT, ODC, ODP, serta ONT di dalamnya
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function deleteRouter(req, res) {
  try {
    const context = getRequestContext();
    const { router_id } = req.params;
    
    logDebug('Menerima request deleteRouter', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa apakah Router ada
    logDebug('Memeriksa keberadaan router sebelum dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id
    });
    
    const routerInfo = await routerRepository.getRouterById(router_id, branchRepository.DeletedFilterTypes.WITHOUT);
    
    if (!routerInfo || !routerInfo.router) {
      logWarn('Router tidak ditemukan atau sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Router not found or already deleted'
      ));
    }
    
    // Lakukan soft delete rekursif pada Router dan semua device di dalamnya
    try {
      logDebug('Memulai proses soft delete router secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id,
        routerLabel: routerInfo.router.label,
        branchId: routerInfo.branchId
      });
      
      const result = await softDeleteRouter({
        branchId: routerInfo.branchId,
        routerIndex: routerInfo.routerIndex
      });
      
      if (!result) {
        logError('Soft delete router gagal', {
          requestId: context.getRequestId(),
          userId: context.getUserId(),
          routerId: router_id,
          routerLabel: routerInfo.router.label,
          branchId: routerInfo.branchId
        });
        
        return res.status(500).json(createErrorResponse(
          500,
          'Failed to delete Router',
          { routerId: router_id }
        ));
      }
      
      logDebug('Soft delete berhasil, mengambil data Router yang sudah dihapus', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id
      });
      
      // Dapatkan Router yang sudah di-soft delete
      const deletedRouter = await routerRepository.getRouterById(router_id, branchRepository.DeletedFilterTypes.WITH);
      
      logInfo('Router berhasil di-soft delete secara rekursif', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id,
        routerLabel: routerInfo.router.label,
        branchId: routerInfo.branchId
      });
      
      // Sukses, kembalikan status 200 dengan data Router yang sudah di-soft delete
      res.status(200).json({
        message: 'Router and all OLTs, ODCs, ODPs, and ONTs deleted successfully',
        data: deletedRouter?.router || { _id: router_id, deleted_at: new Date() }
      });
    } catch (deleteError) {
      logError('Error saat proses delete router', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id,
        error: deleteError.message,
        stack: deleteError.stack
      });
      
      return res.status(500).json(createErrorResponse(
        500,
        `Failed to delete Router: ${deleteError.message || 'Unknown error'}`,
        deleteError
      ));
    }
  } catch (error) {
    logError('Error pada deleteRouter controller', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      routerId: req.params.router_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

/**
 * Melakukan restore pada Router yang sudah di-soft delete
 * @param {Object} req - Request object
 * @param {Object} res - Response object
 */
async function restoreRouter(req, res) {
  try {
    const context = getRequestContext();
    const { router_id } = req.params;
    
    logDebug('Menerima request restoreRouter', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      userRoles: context.getUserRoles().map(r => r.name)
    });
    
    // Periksa status Router terlebih dahulu
    logDebug('Memeriksa keberadaan router yang sudah dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id
    });
    
    const routerInfo = await routerRepository.getRouterById(router_id, branchRepository.DeletedFilterTypes.ONLY);
    
    logDebug('Status pencarian router yang dihapus', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      ditemukan: routerInfo ? true : false
    });
    
    if (!routerInfo || !routerInfo.router) {
      logWarn('Router tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Router not found or already restored'
      ));
    }
    
    // Coba restore Router
    logDebug('Mencoba melakukan restore router secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      routerLabel: routerInfo.router.label,
      branchId: routerInfo.branchId
    });
    
    const result = await routerRepository.restore(router_id);
    
    logDebug('Hasil restore router', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      berhasil: result ? true : false
    });
    
    if (!result) {
      logError('Gagal melakukan restore router', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        routerId: router_id,
        routerLabel: routerInfo.router.label
      });
      
      return res.status(404).json(createErrorResponse(
        404,
        'Failed to restore Router'
      ));
    }
    
    // Dapatkan data Router yang sudah di-restore
    logDebug('Mengambil data router yang sudah di-restore', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id
    });
    
    const restoredRouter = await routerRepository.getRouterById(router_id, branchRepository.DeletedFilterTypes.WITH);
    
    logInfo('Router berhasil di-restore secara rekursif', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      routerId: router_id,
      routerLabel: restoredRouter?.router?.label || 'unknown',
      branchId: routerInfo.branchId
    });
    
    res.status(200).json({
      message: 'Router restored successfully',
      data: restoredRouter
    });
  } catch (error) {
    logError('Error pada restoreRouter', {
      requestId: getRequestContext().getRequestId(),
      error: error.message,
      stack: error.stack,
      userId: getRequestContext().getUserId(),
      routerId: req.params.router_id
    });
    
    res.status(500).json(createErrorResponse(
      500,
      'Internal server error',
      error
    ));
  }
}

module.exports = {
  getRouterById,
  addRouterToBranch,
  deleteRouter,
  restoreRouter
}; ###
cat src/repositories/branch.repository.js
/**
 * Repository untuk operasi CRUD pada collection branches
 */

const { getCollection } = require('./database.connector');
const { createBranchEntity } = require('../entities/branch.entity');
const { createNetDeviceRouterEntity } = require('../entities/netDeviceRouter.entity');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { recursiveDeletedCheck, DeletedFilterTypes } = require('../utils/recursiveDeletedCheck.util');
const { logDebug, logError, logTrace } = require('../services/logger.service');

// Nama collection
const COLLECTION = 'branches';

// Enum untuk tipe scope level
const ResultTypes = {
  BRANCHES: 'BRANCHES',
  ROUTERS: 'ROUTERS',
  OLTS: 'OLTS',
  ODCS: 'ODCS',
  ODPS: 'ODPS',
  ONTS: 'ONTS'
};

/**
 * Mendapatkan semua branches dengan level detail tertentu dan filter akses
 * @param {string} scopeLevel - Level scope data (BRANCHES, ROUTERS, OLTS, ODCS, ODPS, ONTS)
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @param {Array<ObjectId>} [accessibleBranchIds] - Array of branch IDs yang bisa diakses
 * @returns {Promise<Array>} - Array berisi data branches sesuai level detail dan filter
 */
async function getAllBranches(scopeLevel = null, deletedFilter = DeletedFilterTypes.WITHOUT, accessibleBranchIds = null) {
  try {
    logDebug('Memulai query getAllBranches', {
      scopeLevel,
      deletedFilter,
      hasAccessFilter: !!accessibleBranchIds
    });

    const collection = getCollection(COLLECTION);
    const startTime = Date.now();

    // Buat query berdasarkan akses
    const query = accessibleBranchIds ? { _id: { $in: accessibleBranchIds } } : {};
    const branches = await collection.find(query).toArray();
    
    logTrace('Query database selesai', {
      executionTime: Date.now() - startTime,
      resultCount: branches.length,
      accessFilterApplied: !!accessibleBranchIds
    });
    
    const filteredBranches = branches
      .map(branch => recursiveDeletedCheck(branch, deletedFilter, scopeLevel))
      .filter(branch => branch !== null);
    
    logDebug('Filtering branches selesai', {
      originalCount: branches.length,
      filteredCount: filteredBranches.length,
      filters: {
        scopeLevel,
        deletedFilter,
        accessFiltered: !!accessibleBranchIds
      }
    });

    return filteredBranches;
  } catch (error) {
    logError('Error pada getAllBranches repository', {
      error: error.message,
      stack: error.stack,
      collection: COLLECTION
    });
    throw error;
  }
}

/**
 * Mendapatkan branch berdasarkan ID dengan level detail tertentu
 * @param {string} id - ID branch
 * @param {string} scopeLevel - Level scope data (BRANCHES, ROUTERS, OLTS, ODCS, ODPS, ONTS)
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object>} - Data branch sesuai level detail dan filter
 */
async function getBranchById(id, scopeLevel = null, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    const collection = getCollection(COLLECTION);
    const branch = await collection.findOne({ _id: new ObjectId(id) });
    
    if (!branch) {
      return null;
    }
    
    // Terapkan recursive deleted check
    return recursiveDeletedCheck(branch, deletedFilter, scopeLevel);
  } catch (error) {
    console.error('Error getting branch by ID:', error);
    throw error;
  }
}

/**
 * Membuat branch baru
 * @param {Object} branchData - Data branch yang akan dibuat
 * @returns {Promise<Object>} - Data branch yang sudah dibuat
 */
async function createBranch(branchData) {
  try {
    const collection = getCollection(COLLECTION);
    const branch = createBranchEntity(branchData);
    const result = await collection.insertOne(branch);
    return { ...branch, _id: result.insertedId };
  } catch (error) {
    console.error('Error creating branch:', error);
    throw error;
  }
}

/**
 * Mengupdate branch berdasarkan ID
 * @param {string} id - ID branch
 * @param {Object} branchData - Data branch yang akan diupdate
 * @returns {Promise<Object>} - Data branch yang sudah diupdate
 */
async function updateBranch(id, branchData) {
  try {
    const collection = getCollection(COLLECTION);
    const branch = createBranchEntity(branchData);
    delete branch._id; // Hapus _id agar tidak diupdate
    
    await collection.updateOne(
      { _id: new ObjectId(id) },
      { $set: branch }
    );
    
    // Panggil getBranchById tanpa parameter result untuk mendapatkan data lengkap
    return getBranchById(id, null);
  } catch (error) {
    console.error(`Error updating branch with ID ${id}:`, error);
    throw error;
  }
}

/**
 * Menghapus branch berdasarkan ID
 * @param {string} id - ID branch
 * @returns {Promise<boolean>} - True jika berhasil dihapus
 */
async function deleteBranch(id) {
  try {
    const collection = getCollection(COLLECTION);
    const result = await collection.deleteOne({ _id: new ObjectId(id) });
    return result.deletedCount > 0;
  } catch (error) {
    console.error(`Error deleting branch with ID ${id}:`, error);
    throw error;
  }
}

/**
 * Menambahkan router ke branch berdasarkan ID branch
 * @param {string} id - ID branch
 * @param {Object} routerData - Data router yang akan ditambahkan
 * @returns {Promise<Object>} - Data branch yang sudah diupdate dengan router baru
 */
async function addRouterToBranch(id, routerData) {
  try {
    const collection = getCollection(COLLECTION);
    
    // Buat entity router dengan ObjectId baru
    const routerId = new ObjectId();
    const router = createNetDeviceRouterEntity({
      ...routerData,
      _id: routerId
    });
    
    // Update branch, tambahkan router ke children
    const result = await collection.updateOne(
      { _id: new ObjectId(id) },
      { 
        $push: { children: router },
        $set: { updatedAt: new Date() }
      }
    );
    
    if (result.matchedCount === 0) {
      return null;
    }
    
    // Panggil getBranchById tanpa parameter result untuk mendapatkan data lengkap
    return getBranchById(id, null);
  } catch (error) {
    console.error(`Error adding router to branch with ID ${id}:`, error);
    throw error;
  }
}

/**
 * Melakukan restore pada branch yang telah di-soft delete
 * @param {string} branchId - ID branch yang akan di-restore
 * @returns {Promise<Object|null>} - Hasil restore atau null jika branch tidak ditemukan/tidak bisa di-restore
 */
async function restore(branchId) {
  try {
    console.log(`[restore] Mencoba restore branch dengan ID: ${branchId}`);
    
    // Import fungsi restore
    const { restoreBranch } = require('../utils/recursiveRestore.util');
    
    // Cari branch yang memiliki deleted_at
    const branch = await getBranchById(branchId, null, DeletedFilterTypes.ONLY);
    console.log(`[restore] Status pencarian branch yang dihapus:`, branch ? 'Ditemukan' : 'Tidak ditemukan');
    
    if (!branch) {
      console.log('[restore] Branch tidak ditemukan atau sudah di-restore');
      return null;
    }

    // Simpan timestamp deleted_at untuk digunakan dalam restore
    const deletedAt = branch.deleted_at;
    console.log(`[restore] Branch ditemukan dengan deleted_at: ${deletedAt}`);
    
    // Lakukan restore
    console.log('[restore] Memanggil fungsi restoreBranch');
    const result = await restoreBranch(branchId, deletedAt);
    console.log(`[restore] Hasil restore:`, result ? 'Berhasil' : 'Gagal');
    
    if (!result) {
      console.log('[restore] Gagal melakukan restore branch');
      return null;
    }
    
    // Ambil data branch yang sudah di-restore
    const restoredBranch = await getBranchById(branchId, null, DeletedFilterTypes.WITHOUT);
    console.log('[restore] Berhasil mengambil data branch yang sudah di-restore');
    
    return restoredBranch;
  } catch (error) {
    console.error('[restore] Error saat melakukan restore branch:', error);
    throw error;
  }
}

module.exports = {
  getAllBranches,
  getBranchById,
  createBranch,
  updateBranch,
  deleteBranch,
  addRouterToBranch,
  ResultTypes,
  DeletedFilterTypes,
  restore
};
###
cat src/repositories/branchAccess.repository.js
const { ObjectId } = require('mongodb');
const { getCollection } = require('./database.connector');
const { createBranchAccess, validateBranchAccess } = require('../entities/branchAccess.entity');
const { logDebug, logError } = require('../services/logger.service');

class BranchAccessRepository {
  constructor() {
    this.collectionName = 'branch_access';
  }

  /**
   * Mendapatkan collection
   * @private
   */
  getCollection() {
    return getCollection(this.collectionName);
  }

  /**
   * Memeriksa akses user ke branch tertentu
   * @param {string} userId - UUID dari user
   * @param {string|ObjectId} branchId - ID dari branch
   * @returns {Promise<Object|null>} - Document branch_access jika ditemukan
   */
  async checkAccess(userId, branchId) {
    try {
      const branchObjectId = typeof branchId === 'string' ? new ObjectId(branchId) : branchId;
      
      const access = await this.getCollection().findOne({
        user_id: userId,
        branch_id: branchObjectId
      });

      logDebug('Checked branch access', {
        userId,
        branchId: branchObjectId.toString(),
        hasAccess: !!access,
        permission: access?.permission
      });

      return access;
    } catch (error) {
      logError('Error checking branch access', {
        userId,
        branchId,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Mendapatkan list branch yang dapat diakses oleh user
   * @param {string} userId - UUID dari user
   * @returns {Promise<Array>} - Array dari branch_id yang dapat diakses
   */
  async getAccessibleBranches(userId) {
    try {
      const accessList = await this.getCollection().find({
        user_id: userId
      }).toArray();

      logDebug('Retrieved accessible branches', {
        userId,
        count: accessList.length
      });

      return accessList;
    } catch (error) {
      logError('Error getting accessible branches', {
        userId,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Menambahkan akses branch baru
   * @param {Object} data - Data akses branch
   * @returns {Promise<Object>} - Document yang dibuat
   */
  async addAccess(data) {
    try {
      validateBranchAccess(data);
      const branchAccess = createBranchAccess(data);
      
      await this.getCollection().insertOne(branchAccess);

      logDebug('Added branch access', {
        userId: data.user_id,
        branchId: branchAccess.branch_id.toString(),
        permission: data.permission
      });

      return branchAccess;
    } catch (error) {
      logError('Error adding branch access', {
        data,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Mengupdate permission akses branch
   * @param {string} userId - UUID dari user
   * @param {string|ObjectId} branchId - ID dari branch
   * @param {string} permission - Permission baru (R/RW)
   * @returns {Promise<Object>} - Result dari update
   */
  async updateAccess(userId, branchId, permission) {
    try {
      const branchObjectId = typeof branchId === 'string' ? new ObjectId(branchId) : branchId;
      
      const result = await this.getCollection().updateOne(
        {
          user_id: userId,
          branch_id: branchObjectId
        },
        {
          $set: { permission }
        }
      );

      logDebug('Updated branch access', {
        userId,
        branchId: branchObjectId.toString(),
        permission,
        modified: result.modifiedCount
      });

      return result;
    } catch (error) {
      logError('Error updating branch access', {
        userId,
        branchId,
        permission,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Menghapus akses branch
   * @param {string} userId - UUID dari user
   * @param {string|ObjectId} branchId - ID dari branch
   * @returns {Promise<Object>} - Result dari delete
   */
  async removeAccess(userId, branchId) {
    try {
      const branchObjectId = typeof branchId === 'string' ? new ObjectId(branchId) : branchId;
      
      const result = await this.getCollection().deleteOne({
        user_id: userId,
        branch_id: branchObjectId
      });

      logDebug('Removed branch access', {
        userId,
        branchId: branchObjectId.toString(),
        deleted: result.deletedCount
      });

      return result;
    } catch (error) {
      logError('Error removing branch access', {
        userId,
        branchId,
        error: error.message
      });
      throw error;
    }
  }
}

// Export singleton instance
const branchAccessRepository = new BranchAccessRepository();
module.exports = branchAccessRepository; ###
cat src/repositories/database.connector.js
/**
 * Database connector untuk mengakses connection pool MongoDB
 */

const { getConnection } = require('../../connections/mongodb_conn');
const dbConfig = require('../../config/database.config');

/**
 * Mendapatkan referensi ke database
 * @returns {Object} - Objek database MongoDB
 */
const getDatabase = () => {
  const connection = getConnection();
  if (!connection) {
    throw new Error('Database connection not established');
  }
  return connection.connection.useDb(dbConfig.database);
};

/**
 * Mendapatkan collection tertentu dari database
 * @param {string} collectionName - Nama collection
 * @returns {Object} - Objek collection MongoDB
 */
const getCollection = (collectionName) => {
  const db = getDatabase();
  return db.collection(collectionName);
};

module.exports = {
  getDatabase,
  getCollection
};
###
cat src/repositories/log.repository.js
/**
 * Repository untuk operasi logging ke Elasticsearch
 */

const { Client } = require('@elastic/elasticsearch');
const config = require('../../config/app.config');
const { createLogEntity } = require('../entities/log.entity');

// Inisialisasi Elasticsearch client
const client = new Client({
  node: config.elasticsearch.node,
  auth: {
    username: config.elasticsearch.auth.username,
    password: config.elasticsearch.auth.password
  }
});

/**
 * Menyimpan log ke Elasticsearch
 * @param {Object} logData - Data log yang akan disimpan
 * @returns {Promise<Object>} - Response dari Elasticsearch
 */
async function createLog(logData) {
  try {
    const logEntity = createLogEntity(logData);
    
    const result = await client.index({
      index: config.elasticsearch.index,
      id: logEntity._id,
      document: logEntity
    });

    return result;
  } catch (error) {
    console.error('Error creating log in Elasticsearch:', error);
    throw error;
  }
}

/**
 * Mencari log berdasarkan kriteria
 * @param {Object} criteria - Kriteria pencarian
 * @returns {Promise<Array>} - Array of logs
 */
async function searchLogs(criteria) {
  try {
    const { body } = await client.search({
      index: config.elasticsearch.index,
      body: {
        query: {
          bool: {
            must: Object.entries(criteria).map(([key, value]) => ({
              match: { [key]: value }
            }))
          }
        },
        sort: [{ timestamp: 'desc' }]
      }
    });

    return body.hits.hits.map(hit => hit._source);
  } catch (error) {
    console.error('Error searching logs in Elasticsearch:', error);
    throw error;
  }
}

module.exports = {
  createLog,
  searchLogs
}; ###
cat src/repositories/netDeviceOdc.repository.js
/**
 * Repository untuk operasi pada collection branches terkait net device ODC
 */

const { getCollection } = require('./database.connector');
const { createNetDeviceOdpEntity } = require('../entities/netDeviceOdp.entity');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { DeletedFilterTypes } = require('./branch.repository');
const { restoreOdc } = require('../utils/recursiveRestore.util');

// Nama collection
const COLLECTION = 'branches';

// Enum untuk tipe result
const ResultTypes = {
  ODCS: 'ODCS',
  ODPS: 'ODPS'
};

/**
 * Mendapatkan ODC berdasarkan ID
 * @param {string} odcId - ID ODC
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object>} - Data ODC
 */
async function getOdcById(odcId, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    console.log(`[getOdcById] Mencari ODC dengan ID: ${odcId}, filter: ${deletedFilter}`);
    const collection = getCollection('branches');
    const objectId = new ObjectId(odcId);
    
    // Cari branch yang memiliki ODC dengan ID tertentu
    const branch = await collection.findOne({
      'children.children.pon_port.children._id': objectId
    });
    
    console.log(`[getOdcById] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;
    
    // Variabel untuk menyimpan indeks dan data
    let routerIndex = -1;
    let oltIndex = -1;
    let ponPortIndex = -1;
    let odcIndex = -1;
    let odcData = null;
    
    // Loop melalui branch > router > olt > pon_port > odc
    outerLoop: for (let i = 0; i < branch.children.length; i++) {
      const router = branch.children[i];
      
      if (router.children && Array.isArray(router.children)) {
        for (let j = 0; j < router.children.length; j++) {
          const olt = router.children[j];
          
          if (olt.pon_port && Array.isArray(olt.pon_port)) {
            for (let k = 0; k < olt.pon_port.length; k++) {
              const ponPort = olt.pon_port[k];
              
              if (ponPort.children && Array.isArray(ponPort.children)) {
                for (let l = 0; l < ponPort.children.length; l++) {
                  const odc = ponPort.children[l];
                  
                  if (odc._id.toString() === odcId.toString()) {
                    console.log(`[getOdcById] ODC ditemukan dengan deleted_at: ${odc.deleted_at || 'tidak ada'}`);
                    
                    // Periksa filter
                    if (deletedFilter === DeletedFilterTypes.ONLY && !odc.deleted_at) {
                      console.log('[getOdcById] ODC tidak memiliki deleted_at, tapi filter ONLY');
                      continue;
                    }
                    if (deletedFilter === DeletedFilterTypes.WITHOUT && odc.deleted_at) {
                      console.log('[getOdcById] ODC memiliki deleted_at, tapi filter WITHOUT');
                      continue;
                    }
                    
                    routerIndex = i;
                    oltIndex = j;
                    ponPortIndex = k;
                    odcIndex = l;
                    odcData = odc;
                    break outerLoop;
                  }
                }
              }
            }
          }
        }
      }
    }
    
    // Jika ODC tidak ditemukan atau tidak memenuhi filter
    if (!odcData) {
      console.log('[getOdcById] ODC tidak ditemukan atau tidak memenuhi filter');
      return null;
    }
    
    console.log('[getOdcById] ODC berhasil ditemukan dan memenuhi filter');
    
    // Return objek dengan data ODC dan indeksnya
    return {
      odc: odcData,
      branchId: branch._id,
      routerIndex,
      oltIndex,
      ponPortIndex,
      odcIndex
    };
  } catch (error) {
    console.error('Error getting ODC by ID:', error);
    throw error;
  }
}

/**
 * Mendapatkan detail ODC berdasarkan ID dengan level detail tertentu
 * @param {string} odcId - ID ODC
 * @param {string} resultType - Tipe hasil (ODCS, ODPS)
 * @returns {Promise<Object>} - Data ODC sesuai level detail
 */
async function getOdcDetailById(odcId, resultType = null) {
  try {
    const odcInfo = await getOdcById(odcId);
    
    if (!odcInfo || !odcInfo.odc) {
      return null;
    }
    
    // Ambil data ODC
    const odc = odcInfo.odc;
    
    // Jika resultType tidak dispesifikasikan, kembalikan data lengkap seperti biasa
    if (!resultType || !Object.values(ResultTypes).includes(resultType)) {
      return odcInfo;
    }
    
    // Filter data sesuai resultType
    const odcCopy = { ...odc };
    
    // ODCS: Hapus children dari setiap tray di trays
    if (resultType === ResultTypes.ODCS) {
      if (odcCopy.trays && Array.isArray(odcCopy.trays)) {
        odcCopy.trays = odcCopy.trays.map(tray => {
          const trayCopy = { ...tray };
          delete trayCopy.children;
          return trayCopy;
        });
      }
      return {
        ...odcInfo,
        odc: odcCopy
      };
    }
    
    // ODPS: Hapus children dari setiap ODP
    if (resultType === ResultTypes.ODPS) {
      if (odcCopy.trays && Array.isArray(odcCopy.trays)) {
        odcCopy.trays = odcCopy.trays.map(tray => {
          const trayCopy = { ...tray };
          
          if (trayCopy.children && Array.isArray(trayCopy.children)) {
            trayCopy.children = trayCopy.children.map(odp => {
              const odpCopy = { ...odp };
              delete odpCopy.children;
              return odpCopy;
            });
          }
          
          return trayCopy;
        });
      }
      return {
        ...odcInfo,
        odc: odcCopy
      };
    }
    
    return odcInfo;
  } catch (error) {
    console.error(`Error getting ODC detail with ID ${odcId}:`, error);
    throw error;
  }
}

/**
 * Menambahkan ODP ke ODC pada tray tertentu
 * @param {string} odcId - ID ODC
 * @param {Object} odpData - Data ODP yang akan ditambahkan
 * @returns {Promise<Object>} - Data ODC yang sudah diupdate dengan ODP baru
 */
async function addOdpToOdc(odcId, odpData) {
  try {
    const collection = getCollection(COLLECTION);
    
    // Dapatkan informasi ODC
    const odcInfo = await getOdcById(odcId);
    if (!odcInfo || !odcInfo.odc) {
      return null;
    }
    
    const { odc, branchId, routerIndex, oltIndex, ponPortIndex, odcIndex } = odcInfo;
    
    // Cari tray yang sesuai
    const trayIndex = odc.trays.findIndex(tray => tray.tray === odpData.tray);
    if (trayIndex === -1) {
      throw new Error(`Tray ${odpData.tray} not found on ODC ${odcId}`);
    }
    
    const tray = odc.trays[trayIndex];
    
    // Validasi core_on_odc_tray
    if (odpData.core_on_odc_tray < tray.start_core || odpData.core_on_odc_tray > tray.end_core) {
      throw new Error(`core_on_odc_tray value (${odpData.core_on_odc_tray}) out of range for tray ${odpData.tray}. Valid range: ${tray.start_core}-${tray.end_core}`);
    }
    
    // Simpan nilai tray untuk digunakan di entity, lalu hapus dari data input
    const trayNumber = odpData.tray;
    delete odpData.tray;
    
    // Buat entity ODP dengan ObjectId baru
    const odpId = new ObjectId();
    const odp = createNetDeviceOdpEntity({
      ...odpData,
      _id: odpId
    });
    
    // Path untuk update
    const trayPath = `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children`;
    
    // Update branch, tambahkan ODP ke tray ODC
    const result = await collection.updateOne(
      { _id: branchId },
      { 
        $push: { [trayPath]: odp },
        $set: { updatedAt: new Date() }
      }
    );
    
    if (result.matchedCount === 0) {
      return null;
    }
    
    // Dapatkan ODC yang sudah diupdate
    return getOdcById(odcId);
  } catch (error) {
    console.error(`Error adding ODP to ODC with ID ${odcId}:`, error);
    throw error;
  }
}

/**
 * Melakukan restore pada ODC yang telah di-soft delete
 * @param {string} odcId - ID ODC yang akan di-restore
 * @returns {Promise<Object|null>} - Hasil restore atau null jika ODC tidak ditemukan/tidak bisa di-restore
 */
async function restore(odcId) {
  try {
    const result = await restoreOdc(odcId);
    return result;
  } catch (error) {
    console.error('Error in ODC repository - restore:', error);
    throw error;
  }
}

module.exports = {
  getOdcById,
  getOdcDetailById,
  addOdpToOdc,
  ResultTypes,
  restore
}; ###
cat src/repositories/netDeviceOdp.repository.js
/**
 * Repository untuk operasi pada collection branches terkait net device ODP
 */

const { getCollection } = require('./database.connector');
const { createNetDeviceOntEntity } = require('../entities/netDeviceOnt.entity');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { DeletedFilterTypes } = require('./branch.repository');
const { restoreOdp } = require('../utils/recursiveRestore.util');

// Nama collection
const COLLECTION = 'branches';

// Enum untuk tipe result
const ResultTypes = {
  ODPS: 'ODPS'
};

/**
 * Mendapatkan ODP berdasarkan ID
 * @param {string} odpId - ID ODP
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object>} - Data ODP
 */
async function getOdpById(odpId, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    const { logDebug, logInfo, logWarn, logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    const context = getRequestContext();
    
    logDebug(`Mencari ODP dengan ID: ${odpId}, filter: ${deletedFilter}`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      filter: deletedFilter
    });
    
    const branchCollection = getCollection('branches');
    const objectId = new ObjectId(odpId);
    
    // Pipeline aggregation untuk mencari branch yang berisi ODP dengan ID tertentu
    const pipeline = [
      // Match branches yang memiliki ODP dengan ID tertentu
      {
        $match: {
          'children.children.pon_port.children.trays.children._id': objectId
        }
      }
    ];
    
    // Tambahkan filter deleted
    if (deletedFilter === DeletedFilterTypes.ONLY) {
      pipeline[0].$match['children.children.pon_port.children.trays.children.deleted_at'] = { $exists: true };
      logDebug('Menambahkan filter ONLY - mencari yang memiliki deleted_at', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
    } else if (deletedFilter === DeletedFilterTypes.WITHOUT) {
      pipeline[0].$match['children.children.pon_port.children.trays.children.deleted_at'] = { $exists: false };
      logDebug('Menambahkan filter WITHOUT - mencari yang tidak memiliki deleted_at', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
    }
    
    logDebug('Query MongoDB untuk mencari ODP', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      pipeline: JSON.stringify(pipeline)
    });
    
    // Eksekusi query untuk mendapatkan branch
    const branches = await branchCollection.aggregate(pipeline).toArray();
    logDebug(`Jumlah branches ditemukan: ${branches.length}`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      branchCount: branches.length
    });
    
    if (!branches || branches.length === 0) {
      logWarn('Tidak ada branch yang ditemukan untuk ODP', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
      return null;
    }
    
    // Ambil branch pertama yang memiliki ODP tersebut
    const branch = branches[0];
    
    // Variabel untuk menyimpan indeks dan data
    let routerIndex = -1;
    let oltIndex = -1;
    let ponPortIndex = -1;
    let odcIndex = -1;
    let trayIndex = -1;
    let odpIndex = -1;
    let odpData = null;
    
    // Loop melalui branch > router > olt > pon_port > odc > tray > odp
    outerLoop: for (let i = 0; i < branch.children.length; i++) {
      const router = branch.children[i];
      
      if (router.children && Array.isArray(router.children)) {
        for (let j = 0; j < router.children.length; j++) {
          const olt = router.children[j];
          
          if (olt.pon_port && Array.isArray(olt.pon_port)) {
            for (let k = 0; k < olt.pon_port.length; k++) {
              const ponPort = olt.pon_port[k];
              
              if (ponPort.children && Array.isArray(ponPort.children)) {
                for (let l = 0; l < ponPort.children.length; l++) {
                  const odc = ponPort.children[l];
                  
                  if (odc.trays && Array.isArray(odc.trays)) {
                    for (let m = 0; m < odc.trays.length; m++) {
                      const tray = odc.trays[m];
                      
                      if (tray.children && Array.isArray(tray.children)) {
                        for (let n = 0; n < tray.children.length; n++) {
                          const odp = tray.children[n];
                          
                          if (odp._id.toString() === odpId.toString()) {
                            logDebug(`ODP ditemukan dengan deleted_at: ${odp.deleted_at || 'tidak ada'}`, {
                              requestId: context.getRequestId(),
                              userId: context.getUserId(),
                              odpId: odpId,
                              hasDeletedAt: !!odp.deleted_at
                            });
                            
                            // Periksa filter
                            if (deletedFilter === DeletedFilterTypes.ONLY && !odp.deleted_at) {
                              logDebug('ODP tidak memiliki deleted_at, tapi filter ONLY', {
                                requestId: context.getRequestId(),
                                userId: context.getUserId(),
                                odpId: odpId
                              });
                              continue;
                            }
                            if (deletedFilter === DeletedFilterTypes.WITHOUT && odp.deleted_at) {
                              logDebug('ODP memiliki deleted_at, tapi filter WITHOUT', {
                                requestId: context.getRequestId(),
                                userId: context.getUserId(),
                                odpId: odpId
                              });
                              continue;
                            }
                            
                            routerIndex = i;
                            oltIndex = j;
                            ponPortIndex = k;
                            odcIndex = l;
                            trayIndex = m;
                            odpIndex = n;
                            odpData = odp;
                            break outerLoop;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    
    // Jika ODP tidak ditemukan
    if (!odpData) {
      logWarn('ODP tidak ditemukan atau tidak memenuhi filter', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId,
        filter: deletedFilter
      });
      return null;
    }
    
    logInfo('ODP berhasil ditemukan dan memenuhi filter', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      filter: deletedFilter,
      odpLabel: odpData.label || 'unknown'
    });
    
    // Return objek dengan data ODP dan indeksnya
    return {
      odp: odpData,
      branchId: branch._id,
      routerIndex,
      oltIndex,
      ponPortIndex,
      odcIndex,
      trayIndex,
      odpIndex
    };
  } catch (error) {
    const { logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    
    logError('Error getting ODP by ID:', {
      requestId: getRequestContext().getRequestId(),
      userId: getRequestContext().getUserId(),
      odpId: odpId,
      error: error.message,
      stack: error.stack
    });
    
    throw error;
  }
}

/**
 * Mendapatkan detail ODP berdasarkan ID dengan level detail tertentu
 * @param {string} odpId - ID ODP
 * @param {string} resultType - Tipe hasil (ODPS)
 * @returns {Promise<Object>} - Data ODP sesuai level detail
 */
async function getOdpDetailById(odpId, resultType = null) {
  try {
    const { logDebug, logInfo, logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    const context = getRequestContext();
    
    logDebug(`Mencari detail ODP dengan ID: ${odpId}, result type: ${resultType || 'default'}`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      resultType: resultType || 'default'
    });
    
    const odpInfo = await getOdpById(odpId);
    
    if (!odpInfo || !odpInfo.odp) {
      logDebug(`ODP dengan ID ${odpId} tidak ditemukan`, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
      return null;
    }
    
    // Ambil data ODP
    const odp = odpInfo.odp;
    
    // Jika resultType tidak dispesifikasikan, kembalikan data lengkap seperti biasa
    if (!resultType || !Object.values(ResultTypes).includes(resultType)) {
      logDebug(`Mengembalikan data ODP lengkap dengan ID: ${odpId}`, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId,
        odpLabel: odp.label || 'unknown'
      });
      return odpInfo;
    }
    
    // Filter data sesuai resultType
    const odpCopy = { ...odp };
    
    // ODPS: Hapus children dari ODP
    if (resultType === ResultTypes.ODPS) {
      logDebug(`Mengembalikan data ODP yang difilter (tanpa ONT children) untuk ID: ${odpId}`, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId,
        odpLabel: odp.label || 'unknown',
        resultType: resultType
      });
      
      delete odpCopy.children;
      return {
        ...odpInfo,
        odp: odpCopy
      };
    }
    
    return odpInfo;
  } catch (error) {
    const { logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    
    logError(`Error getting ODP detail with ID ${odpId}:`, {
      requestId: getRequestContext().getRequestId(),
      userId: getRequestContext().getUserId(),
      odpId: odpId,
      resultType: resultType || 'default',
      error: error.message,
      stack: error.stack
    });
    
    throw error;
  }
}

/**
 * Menambahkan ONT ke ODP
 * @param {string} odpId - ID ODP
 * @param {Object} ontData - Data ONT yang akan ditambahkan
 * @returns {Promise<Object>} - Data ODP yang sudah diupdate dengan ONT baru
 */
async function addOntToOdp(odpId, ontData) {
  try {
    const { logDebug, logInfo, logWarn, logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    const context = getRequestContext();
    
    const collection = getCollection(COLLECTION);
    
    logDebug(`Memulai proses penambahan ONT ke ODP`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      ontLabel: ontData.label
    });
    
    // Dapatkan informasi ODP
    const odpInfo = await getOdpById(odpId);
    if (!odpInfo || !odpInfo.odp) {
      logWarn(`ODP tidak ditemukan untuk penambahan ONT`, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
      return null;
    }
    
    const { 
      odp, branchId, routerIndex, oltIndex, 
      ponPortIndex, odcIndex, trayIndex, odpIndex 
    } = odpInfo;
    
    // Validasi jumlah ONT tidak melebihi kapasitas port ODP
    const maxAvailablePort = odp.available_port || 0;
    const currentOntCount = odp.children ? odp.children.length : 0;
    
    logDebug(`Validasi kapasitas port ODP untuk ONT baru`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      odpLabel: odp.label || 'unknown',
      maxAvailablePort: maxAvailablePort,
      currentOntCount: currentOntCount
    });
    
    if (currentOntCount >= maxAvailablePort) {
      const errorMsg = `ODP port capacity exceeded. Maximum port: ${maxAvailablePort}, current ONT count: ${currentOntCount}`;
      logWarn(errorMsg, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId,
        odpLabel: odp.label || 'unknown',
        maxAvailablePort: maxAvailablePort,
        currentOntCount: currentOntCount
      });
      throw new Error(errorMsg);
    }

    // Buat entity ONT dengan ObjectId baru
    const ontId = new ObjectId();
    const ont = createNetDeviceOntEntity({
      ...ontData,
      _id: ontId
    });
    
    // Path untuk update
    const odpPath = `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children.${odpIndex}.children`;
    
    logDebug(`Menambahkan ONT ke ODP menggunakan path: ${odpPath}`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      odpLabel: odp.label || 'unknown',
      branchId: branchId.toString(),
      ontId: ontId.toString()
    });
    
    // Update branch, tambahkan ONT ke ODP
    const result = await collection.updateOne(
      { _id: branchId },
      { 
        $push: { [odpPath]: ont },
        $set: { updatedAt: new Date() }
      }
    );
    
    if (result.matchedCount === 0) {
      logWarn(`Gagal menambahkan ONT ke ODP, branch tidak ditemukan`, {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId,
        branchId: branchId.toString()
      });
      return null;
    }
    
    logInfo(`ONT berhasil ditambahkan ke ODP`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      odpLabel: odp.label || 'unknown',
      ontId: ontId.toString(),
      ontLabel: ont.label
    });
    
    // Dapatkan data ODP yang telah diupdate
    return getOdpById(odpId);
  } catch (error) {
    const { logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    
    logError(`Error in addOntToOdp:`, {
      requestId: getRequestContext().getRequestId(),
      userId: getRequestContext().getUserId(),
      odpId: odpId,
      error: error.message,
      stack: error.stack
    });
    
    throw error;
  }
}

/**
 * Melakukan restore pada ODP yang telah di-soft delete
 * @param {string} odpId - ID ODP yang akan di-restore
 * @returns {Promise<Object|null>} - Hasil restore atau null jika ODP tidak ditemukan/tidak bisa di-restore
 */
async function restore(odpId) {
  try {
    const { logDebug, logInfo, logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    const context = getRequestContext();
    
    logDebug(`Mencoba restore ODP dengan ID: ${odpId}`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId
    });
    
    // Cari ODP yang memiliki deleted_at
    const odpInfo = await getOdpById(odpId, DeletedFilterTypes.ONLY);
    
    if (!odpInfo || !odpInfo.odp) {
      logDebug('ODP tidak ditemukan atau sudah di-restore', {
        requestId: context.getRequestId(),
        userId: context.getUserId(),
        odpId: odpId
      });
      return null;
    }
    
    // Lakukan restore
    logDebug('Memanggil fungsi restoreOdp', {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      odpLabel: odpInfo.odp.label || 'unknown'
    });
    
    const result = await restoreOdp(odpId);
    
    logInfo(`ODP berhasil di-restore`, {
      requestId: context.getRequestId(),
      userId: context.getUserId(),
      odpId: odpId,
      hasil: !!result
    });
    
    return result;
  } catch (error) {
    const { logError } = require('../services/logger.service');
    const { getRequestContext } = require('../services/requestContext.service');
    
    logError('Error in ODP repository - restore:', {
      requestId: getRequestContext().getRequestId(),
      userId: getRequestContext().getUserId(),
      odpId: odpId,
      error: error.message,
      stack: error.stack
    });
    
    throw error;
  }
}

module.exports = {
  getOdpById,
  getOdpDetailById,
  addOntToOdp,
  ResultTypes,
  restore
}; ###
cat src/repositories/netDeviceOlt.repository.js
/**
 * Repository untuk operasi pada collection branches terkait net device OLT
 */

const { getCollection } = require('./database.connector');
const { createNetDeviceOdcEntity } = require('../entities/netDeviceOdc.entity');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { DeletedFilterTypes } = require('./branch.repository');
const { restoreOlt } = require('../utils/recursiveRestore.util');

// Nama collection
const COLLECTION = 'branches';

// Enum untuk tipe result
const ResultTypes = {
  OLTS: 'OLTS',
  ODCS: 'ODCS',
  ODPS: 'ODPS'
};

/**
 * Mendapatkan OLT berdasarkan ID
 * @param {string} oltId - ID OLT
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object>} - Data OLT
 */
async function getOltById(oltId, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    console.log(`[getOltById] Mencari OLT dengan ID: ${oltId}, filter: ${deletedFilter}`);
    const collection = getCollection(COLLECTION);
    const objectId = new ObjectId(oltId);
    
    // Cari branch yang memiliki OLT dengan ID tertentu
    const branch = await collection.findOne({
      'children.children._id': objectId
    });
    
    console.log(`[getOltById] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;
    
    // Variabel untuk menyimpan indeks dan data
    let routerIndex = -1;
    let oltIndex = -1;
    let oltData = null;
    
    // Loop melalui branch > router > olt
    outerLoop: for (let i = 0; i < branch.children.length; i++) {
      const router = branch.children[i];
      
      if (router.children && Array.isArray(router.children)) {
        for (let j = 0; j < router.children.length; j++) {
          const olt = router.children[j];
          
          if (olt._id.toString() === oltId.toString()) {
            console.log(`[getOltById] OLT ditemukan dengan deleted_at: ${olt.deleted_at || 'tidak ada'}`);
            
            // Periksa filter
            if (deletedFilter === DeletedFilterTypes.ONLY && !olt.deleted_at) {
              console.log('[getOltById] OLT tidak memiliki deleted_at, tapi filter ONLY');
              continue;
            }
            if (deletedFilter === DeletedFilterTypes.WITHOUT && olt.deleted_at) {
              console.log('[getOltById] OLT memiliki deleted_at, tapi filter WITHOUT');
              continue;
            }
            
            routerIndex = i;
            oltIndex = j;
            oltData = olt;
            break outerLoop;
          }
        }
      }
    }
    
    // Jika OLT tidak ditemukan atau tidak memenuhi filter
    if (!oltData) {
      console.log('[getOltById] OLT tidak ditemukan atau tidak memenuhi filter');
      return null;
    }
    
    console.log('[getOltById] OLT berhasil ditemukan dan memenuhi filter');
    
    // Return objek dengan data OLT dan indeksnya
    return {
      olt: oltData,
      branchId: branch._id,
      routerIndex,
      oltIndex
    };
  } catch (error) {
    console.error('Error getting OLT by ID:', error);
    throw error;
  }
}

/**
 * Mendapatkan detail OLT berdasarkan ID dengan level detail tertentu
 * @param {string} oltId - ID OLT
 * @param {string} resultType - Tipe hasil (OLTS, ODCS, ODPS)
 * @returns {Promise<Object>} - Data OLT sesuai level detail
 */
async function getOltDetailById(oltId, resultType = null) {
  try {
    const oltInfo = await getOltById(oltId);
    
    if (!oltInfo || !oltInfo.olt) {
      return null;
    }
    
    // Ambil data OLT
    const olt = oltInfo.olt;
    
    // Jika resultType tidak dispesifikasikan, kembalikan data lengkap seperti biasa
    if (!resultType || !Object.values(ResultTypes).includes(resultType)) {
      return oltInfo;
    }
    
    // Filter data sesuai resultType
    const oltCopy = { ...olt };
    
    // OLTS: Hapus children dari setiap port di pon_port
    if (resultType === ResultTypes.OLTS) {
      if (oltCopy.pon_port && Array.isArray(oltCopy.pon_port)) {
        oltCopy.pon_port = oltCopy.pon_port.map(port => {
          const portCopy = { ...port };
          delete portCopy.children;
          return portCopy;
        });
      }
      return {
        ...oltInfo,
        olt: oltCopy
      };
    }
    
    // ODCS: Hapus children dari setiap tray di trays dari ODC
    if (resultType === ResultTypes.ODCS) {
      if (oltCopy.pon_port && Array.isArray(oltCopy.pon_port)) {
        oltCopy.pon_port = oltCopy.pon_port.map(port => {
          const portCopy = { ...port };
          
          if (portCopy.children && Array.isArray(portCopy.children)) {
            portCopy.children = portCopy.children.map(odc => {
              const odcCopy = { ...odc };
              
              // Tetap menyertakan trays tapi hapus children dari setiap tray
              if (odcCopy.trays && Array.isArray(odcCopy.trays)) {
                odcCopy.trays = odcCopy.trays.map(tray => {
                  const trayCopy = { ...tray };
                  delete trayCopy.children;
                  return trayCopy;
                });
              }
              
              return odcCopy;
            });
          }
          
          return portCopy;
        });
      }
      return {
        ...oltInfo,
        olt: oltCopy
      };
    }
    
    // ODPS: Hapus children dari setiap ODP
    if (resultType === ResultTypes.ODPS) {
      if (oltCopy.pon_port && Array.isArray(oltCopy.pon_port)) {
        oltCopy.pon_port = oltCopy.pon_port.map(port => {
          const portCopy = { ...port };
          
          if (portCopy.children && Array.isArray(portCopy.children)) {
            portCopy.children = portCopy.children.map(odc => {
              const odcCopy = { ...odc };
              
              if (odcCopy.trays && Array.isArray(odcCopy.trays)) {
                odcCopy.trays = odcCopy.trays.map(tray => {
                  const trayCopy = { ...tray };
                  
                  if (trayCopy.children && Array.isArray(trayCopy.children)) {
                    trayCopy.children = trayCopy.children.map(odp => {
                      const odpCopy = { ...odp };
                      delete odpCopy.children;
                      return odpCopy;
                    });
                  }
                  
                  return trayCopy;
                });
              }
              
              return odcCopy;
            });
          }
          
          return portCopy;
        });
      }
      return {
        ...oltInfo,
        olt: oltCopy
      };
    }
    
    return oltInfo;
  } catch (error) {
    console.error(`Error getting OLT detail with ID ${oltId}:`, error);
    throw error;
  }
}

/**
 * Menambahkan ODC ke OLT berdasarkan ID OLT pada port tertentu
 * @param {string} oltId - ID OLT
 * @param {Object} odcData - Data ODC yang akan ditambahkan
 * @returns {Promise<Object>} - Data OLT yang sudah diupdate dengan ODC baru di port tertentu
 */
async function addOdcToOlt(oltId, odcData) {
  try {
    const collection = getCollection(COLLECTION);
    
    // Dapatkan informasi OLT
    const oltInfo = await getOltById(oltId);
    if (!oltInfo || !oltInfo.olt) {
      return null;
    }
    
    const { olt, branchId, routerIndex, oltIndex } = oltInfo;
    
    // Cari port yang sesuai dengan pon_port
    const ponPortIndex = olt.pon_port.findIndex(port => port.port === odcData.pon_port);
    if (ponPortIndex === -1) {
      throw new Error(`Port ${odcData.pon_port} not found on OLT ${oltId}`);
    }
    
    // Buat trays berdasarkan available_tray dan cores_per_tray
    const trays = [];
    const availableTray = odcData.available_tray || 0;
    const coresPerTray = odcData.cores_per_tray || 0;
    
    for (let i = 0; i < availableTray; i++) {
      trays.push({
        tray: i + 1,
        start_core: 1 + (coresPerTray * i),
        end_core: coresPerTray * (i + 1),
        children: []
      });
    }
    
    // Hapus properti pon_port dan cores_per_tray dari data
    delete odcData.pon_port;
    delete odcData.cores_per_tray;
    
    // Buat entity ODC dengan ObjectId baru
    const odcId = new ObjectId();
    const odc = createNetDeviceOdcEntity({
      ...odcData,
      _id: odcId,
      trays
    });
    
    // Path untuk update
    const oltPath = `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children`;
    
    // Update branch, tambahkan ODC ke port OLT
    const result = await collection.updateOne(
      { _id: branchId },
      { 
        $push: { [oltPath]: odc },
        $set: { updatedAt: new Date() }
      }
    );
    
    if (result.matchedCount === 0) {
      return null;
    }
    
    // Dapatkan OLT yang sudah diupdate
    return getOltById(oltId);
  } catch (error) {
    console.error(`Error adding ODC to OLT with ID ${oltId}:`, error);
    throw error;
  }
}

/**
 * Melakukan restore pada OLT yang telah di-soft delete
 * @param {string} oltId - ID OLT yang akan di-restore
 * @returns {Promise<Object|null>} - Hasil restore atau null jika OLT tidak ditemukan/tidak bisa di-restore
 */
async function restore(oltId) {
  try {
    console.log(`[restore] Mencoba restore OLT dengan ID: ${oltId}`);
    
    // Cari OLT yang memiliki deleted_at
    const oltInfo = await getOltById(oltId, DeletedFilterTypes.ONLY);
    console.log(`[restore] Status pencarian OLT yang dihapus:`, oltInfo);
    
    if (!oltInfo || !oltInfo.olt) {
      console.log('[restore] OLT tidak ditemukan atau sudah di-restore');
      return null;
    }
    
    // Lakukan restore
    console.log('[restore] Memanggil fungsi restoreOlt');
    const result = await restoreOlt(oltId);
    console.log(`[restore] Hasil restore:`, result);
    
    return result;
  } catch (error) {
    console.error('Error in OLT repository - restore:', error);
    throw error;
  }
}

module.exports = {
  getOltById,
  getOltDetailById,
  addOdcToOlt,
  restore,
  ResultTypes
}; ###
cat src/repositories/netDeviceOnt.repository.js
/**
 * Repository untuk operasi pada collection branches terkait net device ONT
 */

const { getCollection } = require('./database.connector');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { DeletedFilterTypes } = require('./branch.repository');
const { recursiveDeletedCheck } = require('../utils/recursiveDeletedCheck.util');

// Nama collection
const COLLECTION = 'branches';

/**
 * Mendapatkan ONT berdasarkan ID
 * @param {string} ontId - ID ONT
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object|null>} ONT yang ditemukan atau null
 */
async function getOntById(ontId, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    console.log(`[getOntById] Mencari ONT dengan ID: ${ontId}, filter: ${deletedFilter}`);
    
    const collection = getCollection(COLLECTION);
    
    // Cari branch yang memiliki ONT dengan ID yang sesuai
    const query = {
      $or: [
        { 'children.children.pon_port.children.trays.children.children.children._id': new ObjectId(ontId) },
        { 'children.children.pon_port.children.trays.children.children._id': new ObjectId(ontId) }
      ]
    };
    
    console.log('[getOntById] Query MongoDB:', JSON.stringify(query, null, 2));
    
    const branch = await collection.findOne(query);
    
    console.log(`[getOntById] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;

    // Cari ONT dalam struktur nested
    let foundOnt = null;
    const searchOnt = (obj) => {
      // Log untuk debugging
      if (obj._id) {
        console.log(`[searchOnt] Memeriksa object dengan ID: ${obj._id.toString()}`);
      }
      
      if (obj._id && obj._id.toString() === ontId.toString()) {
        console.log('[searchOnt] ONT ditemukan!');
        foundOnt = { ...obj };
        return;
      }
      
      // Cek children
      if (obj.children && Array.isArray(obj.children)) {
        obj.children.forEach(child => searchOnt(child));
      }
      
      // Cek pon_port dan children-nya
      if (obj.pon_port && Array.isArray(obj.pon_port)) {
        obj.pon_port.forEach(port => {
          if (port.children) {
            port.children.forEach(child => searchOnt(child));
          }
        });
      }
      
      // Cek trays dan children-nya
      if (obj.trays && Array.isArray(obj.trays)) {
        obj.trays.forEach(tray => {
          if (tray.children) {
            tray.children.forEach(child => searchOnt(child));
          }
        });
      }
    };

    searchOnt(branch);
    
    console.log(`[getOntById] ONT ditemukan setelah pencarian: ${foundOnt ? 'Ya' : 'Tidak'}`);
    
    // Jika ONT tidak ditemukan
    if (!foundOnt) {
      console.log('[getOntById] ONT tidak ditemukan setelah pencarian mendalam');
      return null;
    }

    // Log status deleted
    console.log(`[getOntById] Status deleted_at ONT: ${foundOnt.deleted_at ? 'Ada' : 'Tidak ada'}`);
    
    // Terapkan filter deleted
    if (deletedFilter === DeletedFilterTypes.ONLY && !foundOnt.deleted_at) {
      console.log('[getOntById] ONT tidak memiliki deleted_at, tapi filter ONLY');
      return null;
    }
    if (deletedFilter === DeletedFilterTypes.WITHOUT && foundOnt.deleted_at) {
      console.log('[getOntById] ONT memiliki deleted_at, tapi filter WITHOUT');
      return null;
    }
    
    console.log('[getOntById] ONT berhasil ditemukan dan memenuhi filter');
    return foundOnt;
  } catch (error) {
    console.error('Error getting ONT by ID:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada ONT berdasarkan ID
 * @param {string} ontId - ID ONT
 * @returns {Promise<Object>} - ONT yang sudah di-soft delete
 */
async function softDeleteOnt(ontId) {
  try {
    console.log(`[softDeleteOnt] Mencoba soft delete ONT dengan ID: ${ontId}`);
    
    // Dapatkan informasi ONT
    const ont = await getOntById(ontId, DeletedFilterTypes.WITHOUT);
    if (!ont) {
      console.log('[softDeleteOnt] ONT tidak ditemukan atau sudah dihapus');
      return null;
    }

    const collection = getCollection(COLLECTION);
    
    // Update ONT menggunakan array filters
    const result = await collection.updateOne(
      {
        $or: [
          { 'children.children.pon_port.children.trays.children.children.children._id': new ObjectId(ontId) },
          { 'children.children.pon_port.children.trays.children.children._id': new ObjectId(ontId) }
        ]
      },
      {
        $set: {
          'children.$[].children.$[].pon_port.$[].children.$[].trays.$[].children.$[].children.$[ont].deleted_at': new Date(),
          updatedAt: new Date()
        }
      },
      {
        arrayFilters: [
          { 'ont._id': new ObjectId(ontId) }
        ]
      }
    );

    console.log(`[softDeleteOnt] Update result: matchedCount=${result.matchedCount}, modifiedCount=${result.modifiedCount}`);
    
    if (result.modifiedCount === 0) {
      console.log('[softDeleteOnt] Gagal melakukan soft delete ONT');
      return null;
    }

    // Dapatkan ONT yang sudah diupdate (dengan WITH filter karena sudah di-soft delete)
    const updatedOnt = await getOntById(ontId, DeletedFilterTypes.WITH);
    console.log('[softDeleteOnt] ONT berhasil di-soft delete');
    
    return updatedOnt;
  } catch (error) {
    console.error('Error soft deleting ONT:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada ONT yang sudah di-soft delete
 * @param {string} ontId - ID ONT yang akan di-restore
 * @returns {Promise<Object|null>} ONT yang sudah di-restore atau null jika tidak ditemukan
 */
async function restoreOnt(ontId) {
  try {
    console.log(`[restoreOnt] Mencoba restore ONT dengan ID: ${ontId}`);
    
    const collection = getCollection(COLLECTION);
    
    // Cari ONT yang memiliki deleted_at
    const ont = await getOntById(ontId, DeletedFilterTypes.ONLY);
    console.log(`[restoreOnt] ONT ditemukan dengan filter ONLY: ${ont ? 'Ya' : 'Tidak'}`);
    
    if (!ont) {
      console.log('[restoreOnt] ONT tidak ditemukan atau sudah di-restore');
      return null;
    }

    // Update ONT dengan menghapus field deleted_at menggunakan array filters
    const result = await collection.updateOne(
      {
        $or: [
          { 'children.children.pon_port.children.trays.children.children.children._id': new ObjectId(ontId) },
          { 'children.children.pon_port.children.trays.children.children._id': new ObjectId(ontId) }
        ]
      },
      {
        $unset: {
          'children.$[].children.$[].pon_port.$[].children.$[].trays.$[].children.$[].children.$[ont].deleted_at': ""
        },
        $set: {
          updatedAt: new Date()
        }
      },
      {
        arrayFilters: [
          { 'ont._id': new ObjectId(ontId) }
        ]
      }
    );

    console.log(`[restoreOnt] Update result: matchedCount=${result.matchedCount}, modifiedCount=${result.modifiedCount}`);

    if (result.modifiedCount === 0) {
      console.log('[restoreOnt] Gagal melakukan restore ONT');
      return null;
    }

    // Ambil data ONT yang sudah di-restore
    const restoredOnt = await getOntById(ontId, DeletedFilterTypes.WITHOUT);
    console.log('[restoreOnt] ONT berhasil di-restore');
    
    return restoredOnt;
  } catch (error) {
    console.error('Error restoring ONT:', error);
    throw error;
  }
}

module.exports = {
  getOntById,
  softDeleteOnt,
  restoreOnt
}; ###
cat src/repositories/netDeviceRouter.repository.js
/**
 * Repository untuk operasi pada collection branches terkait net device router
 */

const { getCollection } = require('./database.connector');
const { createNetDeviceOltEntity } = require('../entities/netDeviceOlt.entity');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;
const { DeletedFilterTypes } = require('./branch.repository');
const { restoreRouter } = require('../utils/recursiveRestore.util');

// Nama collection
const COLLECTION = 'branches';

// Enum untuk tipe result
const ResultTypes = {
  ROUTERS: 'ROUTERS',
  OLTS: 'OLTS',
  ODCS: 'ODCS',
  ODPS: 'ODPS'
};

/**
 * Mendapatkan Router berdasarkan ID
 * @param {string} routerId - ID Router
 * @param {string} deletedFilter - Filter data yang dihapus (ONLY, WITH, WITHOUT)
 * @returns {Promise<Object>} - Data Router
 */
async function getRouterById(routerId, deletedFilter = DeletedFilterTypes.WITHOUT) {
  try {
    console.log(`[getRouterById] Mencari Router dengan ID: ${routerId}, filter: ${deletedFilter}`);
    const collection = getCollection(COLLECTION);
    const objectId = new ObjectId(routerId);
    
    // Cari branch yang memiliki Router dengan ID tertentu
    const branch = await collection.findOne({
      'children._id': objectId
    });
    
    console.log(`[getRouterById] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;
    
    // Variabel untuk menyimpan indeks dan data
    let routerIndex = -1;
    let routerData = null;
    
    // Loop melalui branch > router
    for (let i = 0; i < branch.children.length; i++) {
      const router = branch.children[i];
      
      if (router._id.toString() === routerId.toString()) {
        console.log(`[getRouterById] Router ditemukan dengan deleted_at: ${router.deleted_at || 'tidak ada'}`);
        
        // Periksa filter
        if (deletedFilter === DeletedFilterTypes.ONLY && !router.deleted_at) {
          console.log('[getRouterById] Router tidak memiliki deleted_at, tapi filter ONLY');
          continue;
        }
        if (deletedFilter === DeletedFilterTypes.WITHOUT && router.deleted_at) {
          console.log('[getRouterById] Router memiliki deleted_at, tapi filter WITHOUT');
          continue;
        }
        
        routerIndex = i;
        routerData = router;
        break;
      }
    }
    
    // Jika Router tidak ditemukan atau tidak memenuhi filter
    if (!routerData) {
      console.log('[getRouterById] Router tidak ditemukan atau tidak memenuhi filter');
      return null;
    }
    
    console.log('[getRouterById] Router berhasil ditemukan dan memenuhi filter');
    
    // Return objek dengan data Router dan indeksnya
    return {
      router: routerData,
      branchId: branch._id,
      routerIndex
    };
  } catch (error) {
    console.error('Error getting Router by ID:', error);
    throw error;
  }
}

/**
 * Menambahkan OLT ke Router
 * @param {string} routerId - ID Router
 * @param {Object} oltData - Data OLT yang akan ditambahkan
 * @returns {Promise<Object>} - Data Router yang sudah diupdate dengan OLT baru
 */
async function addOltToRouter(routerId, oltData) {
  try {
    const collection = getCollection(COLLECTION);
    
    // Dapatkan informasi Router
    const routerInfo = await getRouterById(routerId);
    if (!routerInfo || !routerInfo.router) {
      return null;
    }
    
    const { router, branchId, routerIndex } = routerInfo;
    
    // Buat entity OLT dengan ObjectId baru
    const oltId = new ObjectId();
    const olt = createNetDeviceOltEntity({
      ...oltData,
      _id: oltId
    });
    
    // Update branch, tambahkan OLT ke Router
    const result = await collection.updateOne(
      { _id: branchId },
      { 
        $push: { [`children.${routerIndex}.children`]: olt },
        $set: { updatedAt: new Date() }
      }
    );
    
    if (result.matchedCount === 0) {
      return null;
    }
    
    // Dapatkan Router yang sudah diupdate
    return getRouterById(routerId);
  } catch (error) {
    console.error(`Error adding OLT to Router with ID ${routerId}:`, error);
    throw error;
  }
}

/**
 * Melakukan restore pada Router yang telah di-soft delete
 * @param {string} routerId - ID Router yang akan di-restore
 * @returns {Promise<Object|null>} - Hasil restore atau null jika Router tidak ditemukan/tidak bisa di-restore
 */
async function restore(routerId) {
  try {
    console.log(`[restore] Mencoba restore Router dengan ID: ${routerId}`);
    
    // Cari Router yang memiliki deleted_at
    const routerInfo = await getRouterById(routerId, DeletedFilterTypes.ONLY);
    console.log(`[restore] Status pencarian Router yang dihapus:`, routerInfo);
    
    if (!routerInfo || !routerInfo.router) {
      console.log('[restore] Router tidak ditemukan atau sudah di-restore');
      return null;
    }
    
    // Lakukan restore
    console.log('[restore] Memanggil fungsi restoreRouter');
    const result = await restoreRouter(routerId);
    console.log(`[restore] Hasil restore:`, result);
    
    return result;
  } catch (error) {
    console.error('Error in Router repository - restore:', error);
    throw error;
  }
}

module.exports = {
  getRouterById,
  addOltToRouter,
  restore,
  ResultTypes
}; ###
cat src/entities/address.entity.js
/**
 * Entity untuk address (alamat)
 */

/**
 * Fungsi untuk membuat objek address
 * @param {Object} data - Data alamat
 * @returns {Object} - Objek address
 */
function createAddressEntity(data = {}) {
  return {
    country: data.country || 'ID', // Default Indonesia
    province: data.province || '',
    city: data.city || '',
    district: data.district || '',
    village: data.village || '',
    detail: data.detail || '',
    zip_code: data.zip_code || ''
  };
}

/**
 * Fungsi untuk memvalidasi data address
 * @param {Object} data - Data address
 * @returns {boolean} - True jika valid
 */
function validateAddressEntity(data) {
  if (!data) {
    return false;
  }
  
  // Validasi country (harus ada dan string)
  if (!data.country || typeof data.country !== 'string') {
    return false;
  }
  
  // Validasi tipe data
  const stringFields = ['province', 'city', 'district', 'village', 'detail', 'zip_code'];
  for (const field of stringFields) {
    if (data[field] && typeof data[field] !== 'string') {
      return false;
    }
  }
  
  return true;
}

module.exports = {
  createAddressEntity,
  validateAddressEntity
}; ###
cat src/entities/branch.entity.js
/**
 * Entity untuk branch (cabang)
 */

const { createLocationEntity, validateLocationEntity } = require('./location.entity');
const { createAddressEntity, validateAddressEntity } = require('./address.entity');
const { createContactEntity, validateContactEntity } = require('./contact.entity');
const { validateNetDeviceRouterEntity } = require('./netDeviceRouter.entity');

/**
 * Fungsi untuk membuat objek branch
 * @param {Object} data - Data branch
 * @returns {Object} - Objek branch
 */
function createBranchEntity(data = {}) {
  return {
    _id: data._id || null,
    name: data.name || '',
    location: data.location ? createLocationEntity(data.location) : createLocationEntity(),
    address: data.address ? createAddressEntity(data.address) : createAddressEntity(),
    contact: data.contact ? createContactEntity(data.contact) : createContactEntity(),
    children: data.children || [],
    createdAt: data.createdAt || new Date(),
    updatedAt: data.updatedAt || new Date()
  };
}

/**
 * Fungsi untuk memvalidasi data branch
 * @param {Object} data - Data branch
 * @returns {boolean} - True jika valid
 */
function validateBranchEntity(data) {
  if (!data.name || typeof data.name !== 'string') {
    return false;
  }
  
  if (data.name.length < 3 || data.name.length > 64) {
    return false;
  }
  
  // Validasi location jika ada
  if (data.location && !validateLocationEntity(data.location)) {
    return false;
  }
  
  // Validasi address jika ada
  if (data.address && !validateAddressEntity(data.address)) {
    return false;
  }
  
  // Validasi contact jika ada
  if (data.contact && !validateContactEntity(data.contact)) {
    return false;
  }
  
  // Validasi children jika ada
  if (data.children) {
    if (!Array.isArray(data.children)) {
      return false;
    }
    
    // Validasi setiap item dalam children harus berupa netDeviceRouter
    for (const child of data.children) {
      if (!validateNetDeviceRouterEntity(child)) {
        return false;
      }
    }
  }
  
  return true;
}

module.exports = {
  createBranchEntity,
  validateBranchEntity
};
###
cat src/entities/branchAccess.entity.js
const { ObjectId } = require('mongodb');

/**
 * @typedef {Object} BranchAccess
 * @property {ObjectId} _id - ID dari dokumen branch access
 * @property {ObjectId} branch_id - ID dari branch yang diakses
 * @property {string} user_id - UUID dari user yang memiliki akses
 * @property {('R'|'RW')} permission - Tipe akses: R (read) atau RW (read-write)
 */

/**
 * Membuat objek BranchAccess baru
 * @param {Object} data - Data untuk membuat BranchAccess
 * @param {string|ObjectId} data.branch_id - ID dari branch
 * @param {string} data.user_id - UUID dari user
 * @param {string} data.permission - Tipe akses (R/RW)
 * @returns {BranchAccess}
 */
function createBranchAccess(data) {
  return {
    _id: new ObjectId(),
    branch_id: typeof data.branch_id === 'string' ? new ObjectId(data.branch_id) : data.branch_id,
    user_id: data.user_id,
    permission: data.permission
  };
}

/**
 * Memvalidasi data BranchAccess
 * @param {Object} data - Data yang akan divalidasi
 * @throws {Error} Jika validasi gagal
 */
function validateBranchAccess(data) {
  if (!data.branch_id) {
    throw new Error('branch_id is required');
  }
  if (!data.user_id) {
    throw new Error('user_id is required');
  }
  if (!data.permission || !['R', 'RW'].includes(data.permission)) {
    throw new Error('permission must be either R or RW');
  }
}

module.exports = {
  createBranchAccess,
  validateBranchAccess
}; ###
cat src/entities/contact.entity.js
/**
 * Entity untuk contact (kontak)
 */

/**
 * Fungsi untuk membuat objek contact
 * @param {Object} data - Data kontak
 * @returns {Object} - Objek contact
 */
function createContactEntity(data = {}) {
  return {
    email: data.email || '',
    phone: data.phone || ''
  };
}

/**
 * Fungsi untuk memvalidasi data contact
 * @param {Object} data - Data contact
 * @returns {boolean} - True jika valid
 */
function validateContactEntity(data) {
  if (!data) {
    return false;
  }
  
  // Validasi email jika ada
  if (data.email) {
    if (typeof data.email !== 'string') {
      return false;
    }
    
    // Simple email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(data.email)) {
      return false;
    }
  }
  
  // Validasi phone jika ada
  if (data.phone) {
    if (typeof data.phone !== 'string') {
      return false;
    }
    
    // Simple phone validation (at least 8 digits)
    const phoneRegex = /^\+?[0-9]{8,15}$/;
    if (!phoneRegex.test(data.phone)) {
      return false;
    }
  }
  
  return true;
}

module.exports = {
  createContactEntity,
  validateContactEntity
}; ###
cat src/entities/location.entity.js
/**
 * Entity untuk location (lokasi) menggunakan format GeoJSON Point
 */

/**
 * Fungsi untuk membuat objek location
 * @param {Object} data - Data lokasi
 * @returns {Object} - Objek location dalam format GeoJSON Point
 */
function createLocationEntity(data = {}) {
  return {
    type: data.type || "Point",
    coordinates: data.coordinates || [0, 0] // [longitude, latitude]
  };
}

/**
 * Fungsi untuk memvalidasi data location
 * @param {Object} data - Data location
 * @returns {boolean} - True jika valid
 */
function validateLocationEntity(data) {
  if (!data || !data.type || !data.coordinates) {
    return false;
  }
  
  if (data.type !== "Point") {
    return false;
  }
  
  if (!Array.isArray(data.coordinates) || data.coordinates.length !== 2) {
    return false;
  }
  
  // Validasi longitude (-180 sampai 180)
  if (typeof data.coordinates[0] !== 'number' || 
      data.coordinates[0] < -180 || 
      data.coordinates[0] > 180) {
    return false;
  }
  
  // Validasi latitude (-90 sampai 90)
  if (typeof data.coordinates[1] !== 'number' || 
      data.coordinates[1] < -90 || 
      data.coordinates[1] > 90) {
    return false;
  }
  
  return true;
}

module.exports = {
  createLocationEntity,
  validateLocationEntity
}; ###
cat src/entities/log.entity.js
/**
 * Entity untuk log
 */

const { generateUUID } = require('../utils/uuid.util');

/**
 * Membuat log entity
 * @param {Object} logData - Data log yang akan dibuat
 * @returns {Object} Log entity
 */
function createLogEntity(logData) {
  const now = new Date();
  
  return {
    _id: generateUUID(),
    timestamp: now.toISOString(),
    level: logData.level,
    message: logData.message,
    context: {
      service: 'infrastructure-service',
      environment: process.env.NODE_ENV || 'development',
      requestId: logData.requestId,
      userId: logData.userId,
      method: logData.method,
      url: logData.url,
      statusCode: logData.statusCode,
      responseTime: logData.responseTime,
      userAgent: logData.userAgent,
      ip: logData.ip
    },
    metadata: logData.metadata || {},
    labels: {
      type: logData.type || 'application',
      component: logData.component || 'general'
    },
    createdAt: now,
    updatedAt: now
  };
}

module.exports = {
  createLogEntity
}; ###
cat src/entities/netDevice.entity.js
/**
 * Entity untuk netDevice (perangkat jaringan)
 */

const { createLocationEntity, validateLocationEntity } = require('./location.entity');
const { createAddressEntity, validateAddressEntity } = require('./address.entity');

/**
 * Fungsi untuk membuat objek netDevice
 * @param {Object} data - Data perangkat jaringan
 * @returns {Object} - Objek netDevice
 */
function createNetDeviceEntity(data = {}) {
  return {
    _id: data._id || null,
    label: data.label || '',
    type: data.type || '',
    location: data.location ? createLocationEntity(data.location) : createLocationEntity(),
    address: data.address ? createAddressEntity(data.address) : createAddressEntity(),
    createdAt: data.createdAt || new Date(),
    updatedAt: data.updatedAt || new Date()
  };
}

/**
 * Fungsi untuk memvalidasi data netDevice
 * @param {Object} data - Data netDevice
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceEntity(data) {
  if (!data.label || typeof data.label !== 'string') {
    return false;
  }
  
  if (!data.type || typeof data.type !== 'string') {
    return false;
  }
  
  // Validasi location jika ada
  if (data.location && !validateLocationEntity(data.location)) {
    return false;
  }
  
  // Validasi address jika ada
  if (data.address && !validateAddressEntity(data.address)) {
    return false;
  }
  
  return true;
}

module.exports = {
  createNetDeviceEntity,
  validateNetDeviceEntity
};
###
cat src/entities/netDeviceConn.entity.js
/**
 * Entity untuk berbagai jenis koneksi perangkat jaringan
 * File ini berisi definisi entity untuk koneksi telnet, ssh, dan snmp
 */

/**
 * Fungsi untuk validasi alamat IP v4
 * @param {string} ip - Alamat IP yang akan divalidasi
 * @returns {boolean} - True jika valid
 */
function isValidIPv4(ip) {
  if (typeof ip !== 'string') return false;
  
  // Pola IPv4: xxx.xxx.xxx.xxx
  const pattern = /^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  return pattern.test(ip);
}

/**
 * Fungsi untuk validasi port yang valid
 * @param {number} port - Nomor port yang akan divalidasi
 * @returns {boolean} - True jika valid
 */
function isValidPort(port) {
  return Number.isInteger(port) && port > 0 && port <= 65535;
}

/**
 * Fungsi untuk membuat objek koneksi telnet
 * @param {Object} data - Data koneksi telnet
 * @returns {Object} - Objek koneksi telnet
 */
function createTelnetConnEntity(data = {}) {
  return {
    ip_addr: data.ip_addr || '',
    port: data.port || 23, // Default telnet port
    username: data.username || '',
    password: data.password || ''
  };
}

/**
 * Fungsi untuk validasi koneksi telnet
 * @param {Object} data - Data koneksi telnet
 * @returns {boolean} - True jika valid
 */
function validateTelnetConnEntity(data) {
  if (!isValidIPv4(data.ip_addr)) {
    return false;
  }

  if (!isValidPort(data.port)) {
    return false;
  }

  if (typeof data.username !== 'string') {
    return false;
  }

  if (typeof data.password !== 'string') {
    return false;
  }

  return true;
}

/**
 * Fungsi untuk membuat objek koneksi SSH
 * @param {Object} data - Data koneksi SSH
 * @returns {Object} - Objek koneksi SSH
 */
function createSshConnEntity(data = {}) {
  return {
    ip_addr: data.ip_addr || '',
    port: data.port || 22, // Default SSH port
    username: data.username || '',
    password: data.password || ''
  };
}

/**
 * Fungsi untuk validasi koneksi SSH
 * @param {Object} data - Data koneksi SSH
 * @returns {boolean} - True jika valid
 */
function validateSshConnEntity(data) {
  if (!isValidIPv4(data.ip_addr)) {
    return false;
  }

  if (!isValidPort(data.port)) {
    return false;
  }

  if (typeof data.username !== 'string') {
    return false;
  }

  if (typeof data.password !== 'string') {
    return false;
  }

  return true;
}

/**
 * Fungsi untuk membuat objek koneksi SNMP
 * @param {Object} data - Data koneksi SNMP
 * @returns {Object} - Objek koneksi SNMP
 */
function createSnmpConnEntity(data = {}) {
  return {
    ip_addr: data.ip_addr || '',
    port: data.port || 161, // Default SNMP port
    community_read: data.community_read || 'public',
    community_write: data.community_write || 'private'
  };
}

/**
 * Fungsi untuk validasi koneksi SNMP
 * @param {Object} data - Data koneksi SNMP
 * @returns {boolean} - True jika valid
 */
function validateSnmpConnEntity(data) {
  if (!isValidIPv4(data.ip_addr)) {
    return false;
  }

  if (!isValidPort(data.port)) {
    return false;
  }

  if (typeof data.community_read !== 'string') {
    return false;
  }

  if (typeof data.community_write !== 'string') {
    return false;
  }

  return true;
}

module.exports = {
  createTelnetConnEntity,
  validateTelnetConnEntity,
  createSshConnEntity,
  validateSshConnEntity,
  createSnmpConnEntity,
  validateSnmpConnEntity,
  isValidIPv4,
  isValidPort
}; ###
cat src/entities/netDeviceOdc.entity.js
/**
 * Entity untuk netDeviceOdc (perangkat Optical Distribution Cabinet)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Fungsi untuk memeriksa tipe anak yang valid untuk ODC Tray
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidTrayChild(child) {
  // Hanya menerima netDeviceOdp
  return child && child.type && child.type === 'odp';
}

/**
 * Fungsi untuk membuat objek Tray ODC
 * @param {Object} data - Data tray
 * @returns {Object} - Objek tray
 */
function createOdcTrayEntity(data = {}) {
  return {
    tray: data.tray || 1,
    start_core: data.start_core || 1,
    end_core: data.end_core || 1,
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data tray ODC
 * @param {Object} data - Data tray
 * @param {Array} existingTrays - Array tray yang sudah ada (untuk validasi keunikan)
 * @returns {boolean} - True jika valid
 */
function validateOdcTrayEntity(data, existingTrays = []) {
  // Validasi tray number (harus integer dan dimulai dari 1)
  if (typeof data.tray !== 'number' || !Number.isInteger(data.tray) || data.tray < 1) {
    return false;
  }
  
  // Validasi keunikan tray number
  if (existingTrays.some(t => t.tray === data.tray)) {
    return false;
  }
  
  // Validasi start_core (harus integer)
  if (typeof data.start_core !== 'number' || !Number.isInteger(data.start_core) || data.start_core < 1) {
    return false;
  }
  
  // Validasi end_core (harus integer dan >= start_core)
  if (typeof data.end_core !== 'number' || !Number.isInteger(data.end_core) || data.end_core < data.start_core) {
    return false;
  }
  
  // Validasi children
  if (!Array.isArray(data.children)) {
    return false;
  }
  
  // Validasi setiap anak, pastikan tipenya adalah ODP
  for (const child of data.children) {
    if (!isValidTrayChild(child)) {
      return false;
    }
  }
  
  return true;
}

/**
 * Fungsi untuk membuat objek netDeviceOdc
 * @param {Object} data - Data ODC
 * @returns {Object} - Objek netDeviceOdc
 */
function createNetDeviceOdcEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'odc'
  });
  
  // Buat array trays jika ada
  const trays = [];
  if (Array.isArray(data.trays)) {
    data.trays.forEach(trayData => {
      trays.push(createOdcTrayEntity(trayData));
    });
  }
  
  // Tambahkan properti khusus ODC
  return {
    ...baseEntity,
    available_tray: data.available_tray || 0,
    trays: trays
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOdc
 * @param {Object} data - Data ODC
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOdcEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'odc'})) {
    return false;
  }
  
  // Validasi available_tray
  if (typeof data.available_tray !== 'number' || !Number.isInteger(data.available_tray) || data.available_tray < 0) {
    return false;
  }
  
  // Validasi trays
  if (data.trays) {
    if (!Array.isArray(data.trays)) {
      return false;
    }
    
    const existingTrays = [];
    for (const tray of data.trays) {
      if (!validateOdcTrayEntity(tray, existingTrays)) {
        return false;
      }
      existingTrays.push(tray);
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceOdcEntity,
  validateNetDeviceOdcEntity,
  createOdcTrayEntity,
  validateOdcTrayEntity
};
###
cat src/entities/netDeviceOdp.entity.js
/**
 * Entity untuk netDeviceOdp (perangkat Optical Distribution Point)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Fungsi untuk memeriksa tipe anak yang valid untuk ODP
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidChild(child) {
  // Hanya menerima netDeviceOnt
  return child && child.type && child.type === 'ont';
}

/**
 * Fungsi untuk membuat objek netDeviceOdp
 * @param {Object} data - Data ODP
 * @returns {Object} - Objek netDeviceOdp
 */
function createNetDeviceOdpEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'odp'
  });
  
  // Tambahkan properti khusus ODP
  return {
    ...baseEntity,
    core_on_odc_tray: data.core_on_odc_tray || 1,
    available_port: data.available_port || 0,
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOdp
 * @param {Object} data - Data ODP
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOdpEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'odp'})) {
    return false;
  }
  
  // Validasi core_on_odc_tray (harus integer dan dimulai dari 1)
  if (typeof data.core_on_odc_tray !== 'number' || !Number.isInteger(data.core_on_odc_tray) || data.core_on_odc_tray < 1) {
    return false;
  }
  
  // Validasi available_port (harus integer lebih besar dari 0)
  if (typeof data.available_port !== 'number' || !Number.isInteger(data.available_port) || data.available_port < 0) {
    return false;
  }
  
  // Validasi children
  if (data.children) {
    if (!Array.isArray(data.children)) {
      return false;
    }
    
    // Validasi setiap anak, pastikan tipenya adalah ONT
    for (const child of data.children) {
      if (!isValidChild(child)) {
        return false;
      }
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceOdpEntity,
  validateNetDeviceOdpEntity
};
###
cat src/entities/netDeviceOlt.entity.js
/**
 * Entity untuk netDeviceOlt (perangkat Optical Line Terminal)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');
const { 
  createTelnetConnEntity, validateTelnetConnEntity,
  createSshConnEntity, validateSshConnEntity,
  createSnmpConnEntity, validateSnmpConnEntity
} = require('./netDeviceConn.entity');

/**
 * Enum untuk tipe PON
 * @enum {string}
 */
const PonTypes = {
  GPON: 'GPON',
  EPON: 'EPON'
};

/**
 * Fungsi untuk memeriksa tipe anak yang valid untuk port PON
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidPortChild(child) {
  // Hanya menerima netDeviceOdc
  return child && child.type && child.type === 'odc';
}

/**
 * Fungsi untuk membuat objek PON port
 * @param {Object} data - Data port PON
 * @returns {Object} - Objek port PON
 */
function createPonPortEntity(data = {}) {
  return {
    port: data.port || 1,
    max_client: data.max_client || 1,
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data PON port
 * @param {Object} data - Data port PON
 * @param {Array} existingPorts - Array port yang sudah ada (untuk validasi keunikan)
 * @returns {boolean} - True jika valid
 */
function validatePonPortEntity(data, existingPorts = []) {
  // Validasi port number (harus integer dan dimulai dari 1)
  if (typeof data.port !== 'number' || !Number.isInteger(data.port) || data.port < 1) {
    return false;
  }
  
  // Validasi keunikan port number
  if (existingPorts.some(p => p.port === data.port)) {
    return false;
  }
  
  // Validasi max_client (harus integer lebih besar dari 0)
  if (typeof data.max_client !== 'number' || !Number.isInteger(data.max_client) || data.max_client < 1) {
    return false;
  }
  
  // Validasi children
  if (!Array.isArray(data.children)) {
    return false;
  }
  
  // Validasi setiap anak, pastikan tipenya adalah ODC
  for (const child of data.children) {
    if (!isValidPortChild(child)) {
      return false;
    }
  }
  
  return true;
}

/**
 * Fungsi untuk membuat objek netDeviceOlt
 * @param {Object} data - Data OLT
 * @returns {Object} - Objek netDeviceOlt
 */
function createNetDeviceOltEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'olt'
  });
  
  // Buat array pon_port berdasarkan available_pon
  const ponPorts = [];
  const availablePon = data.available_pon || 0;
  
  // Jika available_pon ada, buat port sejumlah available_pon
  if (availablePon > 0) {
    for (let i = 1; i <= availablePon; i++) {
      ponPorts.push(createPonPortEntity({
        port: i,
        max_client: 64, // Default max client untuk GPON
        children: []
      }));
    }
  } 
  // Jika pon_port sudah ada di data, gunakan itu
  else if (Array.isArray(data.pon_port)) {
    data.pon_port.forEach(portData => {
      ponPorts.push(createPonPortEntity(portData));
    });
  }
  
  // Tambahkan properti khusus OLT
  return {
    ...baseEntity,
    vendor: data.vendor || '',
    model: data.model || '',
    sn: data.sn || '',
    telnet_conn: data.telnet_conn ? createTelnetConnEntity(data.telnet_conn) : null,
    ssh_conn: data.ssh_conn ? createSshConnEntity(data.ssh_conn) : null,
    snmp_conn: data.snmp_conn ? createSnmpConnEntity(data.snmp_conn) : null,
    pon_type: data.pon_type || PonTypes.GPON,
    pon_port: ponPorts
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOlt
 * @param {Object} data - Data OLT
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOltEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'olt'})) {
    return false;
  }
  
  // Validasi properti vendor
  if (typeof data.vendor !== 'string') {
    return false;
  }
  
  // Validasi properti model
  if (typeof data.model !== 'string') {
    return false;
  }
  
  // Validasi properti serial number
  if (typeof data.sn !== 'string') {
    return false;
  }
  
  // Validasi koneksi telnet
  if (data.telnet_conn && !validateTelnetConnEntity(data.telnet_conn)) {
    return false;
  }
  
  // Validasi koneksi SSH
  if (data.ssh_conn && !validateSshConnEntity(data.ssh_conn)) {
    return false;
  }
  
  // Validasi koneksi SNMP
  if (data.snmp_conn && !validateSnmpConnEntity(data.snmp_conn)) {
    return false;
  }
  
  // Validasi pon_type
  if (data.pon_type && !Object.values(PonTypes).includes(data.pon_type)) {
    return false;
  }
  
  // Validasi pon_port
  if (data.pon_port) {
    if (!Array.isArray(data.pon_port)) {
      return false;
    }
    
    const existingPorts = [];
    for (const port of data.pon_port) {
      if (!validatePonPortEntity(port, existingPorts)) {
        return false;
      }
      existingPorts.push(port);
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceOltEntity,
  validateNetDeviceOltEntity,
  PonTypes,
  createPonPortEntity,
  validatePonPortEntity
};
###
cat src/entities/netDeviceOnt.entity.js
/**
 * Entity untuk netDeviceOnt (perangkat Optical Network Terminal)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Fungsi untuk membuat objek netDeviceOnt
 * @param {Object} data - Data ONT
 * @returns {Object} - Objek netDeviceOnt
 */
function createNetDeviceOntEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'ont'
  });
  
  // Tambahkan properti khusus ONT
  return {
    ...baseEntity,
    vendor: data.vendor || '',
    model: data.model || '',
    sn: data.sn || ''
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOnt
 * @param {Object} data - Data ONT
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOntEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'ont'})) {
    return false;
  }
  
  // Validasi properti vendor
  if (typeof data.vendor !== 'string') {
    return false;
  }
  
  // Validasi properti model
  if (typeof data.model !== 'string') {
    return false;
  }
  
  // Validasi properti serial number
  if (typeof data.sn !== 'string') {
    return false;
  }
  
  return true;
}

module.exports = {
  createNetDeviceOntEntity,
  validateNetDeviceOntEntity
};
###
cat src/entities/netDeviceRouter.entity.js
/**
 * Entity untuk netDeviceRouter (perangkat router)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Enum untuk tipe koneksi router
 * @enum {string}
 */
const ConnectionTypes = {
  OPENVPN: 'OPENVPN',
  PUBLIC: 'PUBLIC',
  ZEROTIER: 'ZEROTIER'
};

/**
 * Fungsi untuk validasi alamat IP v4
 * @param {string} ip - Alamat IP yang akan divalidasi
 * @returns {boolean} - True jika valid
 */
function isValidIPv4(ip) {
  if (typeof ip !== 'string') return false;
  
  // Pola IPv4: xxx.xxx.xxx.xxx
  const pattern = /^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  return pattern.test(ip);
}

/**
 * Fungsi untuk memeriksa tipe anak yang valid
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidChild(child) {
  // Hanya menerima netDeviceOlt
  const validTypes = ['olt'];
  return child && child.type && validTypes.includes(child.type);
}

/**
 * Fungsi untuk membuat objek netDeviceRouter
 * @param {Object} data - Data router
 * @returns {Object} - Objek netDeviceRouter
 */
function createNetDeviceRouterEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'router'
  });
  
  // Tambahkan properti khusus router
  return {
    ...baseEntity,
    connection_type: data.connection_type || ConnectionTypes.PUBLIC,
    ip_addr: data.ip_addr || '',
    // Children hanya bisa berisi OLT
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceRouter
 * @param {Object} data - Data router
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceRouterEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'router'})) {
    return false;
  }
  
  // Validasi connection_type
  if (data.connection_type && !Object.values(ConnectionTypes).includes(data.connection_type)) {
    return false;
  }
  
  // Validasi ip_addr
  if (data.ip_addr && !isValidIPv4(data.ip_addr)) {
    return false;
  }
  
  // Validasi children
  if (data.children) {
    if (!Array.isArray(data.children)) {
      return false;
    }
    
    // Validasi setiap anak, pastikan tipenya valid
    for (const child of data.children) {
      if (!isValidChild(child)) {
        return false;
      }
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceRouterEntity,
  validateNetDeviceRouterEntity,
  ConnectionTypes,
  isValidChild
};
###
cat src/utils/errorHandler.js
###
cat src/utils/jwksHelper.js
###
cat src/utils/recursiveDeletedCheck.util.js
/**
 * Utility untuk melakukan pemeriksaan deleted_at secara recursive
 */

const DeletedFilterTypes = {
  ONLY: 'ONLY',    // Hanya data yang dihapus (memiliki deleted_at)
  WITH: 'WITH',    // Semua data, termasuk yang dihapus
  WITHOUT: 'WITHOUT' // Hanya data yang tidak dihapus (default)
};

/**
 * Memeriksa apakah sebuah object memenuhi kriteria filter deleted
 * @param {Object} obj - Object yang akan diperiksa
 * @param {string} deletedFilter - Tipe filter yang digunakan (ONLY, WITH, WITHOUT)
 * @returns {boolean} - True jika object memenuhi kriteria
 */
function isMatchingDeletedFilter(obj, deletedFilter) {
  if (deletedFilter === DeletedFilterTypes.WITH) return true;
  if (deletedFilter === DeletedFilterTypes.ONLY) return obj.deleted_at !== undefined;
  if (deletedFilter === DeletedFilterTypes.WITHOUT) return obj.deleted_at === undefined;
  return false;
}

/**
 * Memeriksa dan memfilter children dari pon_port OLT
 * @param {Array} ponPorts - Array port dari OLT
 * @param {string} deletedFilter - Tipe filter yang digunakan
 * @param {string} scopeLevel - Level scope data yang akan dikembalikan
 * @returns {Array} - Array port yang sudah difilter
 */
function checkPonPorts(ponPorts, deletedFilter, scopeLevel) {
  if (!ponPorts || !Array.isArray(ponPorts)) return [];
  
  return ponPorts
    .map(port => {
      const portCopy = { ...port };
      
      if (portCopy.children && Array.isArray(portCopy.children)) {
        // Filter ODC di children
        portCopy.children = portCopy.children
          .filter(odc => isMatchingDeletedFilter(odc, deletedFilter))
          .map(odc => {
            const odcCopy = { ...odc };
            
            if (odcCopy.trays && Array.isArray(odcCopy.trays)) {
              // Filter ODP di trays
              odcCopy.trays = odcCopy.trays
                .map(tray => {
                  const trayCopy = { ...tray };
                  
                  // Jika scopeLevel adalah ODCS, hapus children dari tray (yang berisi ODP)
                  if (scopeLevel === 'ODCS') {
                    delete trayCopy.children;
                    return trayCopy;
                  }
                  
                  if (trayCopy.children && Array.isArray(trayCopy.children)) {
                    // Filter ODP
                    trayCopy.children = trayCopy.children
                      .filter(odp => isMatchingDeletedFilter(odp, deletedFilter))
                      .map(odp => {
                        const odpCopy = { ...odp };
                        
                        // Jika scopeLevel adalah ODPS, hapus children (ONT)
                        if (scopeLevel === 'ODPS') {
                          delete odpCopy.children;
                          return odpCopy;
                        }
                        
                        if (odpCopy.children && Array.isArray(odpCopy.children)) {
                          // Filter ONT
                          odpCopy.children = odpCopy.children
                            .filter(ont => isMatchingDeletedFilter(ont, deletedFilter));
                        }
                        
                        return odpCopy;
                      });
                  }
                  
                  return trayCopy;
                });
            }
            
            return odcCopy;
          });
      }
      
      return portCopy;
    });
}

/**
 * Melakukan pemeriksaan deleted_at secara recursive pada branch dan children-nya
 * @param {Object} branch - Data branch yang akan diperiksa
 * @param {string} deletedFilter - Tipe filter yang digunakan (ONLY, WITH, WITHOUT)
 * @param {string} scopeLevel - Level scope data yang akan dikembalikan
 * @returns {Object|null} - Branch yang sudah difilter atau null jika tidak memenuhi kriteria
 */
function recursiveDeletedCheck(branch, deletedFilter = DeletedFilterTypes.WITHOUT, scopeLevel = null) {
  // Periksa apakah branch memenuhi kriteria filter
  if (!isMatchingDeletedFilter(branch, deletedFilter)) {
    return null;
  }
  
  const branchCopy = { ...branch };
  
  // Jika tidak ada children atau scopeLevel adalah BRANCHES, return early
  if (!branchCopy.children || !Array.isArray(branchCopy.children) || scopeLevel === 'BRANCHES') {
    delete branchCopy.children;
    return branchCopy;
  }
  
  // Filter dan map router
  branchCopy.children = branchCopy.children
    .filter(router => isMatchingDeletedFilter(router, deletedFilter))
    .map(router => {
      const routerCopy = { ...router };
      
      // Jika scopeLevel adalah ROUTERS, hapus children router
      if (scopeLevel === 'ROUTERS') {
        delete routerCopy.children;
        return routerCopy;
      }
      
      if (routerCopy.children && Array.isArray(routerCopy.children)) {
        // Filter dan map OLT
        routerCopy.children = routerCopy.children
          .filter(olt => isMatchingDeletedFilter(olt, deletedFilter))
          .map(olt => {
            const oltCopy = { ...olt };
            
            // Jika scopeLevel adalah OLTS, hapus children dari pon_port
            if (scopeLevel === 'OLTS') {
              if (oltCopy.pon_port && Array.isArray(oltCopy.pon_port)) {
                oltCopy.pon_port = oltCopy.pon_port.map(port => {
                  const portCopy = { ...port };
                  delete portCopy.children;
                  return portCopy;
                });
              }
              return oltCopy;
            }
            
            // Proses pon_port dan children-nya (ODC, ODP, ONT)
            if (oltCopy.pon_port && Array.isArray(oltCopy.pon_port)) {
              oltCopy.pon_port = checkPonPorts(oltCopy.pon_port, deletedFilter, scopeLevel);
            }
            
            return oltCopy;
          });
      }
      
      return routerCopy;
    });
  
  return branchCopy;
}

module.exports = {
  recursiveDeletedCheck,
  DeletedFilterTypes
}; ###
cat src/utils/recursiveRestore.util.js
/**
 * Utilitas untuk melakukan restore secara rekursif pada perangkat jaringan
 */

const { getCollection } = require('../repositories/database.connector');
const { ObjectId } = require('mongoose').Types;

/**
 * Helper untuk melakukan restore pada device dan children-nya
 * @param {Object} query - Query untuk mencari device
 * @param {Object} device - Device yang akan di-restore
 * @param {string} devicePath - Path ke device dalam struktur data
 * @param {Date} deletedAt - Timestamp deleted_at yang akan di-restore
 * @returns {Promise<Object>} - Hasil restore
 */
async function restoreDeviceAndChildren(query, device, devicePath, deletedAt) {
  const collection = getCollection('branches');
  
  // Restore device itu sendiri
  const restoreResult = await collection.updateOne(
    {
      ...query,
      [`${devicePath}.deleted_at`]: deletedAt // Hanya restore jika deleted_at sama
    },
    {
      $unset: {
        [`${devicePath}.deleted_at`]: ""
      },
      $set: {
        updatedAt: new Date()
      }
    }
  );
  
  return restoreResult;
}

/**
 * Melakukan restore pada ONT
 * @param {string} ontId - ID ONT yang akan di-restore
 * @returns {Promise<Object>} - Hasil restore
 */
async function restoreOnt(ontId) {
  try {
    const collection = getCollection('branches');
    
    // Cari ONT dan dapatkan timestamp deleted_at nya
    const branch = await collection.findOne({
      'children.children.pon_port.children.trays.children.children.children._id': new ObjectId(ontId)
    });
    
    if (!branch) return null;
    
    // Cari ONT dalam struktur nested
    let foundOnt = null;
    const searchOnt = (obj) => {
      if (obj._id && obj._id.toString() === ontId.toString()) {
        foundOnt = obj;
        return;
      }
      if (obj.children && Array.isArray(obj.children)) {
        obj.children.forEach(searchOnt);
      }
      if (obj.pon_port && Array.isArray(obj.pon_port)) {
        obj.pon_port.forEach(port => {
          if (port.children) port.children.forEach(searchOnt);
        });
      }
      if (obj.trays && Array.isArray(obj.trays)) {
        obj.trays.forEach(tray => {
          if (tray.children) tray.children.forEach(searchOnt);
        });
      }
    };
    
    searchOnt(branch);
    
    if (!foundOnt || !foundOnt.deleted_at) return null;
    
    const deletedAt = foundOnt.deleted_at;
    
    // Restore ONT
    const result = await collection.updateOne(
      {
        'children.children.pon_port.children.trays.children.children.children._id': new ObjectId(ontId),
        'children.children.pon_port.children.trays.children.children.children.deleted_at': deletedAt
      },
      {
        $unset: {
          'children.$[].children.$[].pon_port.$[].children.$[].trays.$[].children.$[].children.$[ont].deleted_at': ""
        },
        $set: {
          updatedAt: new Date()
        }
      },
      {
        arrayFilters: [
          { 'ont._id': new ObjectId(ontId) }
        ]
      }
    );
    
    return result;
  } catch (error) {
    console.error('Error restoring ONT:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada ODP dan children-nya
 * @param {string} odpId - ID ODP yang akan di-restore
 * @returns {Promise<Object>} - Hasil restore
 */
async function restoreOdp(odpId) {
  try {
    console.log(`[recursiveRestore.restoreOdp] Mencoba restore ODP dengan ID: ${odpId}`);
    const collection = getCollection('branches');
    
    // Cari ODP dan dapatkan timestamp deleted_at nya
    const branch = await collection.findOne({
      'children.children.pon_port.children.trays.children._id': new ObjectId(odpId)
    });
    
    console.log(`[recursiveRestore.restoreOdp] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;
    
    // Cari ODP dalam struktur nested
    let foundOdp = null;
    let odpPath = '';
    const searchOdp = (obj, path = '') => {
      if (obj._id && obj._id.toString() === odpId.toString()) {
        console.log('[recursiveRestore.restoreOdp] ODP ditemukan dalam struktur');
        foundOdp = obj;
        odpPath = path;
        return;
      }
      if (obj.children && Array.isArray(obj.children)) {
        obj.children.forEach((child, idx) => searchOdp(child, path ? `${path}.children.${idx}` : `children.${idx}`));
      }
      if (obj.pon_port && Array.isArray(obj.pon_port)) {
        obj.pon_port.forEach((port, idx) => {
          if (port.children) {
            port.children.forEach((child, childIdx) => 
              searchOdp(child, path ? `${path}.pon_port.${idx}.children.${childIdx}` : `pon_port.${idx}.children.${childIdx}`));
          }
        });
      }
      if (obj.trays && Array.isArray(obj.trays)) {
        obj.trays.forEach((tray, idx) => {
          if (tray.children) {
            tray.children.forEach((child, childIdx) => 
              searchOdp(child, path ? `${path}.trays.${idx}.children.${childIdx}` : `trays.${idx}.children.${childIdx}`));
          }
        });
      }
    };
    
    searchOdp(branch);
    
    console.log(`[recursiveRestore.restoreOdp] Status ODP:`, {
      found: !!foundOdp,
      hasDeletedAt: foundOdp ? !!foundOdp.deleted_at : false,
      path: odpPath
    });
    
    if (!foundOdp || !foundOdp.deleted_at) return null;
    
    const deletedAt = foundOdp.deleted_at;
    
    // 1. Restore ODP
    console.log('[recursiveRestore.restoreOdp] Mencoba update ODP di database');
    const odpResult = await collection.updateOne(
      {
        _id: branch._id,
        [`${odpPath}.deleted_at`]: deletedAt // Pastikan kita update ODP dengan deleted_at yang tepat
      },
      {
        $unset: {
          [`${odpPath}.deleted_at`]: ""
        },
        $set: {
          updatedAt: new Date()
        }
      }
    );
    
    console.log(`[recursiveRestore.restoreOdp] Hasil update ODP:`, {
      matchedCount: odpResult.matchedCount,
      modifiedCount: odpResult.modifiedCount
    });
    
    // 2. Restore ONTs yang memiliki deleted_at yang sama persis
    if (foundOdp.children && Array.isArray(foundOdp.children)) {
      console.log('[recursiveRestore.restoreOdp] Mencoba restore ONTs');
      const ontRestorePromises = foundOdp.children
        .map((ont, idx) => {
          if (ont.deleted_at && ont.deleted_at.getTime() === deletedAt.getTime()) {
            return collection.updateOne(
              {
                _id: branch._id,
                [`${odpPath}.children.${idx}.deleted_at`]: deletedAt
              },
              {
                $unset: {
                  [`${odpPath}.children.${idx}.deleted_at`]: ""
                },
                $set: {
                  updatedAt: new Date()
                }
              }
            );
          }
          return null;
        })
        .filter(Boolean);
      
      if (ontRestorePromises.length > 0) {
        console.log(`[recursiveRestore.restoreOdp] Merestore ${ontRestorePromises.length} ONT`);
        await Promise.all(ontRestorePromises);
      }
    }
    
    return odpResult.modifiedCount > 0 ? odpResult : null;
  } catch (error) {
    console.error('Error restoring ODP:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada ODC dan children-nya
 * @param {string} odcId - ID ODC yang akan di-restore
 * @returns {Promise<Object>} - Hasil restore
 */
async function restoreOdc(odcId) {
  try {
    const collection = getCollection('branches');
    
    // Cari ODC dan dapatkan timestamp deleted_at nya
    const branch = await collection.findOne({
      'children.children.pon_port.children._id': new ObjectId(odcId)
    });
    
    if (!branch) return null;
    
    // Cari ODC dalam struktur nested
    let foundOdc = null;
    const searchOdc = (obj) => {
      if (obj._id && obj._id.toString() === odcId.toString()) {
        foundOdc = obj;
        return;
      }
      if (obj.children && Array.isArray(obj.children)) {
        obj.children.forEach(searchOdc);
      }
      if (obj.pon_port && Array.isArray(obj.pon_port)) {
        obj.pon_port.forEach(port => {
          if (port.children) port.children.forEach(searchOdc);
        });
      }
    };
    
    searchOdc(branch);
    
    if (!foundOdc || !foundOdc.deleted_at) return null;
    
    const deletedAt = foundOdc.deleted_at;
    
    // 1. Restore ODC
    const odcResult = await collection.updateOne(
      {
        'children.children.pon_port.children._id': new ObjectId(odcId),
        'children.children.pon_port.children.deleted_at': deletedAt
      },
      {
        $unset: {
          'children.$[].children.$[].pon_port.$[].children.$[odc].deleted_at': ""
        },
        $set: {
          updatedAt: new Date()
        }
      },
      {
        arrayFilters: [
          { 'odc._id': new ObjectId(odcId) }
        ]
      }
    );
    
    // 2. Restore ODPs yang memiliki deleted_at yang sama
    if (foundOdc.trays && Array.isArray(foundOdc.trays)) {
      for (const tray of foundOdc.trays) {
        if (tray.children && Array.isArray(tray.children)) {
          const odpRestorePromises = tray.children
            .filter(odp => odp.deleted_at && odp.deleted_at.getTime() === deletedAt.getTime())
            .map(odp => restoreOdp(odp._id.toString()));
          
          await Promise.all(odpRestorePromises);
        }
      }
    }
    
    return odcResult;
  } catch (error) {
    console.error('Error restoring ODC:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada OLT dan semua ODC, ODP, dan ONT di dalamnya
 * @param {string} oltId - ID OLT yang akan di-restore
 * @returns {Promise<Object>} - Hasil restore
 */
async function restoreOlt(oltId) {
  try {
    console.log(`[recursiveRestore.restoreOlt] Mencoba restore OLT dengan ID: ${oltId}`);
    const collection = getCollection('branches');
    
    // Cari OLT dan dapatkan timestamp deleted_at nya
    const branch = await collection.findOne({
      'children.children._id': new ObjectId(oltId)
    });
    
    console.log(`[recursiveRestore.restoreOlt] Branch ditemukan: ${branch ? 'Ya' : 'Tidak'}`);
    
    if (!branch) return null;
    
    // Cari OLT dalam struktur nested
    let foundOlt = null;
    let oltPath = '';
    const searchOlt = (obj, path = '') => {
      if (obj._id && obj._id.toString() === oltId.toString()) {
        console.log('[recursiveRestore.restoreOlt] OLT ditemukan dalam struktur');
        foundOlt = obj;
        oltPath = path;
        return;
      }
      if (obj.children && Array.isArray(obj.children)) {
        obj.children.forEach((child, idx) => searchOlt(child, path ? `${path}.children.${idx}` : `children.${idx}`));
      }
    };
    
    searchOlt(branch);
    
    console.log(`[recursiveRestore.restoreOlt] Status OLT:`, {
      found: !!foundOlt,
      hasDeletedAt: foundOlt ? !!foundOlt.deleted_at : false,
      path: oltPath
    });
    
    if (!foundOlt || !foundOlt.deleted_at) return null;
    
    const deletedAt = foundOlt.deleted_at;
    
    // 1. Restore OLT
    console.log('[recursiveRestore.restoreOlt] Mencoba update OLT di database');
    const oltResult = await collection.updateOne(
      {
        _id: branch._id,
        [`${oltPath}.deleted_at`]: deletedAt // Pastikan kita update OLT dengan deleted_at yang tepat
      },
      {
        $unset: {
          [`${oltPath}.deleted_at`]: ""
        },
        $set: {
          updatedAt: new Date()
        }
      }
    );
    
    console.log(`[recursiveRestore.restoreOlt] Hasil update OLT:`, {
      matchedCount: oltResult.matchedCount,
      modifiedCount: oltResult.modifiedCount
    });
    
    // 2. Restore ODCs yang memiliki deleted_at yang sama
    if (foundOlt.pon_port && Array.isArray(foundOlt.pon_port)) {
      console.log('[recursiveRestore.restoreOlt] Mencoba restore ODCs');
      for (const [ponPortIndex, ponPort] of foundOlt.pon_port.entries()) {
        if (ponPort.children && Array.isArray(ponPort.children)) {
          const odcRestorePromises = ponPort.children
            .filter(odc => odc.deleted_at && odc.deleted_at.getTime() === deletedAt.getTime())
            .map(odc => restoreOdc(odc._id.toString()));
          
          if (odcRestorePromises.length > 0) {
            console.log(`[recursiveRestore.restoreOlt] Merestore ${odcRestorePromises.length} ODC di port ${ponPort.port}`);
            await Promise.all(odcRestorePromises);
          }
        }
      }
    }
    
    return oltResult.modifiedCount > 0 ? oltResult : null;
  } catch (error) {
    console.error('Error restoring OLT:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada Router dan semua OLT, ODC, ODP, serta ONT di dalamnya
 * @param {string} routerId - ID Router yang akan di-restore
 * @returns {Promise<Object|null>} - Router yang sudah di-restore atau null jika gagal
 */
async function restoreRouter(routerId) {
  try {
    console.log(`[restoreRouter] Mencoba restore Router dengan ID: ${routerId}`);
    const collection = getCollection('branches');
    
    // Cari branch yang memiliki Router dengan ID yang sesuai
    const branch = await collection.findOne({
      'children._id': new ObjectId(routerId)
    });
    
    if (!branch) {
      console.log('[restoreRouter] Branch tidak ditemukan');
      return null;
    }
    
    // Cari Router dan dapatkan informasi lengkapnya
    let routerIndex = -1;
    let routerData = null;
    let routerDeletedAt = null;
    
    for (let i = 0; i < branch.children.length; i++) {
      const router = branch.children[i];
      if (router._id.toString() === routerId.toString()) {
        routerIndex = i;
        routerData = router;
        routerDeletedAt = router.deleted_at;
        break;
      }
    }
    
    if (!routerData || !routerDeletedAt) {
      console.log('[restoreRouter] Router tidak ditemukan atau tidak memiliki deleted_at');
      return null;
    }
    
    console.log(`[restoreRouter] Router ditemukan dengan deleted_at: ${routerDeletedAt}`);
    
    // Restore Router dengan menghapus deleted_at
    const routerResult = await restoreDeviceAndChildren(
      { _id: branch._id },
      'router',
      `children.${routerIndex}`,
      routerDeletedAt
    );
    
    if (!routerResult) {
      console.log('[restoreRouter] Gagal melakukan restore Router');
      return null;
    }
    
    // Restore semua OLT yang memiliki deleted_at yang sama
    if (routerData.children && Array.isArray(routerData.children)) {
      for (let oltIndex = 0; oltIndex < routerData.children.length; oltIndex++) {
        const olt = routerData.children[oltIndex];
        
        // Hanya restore OLT yang memiliki deleted_at yang sama dengan Router
        if (olt.deleted_at && olt.deleted_at.getTime() === routerDeletedAt.getTime()) {
          console.log(`[restoreRouter] Mencoba restore OLT di index ${oltIndex}`);
          
          // Restore OLT dan semua device di bawahnya
          await restoreDeviceAndChildren(
            { _id: branch._id },
            'olt',
            `children.${routerIndex}.children.${oltIndex}`,
            routerDeletedAt
          );
          
          // Restore ODCs
          if (olt.pon_port && Array.isArray(olt.pon_port)) {
            for (let ponPortIndex = 0; ponPortIndex < olt.pon_port.length; ponPortIndex++) {
              const ponPort = olt.pon_port[ponPortIndex];
              if (ponPort.children && Array.isArray(ponPort.children)) {
                for (let odcIndex = 0; odcIndex < ponPort.children.length; odcIndex++) {
                  const odc = ponPort.children[odcIndex];
                  
                  // Hanya restore ODC yang memiliki deleted_at yang sama
                  if (odc.deleted_at && odc.deleted_at.getTime() === routerDeletedAt.getTime()) {
                    console.log(`[restoreRouter] Mencoba restore ODC di port ${ponPortIndex}, index ${odcIndex}`);
                    
                    await restoreDeviceAndChildren(
                      { _id: branch._id },
                      'odc',
                      `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}`,
                      routerDeletedAt
                    );
                    
                    // Restore ODPs
                    if (odc.trays && Array.isArray(odc.trays)) {
                      for (let trayIndex = 0; trayIndex < odc.trays.length; trayIndex++) {
                        const tray = odc.trays[trayIndex];
                        if (tray.children && Array.isArray(tray.children)) {
                          for (let odpIndex = 0; odpIndex < tray.children.length; odpIndex++) {
                            const odp = tray.children[odpIndex];
                            
                            // Hanya restore ODP yang memiliki deleted_at yang sama
                            if (odp.deleted_at && odp.deleted_at.getTime() === routerDeletedAt.getTime()) {
                              console.log(`[restoreRouter] Mencoba restore ODP di tray ${trayIndex}, index ${odpIndex}`);
                              
                              await restoreDeviceAndChildren(
                                { _id: branch._id },
                                'odp',
                                `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children.${odpIndex}`,
                                routerDeletedAt
                              );
                              
                              // Restore ONTs
                              if (odp.children && Array.isArray(odp.children)) {
                                for (let ontIndex = 0; ontIndex < odp.children.length; ontIndex++) {
                                  const ont = odp.children[ontIndex];
                                  
                                  // Hanya restore ONT yang memiliki deleted_at yang sama
                                  if (ont.deleted_at && ont.deleted_at.getTime() === routerDeletedAt.getTime()) {
                                    console.log(`[restoreRouter] Mencoba restore ONT di index ${ontIndex}`);
                                    
                                    await restoreDeviceAndChildren(
                                      { _id: branch._id },
                                      'ont',
                                      `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children.${odpIndex}.children.${ontIndex}`,
                                      routerDeletedAt
                                    );
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    
    console.log('[restoreRouter] Router dan semua device di bawahnya berhasil di-restore');
    return true;
  } catch (error) {
    console.error('Error in restoreRouter:', error);
    throw error;
  }
}

/**
 * Melakukan restore pada branch dan semua device di dalamnya
 * @param {string} branchId - ID branch yang akan di-restore
 * @returns {Promise<Object|null>} - Branch yang sudah di-restore atau null jika gagal
 */
async function restoreBranch(branchId) {
  try {
    console.log(`[restoreBranch] Mencoba restore branch dengan ID: ${branchId}`);
    const collection = getCollection('branches');

    // Cari branch yang memiliki deleted_at
    const branch = await collection.findOne({ 
      _id: new ObjectId(branchId),
      deleted_at: { $exists: true }
    });

    if (!branch) {
      console.log('[restoreBranch] Branch tidak ditemukan atau sudah di-restore');
      return null;
    }

    // Simpan timestamp deleted_at untuk digunakan dalam restore device
    const deletedAt = branch.deleted_at;
    console.log(`[restoreBranch] Timestamp deleted_at branch: ${deletedAt}`);

    // Restore branch dengan menghapus field deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(branchId) },
      {
        $unset: { deleted_at: "" },
        $set: { updatedAt: new Date() }
      }
    );

    if (result.modifiedCount === 0) {
      console.log('[restoreBranch] Gagal melakukan restore branch');
      return null;
    }

    // Restore semua router yang memiliki deleted_at yang sama
    if (branch.children && Array.isArray(branch.children)) {
      for (let routerIndex = 0; routerIndex < branch.children.length; routerIndex++) {
        const router = branch.children[routerIndex];
        if (router.deleted_at && router.deleted_at.getTime() === deletedAt.getTime()) {
          const routerId = router._id.toString();
          console.log(`[restoreBranch] Mencoba restore router dengan ID: ${routerId}`);
          
          await restoreRouter(routerId);
        }
      }
    }

    // Ambil data branch yang sudah di-restore
    const restoredBranch = await collection.findOne({ _id: new ObjectId(branchId) });
    console.log('[restoreBranch] Branch dan semua device berhasil di-restore');
    
    return restoredBranch;
  } catch (error) {
    console.error('Error restoring branch:', error);
    throw error;
  }
}

module.exports = {
  restoreDeviceAndChildren,
  restoreOnt,
  restoreOdp,
  restoreOdc,
  restoreOlt,
  restoreRouter,
  restoreBranch
}; ###
cat src/utils/recursiveSoftDelete.util.js
/**
 * Utilitas untuk melakukan soft delete secara rekursif pada perangkat jaringan
 */

const { getCollection } = require('../repositories/database.connector');
const { ObjectId } = require('mongoose').Types;

/**
 * Helper untuk membuat path update berdasarkan indeks dalam nested document
 * @param {string} device - Jenis perangkat (router, olt, odc, odp, ont)
 * @param {Object} indexes - Indeks untuk setiap level hierarki
 * @returns {string} - Path update untuk MongoDB
 */
function buildDevicePath(device, indexes) {
  const { routerIndex, oltIndex, ponPortIndex, odcIndex, trayIndex, odpIndex, ontIndex } = indexes;
  
  switch (device) {
    case 'router':
      return `children.${routerIndex}`;
    case 'olt':
      return `children.${routerIndex}.children.${oltIndex}`;
    case 'odc':
      return `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}`;
    case 'odp':
      return `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children.${odpIndex}`;
    case 'ont':
      return `children.${routerIndex}.children.${oltIndex}.pon_port.${ponPortIndex}.children.${odcIndex}.trays.${trayIndex}.children.${odpIndex}.children.${ontIndex}`;
    default:
      throw new Error(`Jenis perangkat tidak didukung: ${device}`);
  }
}

/**
 * Melakukan soft delete pada ONT
 * @param {Object} ontData - Data ONT yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteOnt(ontData, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteOnt] Mencoba soft delete ONT di branch ${ontData.branchId}`);
    const collection = getCollection('branches');
    
    // Update ONT dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(ontData.branchId) },
      {
        $set: {
          [`children.${ontData.routerIndex}.children.${ontData.oltIndex}.pon_port.${ontData.ponPortIndex}.children.${ontData.odcIndex}.trays.${ontData.trayIndex}.children.${ontData.odpIndex}.children.${ontData.ontIndex}.deleted_at`]: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteOnt] ONT tidak ditemukan');
      return false;
    }

    console.log('[softDeleteOnt] ONT berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting ONT:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada ODP dan semua ONT di dalamnya
 * @param {Object} odpInfo - Informasi ODP yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteOdp(odpInfo, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteOdp] Mencoba soft delete ODP di branch ${odpInfo.branchId}`);
    const collection = getCollection('branches');
    
    // Update ODP dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(odpInfo.branchId) },
      {
        $set: {
          [`children.${odpInfo.routerIndex}.children.${odpInfo.oltIndex}.pon_port.${odpInfo.ponPortIndex}.children.${odpInfo.odcIndex}.trays.${odpInfo.trayIndex}.children.${odpInfo.odpIndex}.deleted_at`]: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteOdp] ODP tidak ditemukan');
      return false;
    }

    // Dapatkan data ODP untuk proses ONT
    const branch = await collection.findOne({ _id: new ObjectId(odpInfo.branchId) });
    if (!branch) {
      console.log('[softDeleteOdp] Branch tidak ditemukan');
      return false;
    }

    const odp = branch.children[odpInfo.routerIndex]?.children[odpInfo.oltIndex]?.pon_port[odpInfo.ponPortIndex]?.children[odpInfo.odcIndex]?.trays[odpInfo.trayIndex]?.children[odpInfo.odpIndex];
    if (!odp) {
      console.log('[softDeleteOdp] ODP tidak ditemukan di struktur');
      return false;
    }

    // Proses soft delete untuk setiap ONT yang belum dihapus
    if (odp.children && Array.isArray(odp.children)) {
      for (let ontIndex = 0; ontIndex < odp.children.length; ontIndex++) {
        const ont = odp.children[ontIndex];
        // Hanya proses ONT yang belum memiliki deleted_at
        if (!ont.deleted_at) {
          const ontResult = await softDeleteOnt({
            branchId: odpInfo.branchId,
            routerIndex: odpInfo.routerIndex,
            oltIndex: odpInfo.oltIndex,
            ponPortIndex: odpInfo.ponPortIndex,
            odcIndex: odpInfo.odcIndex,
            trayIndex: odpInfo.trayIndex,
            odpIndex: odpInfo.odpIndex,
            ontIndex
          }, deletedAt); // Gunakan timestamp yang sama

          if (!ontResult) {
            console.log(`[softDeleteOdp] Gagal melakukan soft delete pada ONT di index ${ontIndex}`);
            // Lanjutkan ke ONT berikutnya
            continue;
          }
        }
      }
    }

    console.log('[softDeleteOdp] ODP dan semua ONT berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting ODP:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada ODC dan semua ODP serta ONT di dalamnya
 * @param {Object} odcInfo - Informasi ODC yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteOdc(odcInfo, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteOdc] Mencoba soft delete ODC di branch ${odcInfo.branchId}`);
    const collection = getCollection('branches');
    
    // Update ODC dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(odcInfo.branchId) },
      {
        $set: {
          [`children.${odcInfo.routerIndex}.children.${odcInfo.oltIndex}.pon_port.${odcInfo.ponPortIndex}.children.${odcInfo.odcIndex}.deleted_at`]: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteOdc] ODC tidak ditemukan');
      return false;
    }

    // Dapatkan data ODC untuk proses ODP
    const branch = await collection.findOne({ _id: new ObjectId(odcInfo.branchId) });
    if (!branch) {
      console.log('[softDeleteOdc] Branch tidak ditemukan');
      return false;
    }

    const odc = branch.children[odcInfo.routerIndex]?.children[odcInfo.oltIndex]?.pon_port[odcInfo.ponPortIndex]?.children[odcInfo.odcIndex];
    if (!odc) {
      console.log('[softDeleteOdc] ODC tidak ditemukan di struktur');
      return false;
    }

    // Proses soft delete untuk setiap ODP di setiap tray yang belum dihapus
    if (odc.trays && Array.isArray(odc.trays)) {
      for (let trayIndex = 0; trayIndex < odc.trays.length; trayIndex++) {
        const tray = odc.trays[trayIndex];
        if (tray.children && Array.isArray(tray.children)) {
          for (let odpIndex = 0; odpIndex < tray.children.length; odpIndex++) {
            const odp = tray.children[odpIndex];
            // Hanya proses ODP yang belum memiliki deleted_at
            if (!odp.deleted_at) {
              const odpResult = await softDeleteOdp({
                branchId: odcInfo.branchId,
                routerIndex: odcInfo.routerIndex,
                oltIndex: odcInfo.oltIndex,
                ponPortIndex: odcInfo.ponPortIndex,
                odcIndex: odcInfo.odcIndex,
                trayIndex,
                odpIndex
              }, deletedAt); // Gunakan timestamp yang sama

              if (!odpResult) {
                console.log(`[softDeleteOdc] Gagal melakukan soft delete pada ODP di tray ${trayIndex}`);
                // Lanjutkan ke ODP berikutnya
                continue;
              }
            }
          }
        }
      }
    }

    console.log('[softDeleteOdc] ODC dan semua device di bawahnya berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting ODC:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada OLT dan semua ODC, ODP, serta ONT di dalamnya
 * @param {Object} oltInfo - Informasi OLT yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteOlt(oltInfo, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteOlt] Mencoba soft delete OLT di branch ${oltInfo.branchId}`);
    const collection = getCollection('branches');
    
    // Update OLT dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(oltInfo.branchId) },
      {
        $set: {
          [`children.${oltInfo.routerIndex}.children.${oltInfo.oltIndex}.deleted_at`]: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteOlt] OLT tidak ditemukan');
      return false;
    }

    // Dapatkan data OLT untuk proses ODC
    const branch = await collection.findOne({ _id: new ObjectId(oltInfo.branchId) });
    if (!branch) {
      console.log('[softDeleteOlt] Branch tidak ditemukan');
      return false;
    }

    const olt = branch.children[oltInfo.routerIndex]?.children[oltInfo.oltIndex];
    if (!olt) {
      console.log('[softDeleteOlt] OLT tidak ditemukan di struktur');
      return false;
    }

    // Proses soft delete untuk setiap ODC di setiap PON port yang belum dihapus
    if (olt.pon_port && Array.isArray(olt.pon_port)) {
      for (let ponPortIndex = 0; ponPortIndex < olt.pon_port.length; ponPortIndex++) {
        const ponPort = olt.pon_port[ponPortIndex];
        if (ponPort.children && Array.isArray(ponPort.children)) {
          for (let odcIndex = 0; odcIndex < ponPort.children.length; odcIndex++) {
            const odc = ponPort.children[odcIndex];
            // Hanya proses ODC yang belum memiliki deleted_at
            if (!odc.deleted_at) {
              const odcResult = await softDeleteOdc({
                branchId: oltInfo.branchId,
                routerIndex: oltInfo.routerIndex,
                oltIndex: oltInfo.oltIndex,
                ponPortIndex,
                odcIndex
              }, deletedAt); // Gunakan timestamp yang sama

              if (!odcResult) {
                console.log(`[softDeleteOlt] Gagal melakukan soft delete pada ODC di port ${ponPortIndex}`);
                // Lanjutkan ke ODC berikutnya
                continue;
              }
            }
          }
        }
      }
    }

    console.log('[softDeleteOlt] OLT dan semua device di bawahnya berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting OLT:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada Router dan semua OLT, ODC, ODP, serta ONT di dalamnya
 * @param {Object} routerData - Data Router yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteRouter(routerData, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteRouter] Mencoba soft delete Router di branch ${routerData.branchId}`);
    const collection = getCollection('branches');
    
    // Update Router dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { _id: new ObjectId(routerData.branchId) },
      {
        $set: {
          [`children.${routerData.routerIndex}.deleted_at`]: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteRouter] Router tidak ditemukan');
      return false;
    }

    // Dapatkan data Router untuk proses OLT
    const branch = await collection.findOne({ _id: new ObjectId(routerData.branchId) });
    if (!branch) {
      console.log('[softDeleteRouter] Branch tidak ditemukan');
      return false;
    }

    const router = branch.children[routerData.routerIndex];
    if (!router) {
      console.log('[softDeleteRouter] Router tidak ditemukan di struktur');
      return false;
    }

    // Proses soft delete untuk setiap OLT yang belum dihapus
    if (router.children && Array.isArray(router.children)) {
      for (let oltIndex = 0; oltIndex < router.children.length; oltIndex++) {
        const olt = router.children[oltIndex];
        // Hanya proses OLT yang belum memiliki deleted_at
        if (!olt.deleted_at) {
          const oltResult = await softDeleteOlt({
            branchId: routerData.branchId,
            routerIndex: routerData.routerIndex,
            oltIndex
          }, deletedAt); // Gunakan timestamp yang sama

          if (!oltResult) {
            console.log(`[softDeleteRouter] Gagal melakukan soft delete pada OLT di index ${oltIndex}`);
            // Lanjutkan ke OLT berikutnya
            continue;
          }
        }
      }
    }

    console.log('[softDeleteRouter] Router dan semua device di bawahnya berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting Router:', error);
    throw error;
  }
}

/**
 * Melakukan soft delete pada branch dan semua device di dalamnya
 * @param {string} branchId - ID branch yang akan di-soft delete
 * @param {Date} deletedAt - Timestamp untuk soft delete (opsional)
 * @returns {Promise<boolean>} - True jika berhasil
 */
async function softDeleteBranch(branchId, deletedAt = new Date()) {
  try {
    console.log(`[softDeleteBranch] Mencoba soft delete branch dengan ID: ${branchId}`);
    const collection = getCollection('branches');
    
    // Update branch dengan menambahkan deleted_at
    const result = await collection.updateOne(
      { 
        _id: new ObjectId(branchId),
        deleted_at: { $exists: false } // Hanya update jika belum memiliki deleted_at
      },
      {
        $set: {
          deleted_at: deletedAt,
          updatedAt: new Date()
        }
      }
    );

    if (result.matchedCount === 0) {
      console.log('[softDeleteBranch] Branch tidak ditemukan atau sudah memiliki deleted_at');
      return false;
    }

    // Dapatkan data branch untuk proses router
    const branch = await collection.findOne({ _id: new ObjectId(branchId) });
    if (!branch) {
      console.log('[softDeleteBranch] Branch tidak ditemukan setelah update');
      return false;
    }

    // Proses soft delete untuk setiap router yang belum dihapus
    if (branch.children && Array.isArray(branch.children)) {
      for (let routerIndex = 0; routerIndex < branch.children.length; routerIndex++) {
        const router = branch.children[routerIndex];
        // Hanya proses router yang belum memiliki deleted_at
        if (!router.deleted_at) {
          const routerResult = await softDeleteRouter({
            branchId: branchId,
            routerIndex
          }, deletedAt); // Gunakan timestamp yang sama

          if (!routerResult) {
            console.log(`[softDeleteBranch] Gagal melakukan soft delete pada router di index ${routerIndex}`);
            // Lanjutkan ke router berikutnya
            continue;
          }
        }
      }
    }

    console.log('[softDeleteBranch] Branch dan semua device di dalamnya berhasil di-soft delete');
    return true;
  } catch (error) {
    console.error('Error soft deleting branch:', error);
    throw error;
  }
}

module.exports = {
  softDeleteOnt,
  softDeleteOdp,
  softDeleteOdc,
  softDeleteOlt,
  softDeleteRouter,
  softDeleteBranch
}; ###
cat src/utils/uuid.util.js
/**
 * UUID Helper
 * 
 * Modul ini menyediakan fungsi-fungsi helper untuk generate UUID
 * Secara default menggunakan UUID v7 yang memberikan keuntungan:
 * - Memiliki timestamp yang terintegrasi (time ordered)
 * - Memudahkan sorting berdasarkan waktu pembuatan
 * - Kompatibel dengan format UUID standar
 */

const { v7: uuidv7, v4: uuidv4 } = require('uuid');

/**
 * Generate UUID v7 (default)
 * UUID v7 menggabungkan timestamp dengan random bits
 * Sangat cocok untuk primary key yang perlu diurutkan berdasarkan waktu
 * 
 * @returns {string} UUID v7 string
 */
const generateUUID = () => {
  try {
    return uuidv7();
  } catch (error) {
    console.error(`Error generating UUID v7: ${error.message}`);
    // Fallback ke UUID v4 jika v7 tidak tersedia
    return uuidv4();
  }
};

/**
 * Generate UUID v4 (completely random)
 * 
 * @returns {string} UUID v4 string
 */
const generateRandomUUID = () => {
  return uuidv4();
};

/**
 * Memeriksa apakah string adalah UUID valid
 * 
 * @param {string} uuid - String yang akan diperiksa
 * @returns {boolean} true jika valid, false jika tidak
 */
const isValidUUID = (uuid) => {
  if (!uuid) return false;
  
  // Format regex untuk UUID
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-7][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(uuid);
};

module.exports = {
  generateUUID,
  generateRandomUUID,
  isValidUUID
}; ###
cat src/utils/validator.js
