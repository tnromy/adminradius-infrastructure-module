saran anda saat memeriksa routes, middleware dan validation:

Namun ada beberapa saran perbaikan untuk membuat kode lebih efisien dan konsisten:
Duplikasi Validasi
Saran: Buat shared validation untuk address dan location.
Middleware Composition
Saran: Buat middleware composer untuk mengurangi repetisi.
Error Response Format
Saran: Buat helper function untuk format response yang konsisten:
Validation Middleware
Saran: Tambahkan type checking middleware:
Constants & Enums
Saran: Pindahkan semua konstanta ke file terpisah:
Request Context
Saran: Tambahkan request context validation:


saran untuk controller:

Saran perbaikan - buat base controller:
b) Response Handler
Buat response handler terpisah:
c) Logging Helper
Buat logging helper untuk mengurangi duplikasi:
3. Saran Perbaikan untuk Best Practice:
a) Dependency Injection
b) Service Layer
Pindahkan logika bisnis ke service layer:
c) Request Validation
Pisahkan validasi ke middleware:
4. Rekomendasi Implementasi:
a) Fase 1 - Refaktor Base Components:
Implementasi BaseController
Implementasi ResponseHandler
Implementasi LoggingHelper
b) Fase 2 - Refaktor Controllers:
c) Fase 3 - Implementasi Service Layer:


saran untuk repositories:
Saran perbaikan - buat base repository:
b) Query Helper
Buat query helper untuk mengurangi duplikasi:
c) Logging Helper
Buat logging helper khusus repository:
Saran Perbaikan untuk Best Practice:
a) Repository Pattern yang Lebih Baik
b) Caching Layer
c) Transaction Support
Rekomendasi Implementasi:
a) Fase 1 - Refaktor Base Components:
b) Fase 2 - Implementasi Device Repository:
c) Fase 3 - Implementasi Service Integration:


saran untuk entities :
cat src/entities/address.entity.js
/**
 * Entity untuk address (alamat)
 */

/**
 * Fungsi untuk membuat objek address
 * @param {Object} data - Data alamat
 * @returns {Object} - Objek address
 */
function createAddressEntity(data = {}) {
  return {
    country: data.country || 'ID', // Default Indonesia
    province: data.province || '',
    city: data.city || '',
    district: data.district || '',
    village: data.village || '',
    detail: data.detail || '',
    zip_code: data.zip_code || ''
  };
}

/**
 * Fungsi untuk memvalidasi data address
 * @param {Object} data - Data address
 * @returns {boolean} - True jika valid
 */
function validateAddressEntity(data) {
  if (!data) {
    return false;
  }
  
  // Validasi country (harus ada dan string)
  if (!data.country || typeof data.country !== 'string') {
    return false;
  }
  
  // Validasi tipe data
  const stringFields = ['province', 'city', 'district', 'village', 'detail', 'zip_code'];
  for (const field of stringFields) {
    if (data[field] && typeof data[field] !== 'string') {
      return false;
    }
  }
  
  return true;
}

module.exports = {
  createAddressEntity,
  validateAddressEntity
}; ###
cat src/entities/branch.entity.js
/**
 * Entity untuk branch (cabang)
 */

const { createLocationEntity, validateLocationEntity } = require('./location.entity');
const { createAddressEntity, validateAddressEntity } = require('./address.entity');
const { createContactEntity, validateContactEntity } = require('./contact.entity');
const { validateNetDeviceRouterEntity } = require('./netDeviceRouter.entity');

/**
 * Fungsi untuk membuat objek branch
 * @param {Object} data - Data branch
 * @returns {Object} - Objek branch
 */
function createBranchEntity(data = {}) {
  return {
    _id: data._id || null,
    name: data.name || '',
    location: data.location ? createLocationEntity(data.location) : createLocationEntity(),
    address: data.address ? createAddressEntity(data.address) : createAddressEntity(),
    contact: data.contact ? createContactEntity(data.contact) : createContactEntity(),
    children: data.children || [],
    createdAt: data.createdAt || new Date(),
    updatedAt: data.updatedAt || new Date()
  };
}

/**
 * Fungsi untuk memvalidasi data branch
 * @param {Object} data - Data branch
 * @returns {boolean} - True jika valid
 */
function validateBranchEntity(data) {
  if (!data.name || typeof data.name !== 'string') {
    return false;
  }
  
  if (data.name.length < 3 || data.name.length > 64) {
    return false;
  }
  
  // Validasi location jika ada
  if (data.location && !validateLocationEntity(data.location)) {
    return false;
  }
  
  // Validasi address jika ada
  if (data.address && !validateAddressEntity(data.address)) {
    return false;
  }
  
  // Validasi contact jika ada
  if (data.contact && !validateContactEntity(data.contact)) {
    return false;
  }
  
  // Validasi children jika ada
  if (data.children) {
    if (!Array.isArray(data.children)) {
      return false;
    }
    
    // Validasi setiap item dalam children harus berupa netDeviceRouter
    for (const child of data.children) {
      if (!validateNetDeviceRouterEntity(child)) {
        return false;
      }
    }
  }
  
  return true;
}

module.exports = {
  createBranchEntity,
  validateBranchEntity
};
###
cat src/entities/branchAccess.entity.js
const { ObjectId } = require('mongodb');

/**
 * @typedef {Object} BranchAccess
 * @property {ObjectId} _id - ID dari dokumen branch access
 * @property {ObjectId} branch_id - ID dari branch yang diakses
 * @property {string} user_id - UUID dari user yang memiliki akses
 * @property {('R'|'RW')} permission - Tipe akses: R (read) atau RW (read-write)
 */

/**
 * Membuat objek BranchAccess baru
 * @param {Object} data - Data untuk membuat BranchAccess
 * @param {string|ObjectId} data.branch_id - ID dari branch
 * @param {string} data.user_id - UUID dari user
 * @param {string} data.permission - Tipe akses (R/RW)
 * @returns {BranchAccess}
 */
function createBranchAccess(data) {
  return {
    _id: new ObjectId(),
    branch_id: typeof data.branch_id === 'string' ? new ObjectId(data.branch_id) : data.branch_id,
    user_id: data.user_id,
    permission: data.permission
  };
}

/**
 * Memvalidasi data BranchAccess
 * @param {Object} data - Data yang akan divalidasi
 * @throws {Error} Jika validasi gagal
 */
function validateBranchAccess(data) {
  if (!data.branch_id) {
    throw new Error('branch_id is required');
  }
  if (!data.user_id) {
    throw new Error('user_id is required');
  }
  if (!data.permission || !['R', 'RW'].includes(data.permission)) {
    throw new Error('permission must be either R or RW');
  }
}

module.exports = {
  createBranchAccess,
  validateBranchAccess
}; ###
cat src/entities/contact.entity.js
/**
 * Entity untuk contact (kontak)
 */

/**
 * Fungsi untuk membuat objek contact
 * @param {Object} data - Data kontak
 * @returns {Object} - Objek contact
 */
function createContactEntity(data = {}) {
  return {
    email: data.email || '',
    phone: data.phone || ''
  };
}

/**
 * Fungsi untuk memvalidasi data contact
 * @param {Object} data - Data contact
 * @returns {boolean} - True jika valid
 */
function validateContactEntity(data) {
  if (!data) {
    return false;
  }
  
  // Validasi email jika ada
  if (data.email) {
    if (typeof data.email !== 'string') {
      return false;
    }
    
    // Simple email validation
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(data.email)) {
      return false;
    }
  }
  
  // Validasi phone jika ada
  if (data.phone) {
    if (typeof data.phone !== 'string') {
      return false;
    }
    
    // Simple phone validation (at least 8 digits)
    const phoneRegex = /^\+?[0-9]{8,15}$/;
    if (!phoneRegex.test(data.phone)) {
      return false;
    }
  }
  
  return true;
}

module.exports = {
  createContactEntity,
  validateContactEntity
}; ###
cat src/entities/location.entity.js
/**
 * Entity untuk location (lokasi) menggunakan format GeoJSON Point
 */

/**
 * Fungsi untuk membuat objek location
 * @param {Object} data - Data lokasi
 * @returns {Object} - Objek location dalam format GeoJSON Point
 */
function createLocationEntity(data = {}) {
  return {
    type: data.type || "Point",
    coordinates: data.coordinates || [0, 0] // [longitude, latitude]
  };
}

/**
 * Fungsi untuk memvalidasi data location
 * @param {Object} data - Data location
 * @returns {boolean} - True jika valid
 */
function validateLocationEntity(data) {
  if (!data || !data.type || !data.coordinates) {
    return false;
  }
  
  if (data.type !== "Point") {
    return false;
  }
  
  if (!Array.isArray(data.coordinates) || data.coordinates.length !== 2) {
    return false;
  }
  
  // Validasi longitude (-180 sampai 180)
  if (typeof data.coordinates[0] !== 'number' || 
      data.coordinates[0] < -180 || 
      data.coordinates[0] > 180) {
    return false;
  }
  
  // Validasi latitude (-90 sampai 90)
  if (typeof data.coordinates[1] !== 'number' || 
      data.coordinates[1] < -90 || 
      data.coordinates[1] > 90) {
    return false;
  }
  
  return true;
}

module.exports = {
  createLocationEntity,
  validateLocationEntity
}; ###
cat src/entities/log.entity.js
/**
 * Entity untuk log
 */

const { generateUUID } = require('../utils/uuid.util');

/**
 * Membuat log entity
 * @param {Object} logData - Data log yang akan dibuat
 * @returns {Object} Log entity
 */
function createLogEntity(logData) {
  const now = new Date();
  
  return {
    _id: generateUUID(),
    timestamp: now.toISOString(),
    level: logData.level,
    message: logData.message,
    context: {
      service: 'infrastructure-service',
      environment: process.env.NODE_ENV || 'development',
      requestId: logData.requestId,
      userId: logData.userId,
      method: logData.method,
      url: logData.url,
      statusCode: logData.statusCode,
      responseTime: logData.responseTime,
      userAgent: logData.userAgent,
      ip: logData.ip
    },
    metadata: logData.metadata || {},
    labels: {
      type: logData.type || 'application',
      component: logData.component || 'general'
    },
    createdAt: now,
    updatedAt: now
  };
}

module.exports = {
  createLogEntity
}; ###
cat src/entities/netDevice.entity.js
/**
 * Entity untuk netDevice (perangkat jaringan)
 */

const { createLocationEntity, validateLocationEntity } = require('./location.entity');
const { createAddressEntity, validateAddressEntity } = require('./address.entity');

/**
 * Fungsi untuk membuat objek netDevice
 * @param {Object} data - Data perangkat jaringan
 * @returns {Object} - Objek netDevice
 */
function createNetDeviceEntity(data = {}) {
  return {
    _id: data._id || null,
    label: data.label || '',
    type: data.type || '',
    location: data.location ? createLocationEntity(data.location) : createLocationEntity(),
    address: data.address ? createAddressEntity(data.address) : createAddressEntity(),
    createdAt: data.createdAt || new Date(),
    updatedAt: data.updatedAt || new Date()
  };
}

/**
 * Fungsi untuk memvalidasi data netDevice
 * @param {Object} data - Data netDevice
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceEntity(data) {
  if (!data.label || typeof data.label !== 'string') {
    return false;
  }
  
  if (!data.type || typeof data.type !== 'string') {
    return false;
  }
  
  // Validasi location jika ada
  if (data.location && !validateLocationEntity(data.location)) {
    return false;
  }
  
  // Validasi address jika ada
  if (data.address && !validateAddressEntity(data.address)) {
    return false;
  }
  
  return true;
}

module.exports = {
  createNetDeviceEntity,
  validateNetDeviceEntity
};
###
cat src/entities/netDeviceConn.entity.js
/**
 * Entity untuk berbagai jenis koneksi perangkat jaringan
 * File ini berisi definisi entity untuk koneksi telnet, ssh, dan snmp
 */

/**
 * Fungsi untuk validasi alamat IP v4
 * @param {string} ip - Alamat IP yang akan divalidasi
 * @returns {boolean} - True jika valid
 */
function isValidIPv4(ip) {
  if (typeof ip !== 'string') return false;
  
  // Pola IPv4: xxx.xxx.xxx.xxx
  const pattern = /^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  return pattern.test(ip);
}

/**
 * Fungsi untuk validasi port yang valid
 * @param {number} port - Nomor port yang akan divalidasi
 * @returns {boolean} - True jika valid
 */
function isValidPort(port) {
  return Number.isInteger(port) && port > 0 && port <= 65535;
}

/**
 * Fungsi untuk membuat objek koneksi telnet
 * @param {Object} data - Data koneksi telnet
 * @returns {Object} - Objek koneksi telnet
 */
function createTelnetConnEntity(data = {}) {
  return {
    ip_addr: data.ip_addr || '',
    port: data.port || 23, // Default telnet port
    username: data.username || '',
    password: data.password || ''
  };
}

/**
 * Fungsi untuk validasi koneksi telnet
 * @param {Object} data - Data koneksi telnet
 * @returns {boolean} - True jika valid
 */
function validateTelnetConnEntity(data) {
  if (!isValidIPv4(data.ip_addr)) {
    return false;
  }

  if (!isValidPort(data.port)) {
    return false;
  }

  if (typeof data.username !== 'string') {
    return false;
  }

  if (typeof data.password !== 'string') {
    return false;
  }

  return true;
}

/**
 * Fungsi untuk membuat objek koneksi SSH
 * @param {Object} data - Data koneksi SSH
 * @returns {Object} - Objek koneksi SSH
 */
function createSshConnEntity(data = {}) {
  return {
    ip_addr: data.ip_addr || '',
    port: data.port || 22, // Default SSH port
    username: data.username || '',
    password: data.password || ''
  };
}

/**
 * Fungsi untuk validasi koneksi SSH
 * @param {Object} data - Data koneksi SSH
 * @returns {boolean} - True jika valid
 */
function validateSshConnEntity(data) {
  if (!isValidIPv4(data.ip_addr)) {
    return false;
  }

  if (!isValidPort(data.port)) {
    return false;
  }

  if (typeof data.username !== 'string') {
    return false;
  }

  if (typeof data.password !== 'string') {
    return false;
  }

  return true;
}

/**
 * Fungsi untuk membuat objek koneksi SNMP
 * @param {Object} data - Data koneksi SNMP
 * @returns {Object} - Objek koneksi SNMP
 */
function createSnmpConnEntity(data = {}) {
  return {
    ip_addr: data.ip_addr || '',
    port: data.port || 161, // Default SNMP port
    community_read: data.community_read || 'public',
    community_write: data.community_write || 'private'
  };
}

/**
 * Fungsi untuk validasi koneksi SNMP
 * @param {Object} data - Data koneksi SNMP
 * @returns {boolean} - True jika valid
 */
function validateSnmpConnEntity(data) {
  if (!isValidIPv4(data.ip_addr)) {
    return false;
  }

  if (!isValidPort(data.port)) {
    return false;
  }

  if (typeof data.community_read !== 'string') {
    return false;
  }

  if (typeof data.community_write !== 'string') {
    return false;
  }

  return true;
}

module.exports = {
  createTelnetConnEntity,
  validateTelnetConnEntity,
  createSshConnEntity,
  validateSshConnEntity,
  createSnmpConnEntity,
  validateSnmpConnEntity,
  isValidIPv4,
  isValidPort
}; ###
cat src/entities/netDeviceOdc.entity.js
/**
 * Entity untuk netDeviceOdc (perangkat Optical Distribution Cabinet)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Fungsi untuk memeriksa tipe anak yang valid untuk ODC Tray
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidTrayChild(child) {
  // Hanya menerima netDeviceOdp
  return child && child.type && child.type === 'odp';
}

/**
 * Fungsi untuk membuat objek Tray ODC
 * @param {Object} data - Data tray
 * @returns {Object} - Objek tray
 */
function createOdcTrayEntity(data = {}) {
  return {
    tray: data.tray || 1,
    start_core: data.start_core || 1,
    end_core: data.end_core || 1,
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data tray ODC
 * @param {Object} data - Data tray
 * @param {Array} existingTrays - Array tray yang sudah ada (untuk validasi keunikan)
 * @returns {boolean} - True jika valid
 */
function validateOdcTrayEntity(data, existingTrays = []) {
  // Validasi tray number (harus integer dan dimulai dari 1)
  if (typeof data.tray !== 'number' || !Number.isInteger(data.tray) || data.tray < 1) {
    return false;
  }
  
  // Validasi keunikan tray number
  if (existingTrays.some(t => t.tray === data.tray)) {
    return false;
  }
  
  // Validasi start_core (harus integer)
  if (typeof data.start_core !== 'number' || !Number.isInteger(data.start_core) || data.start_core < 1) {
    return false;
  }
  
  // Validasi end_core (harus integer dan >= start_core)
  if (typeof data.end_core !== 'number' || !Number.isInteger(data.end_core) || data.end_core < data.start_core) {
    return false;
  }
  
  // Validasi children
  if (!Array.isArray(data.children)) {
    return false;
  }
  
  // Validasi setiap anak, pastikan tipenya adalah ODP
  for (const child of data.children) {
    if (!isValidTrayChild(child)) {
      return false;
    }
  }
  
  return true;
}

/**
 * Fungsi untuk membuat objek netDeviceOdc
 * @param {Object} data - Data ODC
 * @returns {Object} - Objek netDeviceOdc
 */
function createNetDeviceOdcEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'odc'
  });
  
  // Buat array trays jika ada
  const trays = [];
  if (Array.isArray(data.trays)) {
    data.trays.forEach(trayData => {
      trays.push(createOdcTrayEntity(trayData));
    });
  }
  
  // Tambahkan properti khusus ODC
  return {
    ...baseEntity,
    available_tray: data.available_tray || 0,
    trays: trays
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOdc
 * @param {Object} data - Data ODC
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOdcEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'odc'})) {
    return false;
  }
  
  // Validasi available_tray
  if (typeof data.available_tray !== 'number' || !Number.isInteger(data.available_tray) || data.available_tray < 0) {
    return false;
  }
  
  // Validasi trays
  if (data.trays) {
    if (!Array.isArray(data.trays)) {
      return false;
    }
    
    const existingTrays = [];
    for (const tray of data.trays) {
      if (!validateOdcTrayEntity(tray, existingTrays)) {
        return false;
      }
      existingTrays.push(tray);
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceOdcEntity,
  validateNetDeviceOdcEntity,
  createOdcTrayEntity,
  validateOdcTrayEntity
};
###
cat src/entities/netDeviceOdp.entity.js
/**
 * Entity untuk netDeviceOdp (perangkat Optical Distribution Point)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Fungsi untuk memeriksa tipe anak yang valid untuk ODP
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidChild(child) {
  // Hanya menerima netDeviceOnt
  return child && child.type && child.type === 'ont';
}

/**
 * Fungsi untuk membuat objek netDeviceOdp
 * @param {Object} data - Data ODP
 * @returns {Object} - Objek netDeviceOdp
 */
function createNetDeviceOdpEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'odp'
  });
  
  // Tambahkan properti khusus ODP
  return {
    ...baseEntity,
    core_on_odc_tray: data.core_on_odc_tray || 1,
    available_port: data.available_port || 0,
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOdp
 * @param {Object} data - Data ODP
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOdpEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'odp'})) {
    return false;
  }
  
  // Validasi core_on_odc_tray (harus integer dan dimulai dari 1)
  if (typeof data.core_on_odc_tray !== 'number' || !Number.isInteger(data.core_on_odc_tray) || data.core_on_odc_tray < 1) {
    return false;
  }
  
  // Validasi available_port (harus integer lebih besar dari 0)
  if (typeof data.available_port !== 'number' || !Number.isInteger(data.available_port) || data.available_port < 0) {
    return false;
  }
  
  // Validasi children
  if (data.children) {
    if (!Array.isArray(data.children)) {
      return false;
    }
    
    // Validasi setiap anak, pastikan tipenya adalah ONT
    for (const child of data.children) {
      if (!isValidChild(child)) {
        return false;
      }
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceOdpEntity,
  validateNetDeviceOdpEntity
};
###
cat src/entities/netDeviceOlt.entity.js
/**
 * Entity untuk netDeviceOlt (perangkat Optical Line Terminal)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');
const { 
  createTelnetConnEntity, validateTelnetConnEntity,
  createSshConnEntity, validateSshConnEntity,
  createSnmpConnEntity, validateSnmpConnEntity
} = require('./netDeviceConn.entity');

/**
 * Enum untuk tipe PON
 * @enum {string}
 */
const PonTypes = {
  GPON: 'GPON',
  EPON: 'EPON'
};

/**
 * Fungsi untuk memeriksa tipe anak yang valid untuk port PON
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidPortChild(child) {
  // Hanya menerima netDeviceOdc
  return child && child.type && child.type === 'odc';
}

/**
 * Fungsi untuk membuat objek PON port
 * @param {Object} data - Data port PON
 * @returns {Object} - Objek port PON
 */
function createPonPortEntity(data = {}) {
  return {
    port: data.port || 1,
    max_client: data.max_client || 1,
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data PON port
 * @param {Object} data - Data port PON
 * @param {Array} existingPorts - Array port yang sudah ada (untuk validasi keunikan)
 * @returns {boolean} - True jika valid
 */
function validatePonPortEntity(data, existingPorts = []) {
  // Validasi port number (harus integer dan dimulai dari 1)
  if (typeof data.port !== 'number' || !Number.isInteger(data.port) || data.port < 1) {
    return false;
  }
  
  // Validasi keunikan port number
  if (existingPorts.some(p => p.port === data.port)) {
    return false;
  }
  
  // Validasi max_client (harus integer lebih besar dari 0)
  if (typeof data.max_client !== 'number' || !Number.isInteger(data.max_client) || data.max_client < 1) {
    return false;
  }
  
  // Validasi children
  if (!Array.isArray(data.children)) {
    return false;
  }
  
  // Validasi setiap anak, pastikan tipenya adalah ODC
  for (const child of data.children) {
    if (!isValidPortChild(child)) {
      return false;
    }
  }
  
  return true;
}

/**
 * Fungsi untuk membuat objek netDeviceOlt
 * @param {Object} data - Data OLT
 * @returns {Object} - Objek netDeviceOlt
 */
function createNetDeviceOltEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'olt'
  });
  
  // Buat array pon_port berdasarkan available_pon
  const ponPorts = [];
  const availablePon = data.available_pon || 0;
  
  // Jika available_pon ada, buat port sejumlah available_pon
  if (availablePon > 0) {
    for (let i = 1; i <= availablePon; i++) {
      ponPorts.push(createPonPortEntity({
        port: i,
        max_client: 64, // Default max client untuk GPON
        children: []
      }));
    }
  } 
  // Jika pon_port sudah ada di data, gunakan itu
  else if (Array.isArray(data.pon_port)) {
    data.pon_port.forEach(portData => {
      ponPorts.push(createPonPortEntity(portData));
    });
  }
  
  // Tambahkan properti khusus OLT
  return {
    ...baseEntity,
    vendor: data.vendor || '',
    model: data.model || '',
    sn: data.sn || '',
    telnet_conn: data.telnet_conn ? createTelnetConnEntity(data.telnet_conn) : null,
    ssh_conn: data.ssh_conn ? createSshConnEntity(data.ssh_conn) : null,
    snmp_conn: data.snmp_conn ? createSnmpConnEntity(data.snmp_conn) : null,
    pon_type: data.pon_type || PonTypes.GPON,
    pon_port: ponPorts
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOlt
 * @param {Object} data - Data OLT
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOltEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'olt'})) {
    return false;
  }
  
  // Validasi properti vendor
  if (typeof data.vendor !== 'string') {
    return false;
  }
  
  // Validasi properti model
  if (typeof data.model !== 'string') {
    return false;
  }
  
  // Validasi properti serial number
  if (typeof data.sn !== 'string') {
    return false;
  }
  
  // Validasi koneksi telnet
  if (data.telnet_conn && !validateTelnetConnEntity(data.telnet_conn)) {
    return false;
  }
  
  // Validasi koneksi SSH
  if (data.ssh_conn && !validateSshConnEntity(data.ssh_conn)) {
    return false;
  }
  
  // Validasi koneksi SNMP
  if (data.snmp_conn && !validateSnmpConnEntity(data.snmp_conn)) {
    return false;
  }
  
  // Validasi pon_type
  if (data.pon_type && !Object.values(PonTypes).includes(data.pon_type)) {
    return false;
  }
  
  // Validasi pon_port
  if (data.pon_port) {
    if (!Array.isArray(data.pon_port)) {
      return false;
    }
    
    const existingPorts = [];
    for (const port of data.pon_port) {
      if (!validatePonPortEntity(port, existingPorts)) {
        return false;
      }
      existingPorts.push(port);
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceOltEntity,
  validateNetDeviceOltEntity,
  PonTypes,
  createPonPortEntity,
  validatePonPortEntity
};
###
cat src/entities/netDeviceOnt.entity.js
/**
 * Entity untuk netDeviceOnt (perangkat Optical Network Terminal)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Fungsi untuk membuat objek netDeviceOnt
 * @param {Object} data - Data ONT
 * @returns {Object} - Objek netDeviceOnt
 */
function createNetDeviceOntEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'ont'
  });
  
  // Tambahkan properti khusus ONT
  return {
    ...baseEntity,
    vendor: data.vendor || '',
    model: data.model || '',
    sn: data.sn || ''
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceOnt
 * @param {Object} data - Data ONT
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceOntEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'ont'})) {
    return false;
  }
  
  // Validasi properti vendor
  if (typeof data.vendor !== 'string') {
    return false;
  }
  
  // Validasi properti model
  if (typeof data.model !== 'string') {
    return false;
  }
  
  // Validasi properti serial number
  if (typeof data.sn !== 'string') {
    return false;
  }
  
  return true;
}

module.exports = {
  createNetDeviceOntEntity,
  validateNetDeviceOntEntity
};
###
cat src/entities/netDeviceRouter.entity.js
/**
 * Entity untuk netDeviceRouter (perangkat router)
 */

const { createNetDeviceEntity, validateNetDeviceEntity } = require('./netDevice.entity');

/**
 * Enum untuk tipe koneksi router
 * @enum {string}
 */
const ConnectionTypes = {
  OPENVPN: 'OPENVPN',
  PUBLIC: 'PUBLIC',
  ZEROTIER: 'ZEROTIER'
};

/**
 * Fungsi untuk validasi alamat IP v4
 * @param {string} ip - Alamat IP yang akan divalidasi
 * @returns {boolean} - True jika valid
 */
function isValidIPv4(ip) {
  if (typeof ip !== 'string') return false;
  
  // Pola IPv4: xxx.xxx.xxx.xxx
  const pattern = /^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  return pattern.test(ip);
}

/**
 * Fungsi untuk memeriksa tipe anak yang valid
 * @param {Object} child - Objek anak yang akan diperiksa
 * @returns {boolean} - True jika valid
 */
function isValidChild(child) {
  // Hanya menerima netDeviceOlt
  const validTypes = ['olt'];
  return child && child.type && validTypes.includes(child.type);
}

/**
 * Fungsi untuk membuat objek netDeviceRouter
 * @param {Object} data - Data router
 * @returns {Object} - Objek netDeviceRouter
 */
function createNetDeviceRouterEntity(data = {}) {
  // Buat base netDevice entity
  const baseEntity = createNetDeviceEntity({
    ...data,
    type: 'router'
  });
  
  // Tambahkan properti khusus router
  return {
    ...baseEntity,
    connection_type: data.connection_type || ConnectionTypes.PUBLIC,
    ip_addr: data.ip_addr || '',
    // Children hanya bisa berisi OLT
    children: data.children || []
  };
}

/**
 * Fungsi untuk memvalidasi data netDeviceRouter
 * @param {Object} data - Data router
 * @returns {boolean} - True jika valid
 */
function validateNetDeviceRouterEntity(data) {
  // Validasi base properties
  if (!validateNetDeviceEntity({...data, type: 'router'})) {
    return false;
  }
  
  // Validasi connection_type
  if (data.connection_type && !Object.values(ConnectionTypes).includes(data.connection_type)) {
    return false;
  }
  
  // Validasi ip_addr
  if (data.ip_addr && !isValidIPv4(data.ip_addr)) {
    return false;
  }
  
  // Validasi children
  if (data.children) {
    if (!Array.isArray(data.children)) {
      return false;
    }
    
    // Validasi setiap anak, pastikan tipenya valid
    for (const child of data.children) {
      if (!isValidChild(child)) {
        return false;
      }
    }
  }
  
  return true;
}

module.exports = {
  createNetDeviceRouterEntity,
  validateNetDeviceRouterEntity,
  ConnectionTypes,
  isValidChild
};
###
cat src/services/address.entity.js
###
cat src/services/branch.entity.js
###
cat src/services/branchAccess.entity.js
###
cat src/services/contact.entity.js
###
cat src/services/location.entity.js
###
cat src/services/log.entity.js
###
cat src/services/netDevice.entity.js
###
cat src/services/netDeviceConn.entity.js
###
cat src/services/netDeviceOdc.entity.js
###
cat src/services/netDeviceOdp.entity.js
###
cat src/services/netDeviceOlt.entity.js
###
cat src/services/netDeviceOnt.entity.js
###
cat src/services/netDeviceRouter.entity.js
###


saran untuk services:

Setelah melihat isi folder services, saya merevisi rekomendasi prioritas perbaikan. Berikut analisis dan urutan yang lebih tepat:

1. **Services (Prioritas Pertama)**
Alasan:
- Sudah ada implementasi dasar yang bagus
- Beberapa service masih kosong (`netDevice.service.js`, `netDeviceFactory.service.js`)
- Perlu standarisasi error handling dan logging
- Perlu implementasi dependency injection
- Perlu implementasi service layer pattern yang lebih baik

2. **Utils (Prioritas Kedua)**
Alasan:
- Digunakan oleh services yang akan kita perbaiki
- Masih ada utils yang belum diimplementasi
- Perlu standardisasi error handling

3. **Entities (Prioritas Ketiga)**
[urutan selanjutnya sama seperti sebelumnya]

Mari kita fokus ke **Services** terlebih dahulu. Berikut area yang perlu diperbaiki:

1. **Service Base Class**:
```javascript
// services/base.service.js
class BaseService {
  constructor(repository, logger) {
    this.repository = repository;
    this.logger = logger;
    this.context = null;
  }

  setContext(context) {
    this.context = context;
  }

  logInfo(message, data = {}) {
    this.logger.info(message, {
      ...data,
      service: this.constructor.name,
      requestId: this.context?.getRequestId(),
      userId: this.context?.getUserId()
    });
  }

  handleError(error, operation) {
    this.logger.error(`Error in ${operation}`, {
      service: this.constructor.name,
      error: error.message,
      stack: error.stack,
      requestId: this.context?.getRequestId()
    });
    throw error;
  }
}
```

2. **Service Factory**:
```javascript
// services/serviceFactory.js
class ServiceFactory {
  constructor(logger, requestContext) {
    this.logger = logger;
    this.requestContext = requestContext;
  }

  createBranchService() {
    const service = new BranchService(branchRepository, this.logger);
    service.setContext(this.requestContext);
    return service;
  }

  createNetDeviceService() {
    const service = new NetDeviceService(netDeviceRepository, this.logger);
    service.setContext(this.requestContext);
    return service;
  }
}
```

3. **Network Device Factory Service**:
```javascript
// services/netDeviceFactory.service.js
class NetDeviceFactoryService extends BaseService {
  createDevice(type, data) {
    try {
      switch(type) {
        case 'router':
          return this.createRouter(data);
        case 'olt':
          return this.createOlt(data);
        case 'odc':
          return this.createOdc(data);
        case 'odp':
          return this.createOdp(data);
        case 'ont':
          return this.createOnt(data);
        default:
          throw new Error(`Unknown device type: ${type}`);
      }
    } catch (error) {
      this.handleError(error, 'createDevice');
    }
  }

  // Implementasi method create untuk setiap device
}
```

4. **Network Device Service**:
```javascript
// services/netDevice.service.js
class NetDeviceService extends BaseService {
  constructor(repository, logger, factory) {
    super(repository, logger);
    this.factory = factory;
  }

  async getDeviceById(id, type, options = {}) {
    try {
      const device = await this.repository.findById(id, type, options);
      if (!device) {
        throw new Error(`${type} device not found`);
      }
      return device;
    } catch (error) {
      this.handleError(error, 'getDeviceById');
    }
  }

  async createDevice(type, data) {
    try {
      const device = this.factory.createDevice(type, data);
      return await this.repository.create(device);
    } catch (error) {
      this.handleError(error, 'createDevice');
    }
  }
}
```

5. **Perbaikan JWKS Service**:
```javascript
// services/jwks.service.js
class JwksService extends BaseService {
  constructor(config, logger) {
    super(null, logger);
    this.config = config;
    this.jwks = null;
  }

  async initialize() {
    try {
      this.jwks = await this.fetchJwks();
    } catch (error) {
      this.handleError(error, 'initialize');
    }
  }

  async refreshJwks() {
    try {
      this.jwks = await this.fetchJwks();
    } catch (error) {
      this.handleError(error, 'refreshJwks');
    }
  }
}
```



